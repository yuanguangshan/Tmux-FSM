diff --git a/fsm/engine.go b/fsm/engine.go
index b1ab11d..453a0c4 100644
--- a/fsm/engine.go
+++ b/fsm/engine.go
@@ -2,7 +2,10 @@ package fsm
 
 import (
 	"fmt"
+	"strings"
 	"time"
+	"tmux-fsm/intent"
+	"tmux-fsm/resolver"
 )
 
 // RawTokenEmitter 用于发送 RawToken 的接口
@@ -10,13 +13,50 @@ type RawTokenEmitter interface {
 	Emit(RawToken)
 }
 
+// EngineAdapter 实现resolver.EngineAdapter接口
+type EngineAdapter struct {
+	engine *Engine
+}
+
+func (ea *EngineAdapter) SendKeys(keys ...string) {
+	// 将键发送到tmux
+	args := append([]string{"send-keys", "-t", "."}, keys...)
+	tmux(strings.Join(args, " "))
+}
+
+func (ea *EngineAdapter) RunAction(name string) {
+	ea.engine.RunAction(name)
+}
+
+func (ea *EngineAdapter) GetVisualMode() intent.VisualMode {
+	return ea.engine.visualMode
+}
+
+func (ea *EngineAdapter) SetVisualMode(mode intent.VisualMode) {
+	ea.engine.visualMode = mode
+}
+
+func (ea *EngineAdapter) EnterVisualMode(mode intent.VisualMode) {
+	ea.engine.visualMode = mode
+	// 可能需要更新UI显示
+	UpdateUI()
+}
+
+func (ea *EngineAdapter) ExitVisualMode() {
+	ea.engine.visualMode = intent.VisualNone
+	// 可能需要更新UI显示
+	UpdateUI()
+}
+
 // Engine FSM 引擎结构体
 type Engine struct {
-	Active     string
-	Keymap     *Keymap
-	layerTimer *time.Timer
-	count      int              // 用于存储数字计数
-	emitters   []RawTokenEmitter // 用于向外部发送token的多个接收者
+	Active       string
+	Keymap       *Keymap
+	layerTimer   *time.Timer
+	count        int              // 用于存储数字计数
+	emitters     []RawTokenEmitter // 用于向外部发送token的多个接收者
+	visualMode   intent.VisualMode // 视觉模式状态
+	resolver     *resolver.Resolver // 解析器
 }
 
 // FSMStatus FSM 状态信息，用于UI更新
@@ -53,12 +93,21 @@ var defaultEngine *Engine
 
 // NewEngine 创建新的 FSM 引擎实例（显式注入 Keymap）
 func NewEngine(km *Keymap) *Engine {
-	return &Engine{
-		Active:   "NAV",
-		Keymap:   km,
-		count:    0,
-		emitters: make([]RawTokenEmitter, 0),
+	engine := &Engine{
+		Active:     "NAV",
+		Keymap:     km,
+		count:      0,
+		emitters:   make([]RawTokenEmitter, 0),
+		visualMode: intent.VisualNone,
 	}
+
+	// 创建引擎适配器
+	adapter := &EngineAdapter{engine: engine}
+
+	// 初始化解析器
+	engine.resolver = resolver.New(adapter)
+
+	return engine
 }
 
 // InitEngine 初始化全局唯一 Engine
@@ -267,6 +316,14 @@ func tmux(cmd string) {
 }
 
 
+// DispatchIntent 分发意图给解析器
+func (e *Engine) DispatchIntent(i *intent.Intent) error {
+	if e.resolver != nil {
+		return e.resolver.Resolve(i)
+	}
+	return nil
+}
+
 func EnterFSM() {
 	if defaultEngine == nil {
 		InitEngine(&KM)
diff --git a/intent/intent.go b/intent/intent.go
index 49de9ac..a891fd3 100644
--- a/intent/intent.go
+++ b/intent/intent.go
@@ -23,6 +23,7 @@ const (
 	IntentCount
 	IntentOperator
 	IntentMotion
+	IntentMacro
 )
 
 
@@ -70,6 +71,16 @@ const (
 	LineWise
 )
 
+// VisualMode 视觉模式类型
+type VisualMode int
+
+const (
+	VisualNone VisualMode = iota
+	VisualChar
+	VisualLine
+	VisualBlock
+)
+
 // Intent 意图结构（用于执行层）
 type Intent struct {
 	Kind         IntentKind             `json:"kind"`
@@ -80,6 +91,7 @@ type Intent struct {
 	SnapshotHash string                 `json:"snapshot_hash"` // Phase 6.2
 	AllowPartial bool                   `json:"allow_partial"` // Phase 7: Explicit permission for fuzzy resolution
 	Anchors      []Anchor               `json:"anchors,omitempty"` // Phase 11.0: Support for multi-cursor / multi-selection
+	UseRange     bool                   `json:"use_range"`     // Phase 12: Use range-based operations
 }
 
 // SemanticTarget 语义目标（而非物理位置）
diff --git a/kernel/decide.go b/kernel/decide.go
index 503a992..3eab3a3 100644
--- a/kernel/decide.go
+++ b/kernel/decide.go
@@ -55,10 +55,11 @@ func (k *Kernel) Decide(key string) *Decision {
 		k.FSM.RemoveEmitter(grammarEmitter)
 
 		if dispatched && lastIntent != nil {
-			return &Decision{
-				Kind:   DecisionFSM,
-				Intent: lastIntent,
+			// 直接执行意图，而不是返回决策
+			if k.FSM != nil {
+				_ = k.FSM.DispatchIntent(lastIntent)
 			}
+			return nil // 意图已直接执行
 		}
 
 		if dispatched {
diff --git a/resolver/context.go b/resolver/context.go
new file mode 100644
index 0000000..01a5eee
--- /dev/null
+++ b/resolver/context.go
@@ -0,0 +1,8 @@
+package resolver
+
+// ExecContext 执行上下文，用于隔离不同类型的执行
+type ExecContext struct {
+	FromMacro  bool // 是否来自宏播放
+	FromRepeat bool // 是否来自重复操作
+	FromUndo   bool // 是否来自撤销操作
+}
\ No newline at end of file
diff --git a/resolver/macro.go b/resolver/macro.go
new file mode 100644
index 0000000..695ded4
--- /dev/null
+++ b/resolver/macro.go
@@ -0,0 +1,123 @@
+package resolver
+
+import (
+	"tmux-fsm/intent"
+)
+
+// Macro 宏结构
+type Macro struct {
+	Name   string
+	IntentSequence []*intent.Intent
+	Active bool
+}
+
+// MacroManager 宏管理器
+type MacroManager struct {
+	macros   map[string]*Macro
+	recording *Macro
+}
+
+// NewMacroManager 创建新的宏管理器
+func NewMacroManager() *MacroManager {
+	return &MacroManager{
+		macros: make(map[string]*Macro),
+	}
+}
+
+// StartRecording 开始录制宏
+func (mm *MacroManager) StartRecording(name string) {
+	macro := &Macro{
+		Name:           name,
+		IntentSequence: make([]*intent.Intent, 0),
+		Active:         true,
+	}
+	mm.recording = macro
+}
+
+// StopRecording 停止录制宏
+func (mm *MacroManager) StopRecording() {
+	if mm.recording != nil {
+		mm.macros[mm.recording.Name] = mm.recording
+		mm.recording = nil
+	}
+}
+
+// AddIntentToRecording 向正在录制的宏添加意图
+func (mm *MacroManager) AddIntentToRecording(i *intent.Intent) {
+	if mm.recording != nil {
+		// 只记录某些类型的意图
+		if i.Kind == intent.IntentMove || i.Kind == intent.IntentOperator {
+			mm.recording.IntentSequence = append(mm.recording.IntentSequence, i)
+		}
+	}
+}
+
+// GetMacro 获取宏
+func (mm *MacroManager) GetMacro(name string) *Macro {
+	return mm.macros[name]
+}
+
+// PlayMacro 播放宏
+func (mm *MacroManager) PlayMacro(name string) []*intent.Intent {
+	macro := mm.macros[name]
+	if macro == nil {
+		return nil
+	}
+	return macro.IntentSequence
+}
+
+// 在resolver中添加macro manager
+func (r *Resolver) initMacro() {
+	if r.macroManager == nil {
+		r.macroManager = NewMacroManager()
+	}
+}
+
+// resolveMacroWithContext 解析宏意图（带上下文）
+func (r *Resolver) resolveMacroWithContext(i *intent.Intent, ctx ExecContext) error {
+	r.initMacro()
+
+	operation, ok := i.Meta["operation"].(string)
+	if !ok {
+		return nil
+	}
+
+	switch operation {
+	case "start_recording":
+		name, ok := i.Meta["name"].(string)
+		if ok {
+			r.macroManager.StartRecording(name)
+		}
+	case "stop_recording":
+		r.macroManager.StopRecording()
+	case "play":
+		name, ok := i.Meta["name"].(string)
+		if ok {
+			sequence := r.macroManager.PlayMacro(name)
+			for _, intent := range sequence {
+				// 创建新的上下文，标记为来自宏
+				newCtx := ExecContext{
+					FromMacro:  true,
+					FromRepeat: ctx.FromRepeat, // 保持重复上下文
+					FromUndo:   ctx.FromUndo,   // 保持撤销上下文
+				}
+				// 递归执行宏中的每个意图
+				_ = r.ResolveWithContext(intent, newCtx)
+			}
+		}
+	}
+
+	return nil
+}
+
+// resolveMacro 解析宏意图（兼容旧接口）
+func (r *Resolver) resolveMacro(i *intent.Intent) error {
+	return r.resolveMacroWithContext(i, ExecContext{})
+}
+
+// 在执行意图时，如果正在录制宏，则添加到宏中
+func (r *Resolver) recordIntentForMacro(i *intent.Intent) {
+	if r.macroManager != nil && r.macroManager.recording != nil {
+		r.macroManager.AddIntentToRecording(i)
+	}
+}
\ No newline at end of file
diff --git a/resolver/move.go b/resolver/move.go
new file mode 100644
index 0000000..2c000af
--- /dev/null
+++ b/resolver/move.go
@@ -0,0 +1,160 @@
+package resolver
+
+import (
+	"tmux-fsm/intent"
+)
+
+// resolveMove 解析移动意图
+func (r *Resolver) resolveMove(i *intent.Intent) error {
+	count := max(1, i.Count)
+
+	// 检查是否在视觉模式下
+	visualMode := r.engine.GetVisualMode()
+	inVisualMode := visualMode != intent.VisualNone
+
+	switch i.Target.Kind {
+	case intent.TargetChar:
+		return r.resolveCharMove(i, count, inVisualMode)
+
+	case intent.TargetLine:
+		return r.resolveLineMove(i, inVisualMode)
+
+	case intent.TargetWord:
+		return r.resolveWordMove(i, count, inVisualMode)
+
+	default:
+		return nil
+	}
+}
+
+// resolveCharMove 解析字符级移动
+func (r *Resolver) resolveCharMove(i *intent.Intent, count int, inVisualMode bool) error {
+	var key string
+
+	// 根据方向确定按键
+	switch i.Target.Direction {
+	case "left":
+		key = "Left"
+	case "right":
+		key = "Right"
+	case "up":
+		key = "Up"
+	case "down":
+		key = "Down"
+	default:
+		// 如果没有明确方向，尝试从Value中获取
+		if i.Target.Value == "h" {
+			key = "Left"
+		} else if i.Target.Value == "j" {
+			key = "Down"
+		} else if i.Target.Value == "k" {
+			key = "Up"
+		} else if i.Target.Value == "l" {
+			key = "Right"
+		}
+	}
+
+	// 如果在视觉模式下，需要先进入copy-mode
+	if inVisualMode {
+		r.engine.SendKeys("Escape")
+		r.engine.SendKeys("copy-mode")
+		r.engine.SendKeys("Space") // 开始选择
+	}
+
+	// 发送按键
+	for n := 0; n < count; n++ {
+		r.engine.SendKeys(key)
+	}
+
+	// 如果在视觉模式下，退出copy-mode
+	if inVisualMode {
+		r.engine.SendKeys("q") // 退出copy-mode但保持选择
+	}
+
+	return nil
+}
+
+// resolveLineMove 解析行级移动
+func (r *Resolver) resolveLineMove(i *intent.Intent, inVisualMode bool) error {
+	var key string
+
+	// 根据范围确定按键
+	switch i.Target.Scope {
+	case "start":
+		key = "Home"
+	case "end":
+		key = "End"
+	case "whole":
+		// 行整体移动，可能需要特殊处理
+		if inVisualMode {
+			r.engine.SendKeys("Escape")
+			r.engine.SendKeys("copy-mode")
+			r.engine.SendKeys("Space") // 开始选择
+			r.engine.SendKeys("End")   // 移动到行尾
+			r.engine.SendKeys("q")     // 退出但保持选择
+		}
+		return nil
+	default:
+		return nil
+	}
+
+	// 如果在视觉模式下，需要特殊处理
+	if inVisualMode {
+		r.engine.SendKeys("Escape")
+		r.engine.SendKeys("copy-mode")
+		r.engine.SendKeys("Space") // 开始选择
+	}
+
+	r.engine.SendKeys(key)
+
+	if inVisualMode {
+		r.engine.SendKeys("q") // 退出但保持选择
+	}
+
+	return nil
+}
+
+// resolveWordMove 解析单词级移动
+func (r *Resolver) resolveWordMove(i *intent.Intent, count int, inVisualMode bool) error {
+	var key string
+
+	// 根据方向确定按键
+	switch i.Target.Direction {
+	case "forward":
+		key = "M-f" // Alt+f - 下一个单词
+	case "backward":
+		key = "M-b" // Alt+b - 上一个单词
+	default:
+		// 从Value中获取
+		if i.Target.Value == "w" {
+			key = "M-f"
+		} else if i.Target.Value == "b" {
+			key = "M-b"
+		}
+	}
+
+	// 如果在视觉模式下，需要特殊处理
+	if inVisualMode {
+		r.engine.SendKeys("Escape")
+		r.engine.SendKeys("copy-mode")
+		r.engine.SendKeys("Space") // 开始选择
+	}
+
+	// 发送按键
+	for n := 0; n < count; n++ {
+		r.engine.SendKeys(key)
+	}
+
+	if inVisualMode {
+		r.engine.SendKeys("q") // 退出但保持选择
+	}
+
+	return nil
+}
+
+func max(a, b int) int {
+	if a > b {
+		return a
+	}
+	return b
+}
\ No newline at end of file
diff --git a/resolver/operator.go b/resolver/operator.go
new file mode 100644
index 0000000..1887287
--- /dev/null
+++ b/resolver/operator.go
@@ -0,0 +1,189 @@
+package resolver
+
+import (
+	"tmux-fsm/intent"
+)
+
+// resolveOperatorWithContext 解析操作意图（带上下文）
+func (r *Resolver) resolveOperatorWithContext(i *intent.Intent, ctx ExecContext) error {
+	op, ok := i.Meta["operator"].(intent.OperatorKind)
+	if !ok {
+		return nil
+	}
+
+	switch op {
+	case intent.OpDelete:
+		return r.resolveDelete(i)
+
+	case intent.OpYank:
+		return r.resolveYank(i)
+
+	case intent.OpChange:
+		return r.resolveChange(i)
+
+	default:
+		return nil
+	}
+}
+
+// resolveDelete 解析删除操作
+func (r *Resolver) resolveDelete(i *intent.Intent) error {
+	// 检查是否使用范围操作
+	if i.UseRange {
+		return r.resolveDeleteRange(i)
+	}
+
+	// 使用Vim-lite方式
+	return r.resolveDeleteVimLite(i)
+}
+
+// resolveDeleteVimLite Vim-lite方式删除
+func (r *Resolver) resolveDeleteVimLite(i *intent.Intent) error {
+	motion, ok := i.Meta["motion"].(intent.MotionKind)
+	if !ok {
+		// 如果没有motion，执行默认删除
+		r.engine.SendKeys("Delete")
+		return nil
+	}
+
+	// 根据motion类型执行不同的删除操作
+	switch motion {
+	case intent.MotionWord:
+		r.engine.SendKeys("Escape", "d", "w")
+	case intent.MotionLine:
+		r.engine.SendKeys("Escape", "d", "d")
+	case intent.MotionChar:
+		r.engine.SendKeys("Delete")
+	default:
+		r.engine.SendKeys("Delete")
+	}
+
+	return nil
+}
+
+// resolveDeleteRange 范围删除（使用copy-mode）
+func (r *Resolver) resolveDeleteRange(i *intent.Intent) error {
+	r.engine.SendKeys("Escape")
+	r.engine.SendKeys("copy-mode")
+	r.engine.SendKeys("m") // 设置标记
+
+	// 复用move resolver来执行移动
+	moveIntent := &intent.Intent{
+		Kind:     intent.IntentMove,
+		Target:   i.Target,
+		Count:    i.Count,
+		UseRange: i.UseRange,
+	}
+
+	// 执行移动
+	_ = r.resolveMove(moveIntent)
+
+	r.engine.SendKeys("d") // 执行删除
+	r.engine.SendKeys("q") // 退出copy-mode
+
+	return nil
+}
+
+// resolveYank 解析复制操作
+func (r *Resolver) resolveYank(i *intent.Intent) error {
+	if i.UseRange {
+		return r.resolveYankRange(i)
+	}
+
+	// 使用Vim-lite方式
+	motion, ok := i.Meta["motion"].(intent.MotionKind)
+	if !ok {
+		// 默认复制当前行
+		r.engine.SendKeys("Escape", "y", "y")
+		return nil
+	}
+
+	// 根据motion类型执行不同的复制操作
+	switch motion {
+	case intent.MotionWord:
+		r.engine.SendKeys("Escape", "y", "w")
+	case intent.MotionLine:
+		r.engine.SendKeys("Escape", "y", "y")
+	case intent.MotionChar:
+		r.engine.SendKeys("Escape", "y", "l")
+	default:
+		r.engine.SendKeys("Escape", "y", "y")
+	}
+
+	return nil
+}
+
+// resolveYankRange 范围复制（使用copy-mode）
+func (r *Resolver) resolveYankRange(i *intent.Intent) error {
+	r.engine.SendKeys("Escape")
+	r.engine.SendKeys("copy-mode")
+	r.engine.SendKeys("m") // 设置标记
+
+	// 复用move resolver来执行移动
+	moveIntent := &intent.Intent{
+		Kind:     intent.IntentMove,
+		Target:   i.Target,
+		Count:    i.Count,
+		UseRange: i.UseRange,
+	}
+
+	// 执行移动
+	_ = r.resolveMove(moveIntent)
+
+	r.engine.SendKeys("y") // 执行复制
+	r.engine.SendKeys("q") // 退出copy-mode
+
+	return nil
+}
+
+// resolveChange 解析修改操作
+func (r *Resolver) resolveChange(i *intent.Intent) error {
+	if i.UseRange {
+		return r.resolveChangeRange(i)
+	}
+
+	// 使用Vim-lite方式
+	motion, ok := i.Meta["motion"].(intent.MotionKind)
+	if !ok {
+		// 默认修改当前行
+		r.engine.SendKeys("Escape", "c", "c")
+		return nil
+	}
+
+	// 根据motion类型执行不同的修改操作
+	switch motion {
+	case intent.MotionWord:
+		r.engine.SendKeys("Escape", "c", "w")
+	case intent.MotionLine:
+		r.engine.SendKeys("Escape", "c", "c")
+	case intent.MotionChar:
+		r.engine.SendKeys("Escape", "c", "l")
+	default:
+		r.engine.SendKeys("Escape", "c", "c")
+	}
+
+	return nil
+}
+
+// resolveChangeRange 范围修改（使用copy-mode）
+func (r *Resolver) resolveChangeRange(i *intent.Intent) error {
+	r.engine.SendKeys("Escape")
+	r.engine.SendKeys("copy-mode")
+	r.engine.SendKeys("m") // 设置标记
+
+	// 复用move resolver来执行移动
+	moveIntent := &intent.Intent{
+		Kind:     intent.IntentMove,
+		Target:   i.Target,
+		Count:    i.Count,
+		UseRange: i.UseRange,
+	}
+
+	// 执行移动
+	_ = r.resolveMove(moveIntent)
+
+	r.engine.SendKeys("c") // 执行修改
+	r.engine.SendKeys("q") // 退出copy-mode
+
+	return nil
+}
\ No newline at end of file
diff --git a/resolver/resolver.go b/resolver/resolver.go
new file mode 100644
index 0000000..9d51a22
--- /dev/null
+++ b/resolver/resolver.go
@@ -0,0 +1,159 @@
+package resolver
+
+import (
+	"errors"
+	"tmux-fsm/intent"
+)
+
+// EngineAdapter 定义引擎适配器接口
+type EngineAdapter interface {
+	SendKeys(keys ...string)
+	RunAction(name string)
+	GetVisualMode() intent.VisualMode
+	SetVisualMode(mode intent.VisualMode)
+	EnterVisualMode(mode intent.VisualMode)
+	ExitVisualMode()
+
+	// Selection 相关方法
+	EnterSelection(mode SelectionMode)
+	UpdateSelection(anchor, focus Cursor)
+	ExitSelection()
+	GetCurrentCursor() Cursor
+}
+
+// Resolver 解析器结构体
+type Resolver struct {
+	engine          EngineAdapter
+	undoTree        *UndoTree
+	macroManager    *MacroManager
+	lastRepeatAction *RepeatableAction
+	selection       *Selection
+}
+
+// RepeatableAction 可重复操作
+type RepeatableAction struct {
+	Operator *intent.Intent  // 操作符（如 delete）
+	Motion   *intent.Intent  // 动作（如 word）
+	Count    int             // 重复次数
+	// 可选：执行前的状态快照
+	PreState map[string]interface{} // 执行前状态（用于复杂操作）
+}
+
+// New 创建新的解析器实例
+func New(engine EngineAdapter) *Resolver {
+	return &Resolver{engine: engine}
+}
+
+// Resolve 解析意图并执行相应操作（默认上下文）
+func (r *Resolver) Resolve(i *intent.Intent) error {
+	return r.ResolveWithContext(i, ExecContext{})
+}
+
+// ResolveWithContext 解析意图并执行相应操作（带上下文）
+func (r *Resolver) ResolveWithContext(i *intent.Intent, ctx ExecContext) error {
+	if i == nil {
+		return errors.New("nil intent")
+	}
+
+	// 如果不是来自宏，且正在录制宏，则记录意图
+	if !ctx.FromMacro && r.macroManager != nil && r.macroManager.recording != nil {
+		r.recordIntentForMacro(i)
+	}
+
+	// 处理视觉模式切换
+	if err := r.handleVisualMode(i); err != nil {
+		return err
+	}
+
+	var err error
+	switch i.Kind {
+	case intent.IntentMove:
+		err = r.resolveMove(i)
+
+	case intent.IntentOperator:
+		err = r.resolveOperatorWithContext(i, ctx)
+
+	case intent.IntentVisual:
+		err = r.resolveVisual(i)
+
+	case intent.IntentUndo:
+		err = r.resolveUndo(i)
+
+	case intent.IntentRepeat:
+		err = r.resolveRepeatWithContext(i, ctx)
+
+	case intent.IntentMacro:
+		err = r.resolveMacro(i)
+
+	default:
+		return nil
+	}
+
+	// 如果不是Undo或Repeat操作，且不是来自重复操作，则记录到撤销树
+	if i.Kind != intent.IntentUndo && i.Kind != intent.IntentRepeat && !ctx.FromRepeat {
+		r.recordAction(i, intentKindToString(i.Kind))
+	}
+
+	// 如果不是来自重复操作，则更新lastRepeatIntent
+	if !ctx.FromRepeat {
+		r.lastRepeatIntent = i
+	}
+
+	return err
+}
+
+// intentKindToString 将IntentKind转换为字符串
+func intentKindToString(kind intent.IntentKind) string {
+	switch kind {
+	case intent.IntentMove:
+		return "move"
+	case intent.IntentOperator:
+		return "operator"
+	case intent.IntentVisual:
+		return "visual"
+	case intent.IntentInsert:
+		return "insert"
+	case intent.IntentDelete:
+		return "delete"
+	case intent.IntentMacro:
+		return "macro"
+	case intent.IntentRepeat:
+		return "repeat"
+	default:
+		return "other"
+	}
+}
+
+// resolveRepeatWithContext 解析重复意图（带上下文）
+func (r *Resolver) resolveRepeatWithContext(i *intent.Intent, ctx ExecContext) error {
+	if r.lastRepeatIntent == nil {
+		return nil
+	}
+
+	// 创建新的上下文，标记为来自重复
+	newCtx := ExecContext{
+		FromRepeat: true,
+		FromMacro:  ctx.FromMacro, // 保持宏上下文
+		FromUndo:   ctx.FromUndo,  // 保持撤销上下文
+	}
+
+	// 重新执行最后一次操作
+	return r.ResolveWithContext(r.lastRepeatIntent, newCtx)
+}
+
+// handleVisualMode 处理视觉模式切换
+func (r *Resolver) handleVisualMode(i *intent.Intent) error {
+	if i.Kind == intent.IntentVisual {
+		switch i.Meta["operation"] {
+		case "start_char":
+			r.engine.EnterVisualMode(intent.VisualChar)
+		case "start_line":
+			r.engine.EnterVisualMode(intent.VisualLine)
+		case "start_block":
+			r.engine.EnterVisualMode(intent.VisualBlock)
+		case "cancel":
+			r.engine.ExitVisualMode()
+		}
+	}
+	return nil
+}
\ No newline at end of file
diff --git a/resolver/selection.go b/resolver/selection.go
new file mode 100644
index 0000000..60f29e3
--- /dev/null
+++ b/resolver/selection.go
@@ -0,0 +1,21 @@
+package resolver
+
+type SelectionMode int
+
+const (
+	SelectionNone SelectionMode = iota
+	SelectionChar
+	SelectionLine
+	SelectionBlock
+)
+
+type Cursor struct {
+	Line int
+	Col  int
+}
+
+type Selection struct {
+	Mode   SelectionMode
+	Anchor Cursor
+	Focus  Cursor
+}
\ No newline at end of file
diff --git a/resolver/undo.go b/resolver/undo.go
new file mode 100644
index 0000000..2db6921
--- /dev/null
+++ b/resolver/undo.go
@@ -0,0 +1,154 @@
+package resolver
+
+import (
+	"tmux-fsm/intent"
+)
+
+// UndoEntry 撤销条目
+type UndoEntry struct {
+	Intent *intent.Intent
+	Action string // 执行的动作
+	State  map[string]interface{} // 执行前的状态
+}
+
+// UndoTree 撤销树结构
+type UndoTree struct {
+	entries []*UndoEntry
+	current int
+	maxSize int
+}
+
+// NewUndoTree 创建新的撤销树
+func NewUndoTree(maxSize int) *UndoTree {
+	return &UndoTree{
+		entries: make([]*UndoEntry, 0, maxSize),
+		current: -1,
+		maxSize: maxSize,
+	}
+}
+
+// Add 添加撤销条目
+func (ut *UndoTree) Add(entry *UndoEntry) {
+	// 如果当前不在末尾，截断后续历史
+	if ut.current < len(ut.entries)-1 {
+		ut.entries = ut.entries[:ut.current+1]
+	}
+
+	// 添加新条目
+	ut.entries = append(ut.entries, entry)
+	ut.current = len(ut.entries) - 1
+
+	// 如果超出最大大小，移除最早的条目
+	if len(ut.entries) > ut.maxSize {
+		ut.entries = ut.entries[1:]
+		ut.current = len(ut.entries) - 1
+	}
+}
+
+// Undo 执行撤销
+func (ut *UndoTree) Undo() *UndoEntry {
+	if ut.current < 0 {
+		return nil
+	}
+
+	entry := ut.entries[ut.current]
+	ut.current--
+	return entry
+}
+
+// Redo 执行重做
+func (ut *UndoTree) Redo() *UndoEntry {
+	if ut.current >= len(ut.entries)-1 {
+		return nil
+	}
+
+	ut.current++
+	entry := ut.entries[ut.current]
+	return entry
+}
+
+// 在resolver中添加undo tree
+func (r *Resolver) initUndo() {
+	if r.undoTree == nil {
+		r.undoTree = NewUndoTree(100) // 最多保存100个操作
+	}
+}
+
+// resolveUndo 解析撤销意图
+func (r *Resolver) resolveUndo(i *intent.Intent) error {
+	r.initUndo()
+
+	operation, ok := i.Meta["operation"].(string)
+	if !ok {
+		operation = "undo" // 默认是撤销
+	}
+
+	switch operation {
+	case "undo":
+		return r.performUndo()
+	case "redo":
+		return r.performRedo()
+	default:
+		return r.performUndo() // 默认撤销
+	}
+}
+
+// performUndo 执行撤销
+func (r *Resolver) performUndo() error {
+	entry := r.undoTree.Undo()
+	if entry == nil {
+		// 没有可撤销的操作
+		return nil
+	}
+
+	// 执行逆向操作
+	// 这里需要根据之前的操作来执行逆向操作
+	// 例如，如果是删除操作，可能需要粘贴之前删除的内容
+	// 如果是插入操作，可能需要删除插入的内容
+	switch entry.Action {
+	case "delete":
+		// 如果有之前删除的内容，可以尝试恢复
+		// 这里需要更复杂的逻辑来处理具体撤销
+		r.engine.SendKeys("C-z") // 尝试使用系统撤销
+	case "insert":
+		// 撤销插入可能需要删除插入的内容
+		// 这需要更复杂的逻辑
+		r.engine.SendKeys("C-z") // 尝试使用系统撤销
+	default:
+		r.engine.SendKeys("C-z") // 通用撤销
+	}
+
+	return nil
+}
+
+// performRedo 执行重做
+func (r *Resolver) performRedo() error {
+	entry := r.undoTree.Redo()
+	if entry == nil {
+		// 没有可重做的操作
+		return nil
+	}
+
+	// 重新执行之前的操作
+	// 这里需要根据之前的意图重新执行操作
+	// 由于Intent是语义化的，我们可以重新解析并执行
+	_ = r.Resolve(entry.Intent)
+
+	return nil
+}
+
+// recordAction 记录操作以便撤销
+func (r *Resolver) recordAction(i *intent.Intent, action string) {
+	r.initUndo()
+
+	entry := &UndoEntry{
+		Intent: i,
+		Action: action,
+		State:  make(map[string]interface{}), // 可以保存执行前的状态
+	}
+
+	r.undoTree.Add(entry)
+}
+
+// 在resolver结构体中添加undo tree字段
+// 注意：我们需要在resolver.go中添加这个字段
\ No newline at end of file
diff --git a/resolver/visual.go b/resolver/visual.go
new file mode 100644
index 0000000..d00daa9
--- /dev/null
+++ b/resolver/visual.go
@@ -0,0 +1,46 @@
+package resolver
+
+import (
+	"tmux-fsm/intent"
+)
+
+// resolveVisual 解析视觉模式意图
+func (r *Resolver) resolveVisual(i *intent.Intent) error {
+	operation, ok := i.Meta["operation"].(string)
+	if !ok {
+		return nil
+	}
+
+	switch operation {
+	case "start_char":
+		r.engine.EnterVisualMode(intent.VisualChar)
+	case "start_line":
+		r.engine.EnterVisualMode(intent.VisualLine)
+	case "start_block":
+		r.engine.EnterVisualMode(intent.VisualBlock)
+	case "cancel":
+		r.engine.ExitVisualMode()
+	}
+
+	return nil
+}
+
+// 在视觉模式下执行操作
+func (r *Resolver) executeInVisualMode(op string) error {
+	// 获取当前视觉模式
+	visualMode := r.engine.GetVisualMode()
+	
+	if visualMode == intent.VisualNone {
+		// 如果不在视觉模式，直接执行操作
+		r.engine.SendKeys(op)
+		return nil
+	}
+
+	// 在视觉模式下执行操作
+	r.engine.SendKeys("Escape") // 确保退出插入模式
+	r.engine.SendKeys("copy-mode")
+	r.engine.SendKeys(op)        // 执行操作
+	r.engine.SendKeys("q")       // 退出copy-mode
+
+	return nil
+}
\ No newline at end of file
