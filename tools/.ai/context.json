[
  {
    "id": "file:gen-docs.go",
    "source": "file",
    "path": "gen-docs.go",
    "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode/utf8\"\n)\n\n/*\n====================================================\n Configuration & Globals\n====================================================\n*/\n\nconst versionStr = \"v2.0.0\"\n\n// Config é›†ä¸­ç®¡ç†é…ç½®\ntype Config struct {\n\tRootDir        string\n\tOutputFile     string\n\tIncludeExts    []string\n\tIncludeMatches []string\n\tExcludeExts    []string\n\tExcludeMatches []string\n\tMaxFileSize    int64\n\tNoSubdirs      bool\n\tVerbose        bool\n\tVersion        bool\n}\n\n// FileMetadata ä»…å­˜å‚¨å…ƒæ•°æ®ï¼Œä¸å­˜å†…å®¹\ntype FileMetadata struct {\n\tRelPath   string\n\tFullPath  string\n\tSize      int64\n\tLineCount int\n}\n\n// Stats ç»Ÿè®¡ä¿¡æ¯\ntype Stats struct {\n\tPotentialMatches   int // ç¬¦åˆåŒ…å«è§„åˆ™çš„æ–‡ä»¶æ•°\n\tExplicitlyExcluded int // ç¬¦åˆåŒ…å«è§„åˆ™ä½†è¢«æ’é™¤è§„åˆ™è¸¢æ‰çš„æ–‡ä»¶æ•°\n\tFileCount          int // æœ€ç»ˆå†™å…¥çš„æ–‡ä»¶æ•°\n\tTotalSize          int64\n\tTotalLines         int\n\tSkipped            int // å®Œå…¨ä¸åŒ¹é…è§„åˆ™çš„æ–‡ä»¶æ•°\n}\n\nvar defaultIgnorePatterns = []string{\n\t\".git\", \".idea\", \".vscode\",\n\t\"node_modules\", \"vendor\", \"dist\", \"build\", \"target\", \"bin\",\n\t\"__pycache__\", \".DS_Store\",\n\t\"package-lock.json\", \"yarn.lock\", \"go.sum\",\n}\n\n// è¯­è¨€æ˜ å°„è¡¨ï¼ˆå…¨å±€é…ç½®ï¼Œä¾¿äºæ‰©å±•ï¼‰\nvar languageMap = map[string]string{\n\t\".go\":    \"go\",\n\t\".js\":    \"javascript\",\n\t\".ts\":    \"typescript\",\n\t\".tsx\":   \"typescript\",\n\t\".jsx\":   \"javascript\",\n\t\".py\":    \"python\",\n\t\".java\":  \"java\",\n\t\".c\":     \"c\",\n\t\".cpp\":   \"cpp\",\n\t\".cc\":    \"cpp\",\n\t\".cxx\":   \"cpp\",\n\t\".h\":     \"c\",\n\t\".hpp\":   \"cpp\",\n\t\".rs\":    \"rust\",\n\t\".rb\":    \"ruby\",\n\t\".php\":   \"php\",\n\t\".cs\":    \"csharp\",\n\t\".swift\": \"swift\",\n\t\".kt\":    \"kotlin\",\n\t\".scala\": \"scala\",\n\t\".r\":     \"r\",\n\t\".sql\":   \"sql\",\n\t\".sh\":    \"bash\",\n\t\".bash\":  \"bash\",\n\t\".zsh\":   \"bash\",\n\t\".fish\":  \"fish\",\n\t\".ps1\":   \"powershell\",\n\t\".md\":    \"markdown\",\n\t\".html\":  \"html\",\n\t\".htm\":   \"html\",\n\t\".css\":   \"css\",\n\t\".scss\":  \"scss\",\n\t\".sass\":  \"sass\",\n\t\".less\":  \"less\",\n\t\".xml\":   \"xml\",\n\t\".json\":  \"json\",\n\t\".yaml\":  \"yaml\",\n\t\".yml\":   \"yaml\",\n\t\".toml\":  \"toml\",\n\t\".ini\":   \"ini\",\n\t\".conf\":  \"conf\",\n\t\".txt\":   \"text\",\n}\n\n/*\n====================================================\n Main Entry\n====================================================\n*/\n\nfunc main() {\n\tcfg := parseFlags()\n\tprintStartupInfo(cfg)\n\n\t// Phase 1: æ‰«ææ–‡ä»¶ç»“æ„\n\tfmt.Println(\"â³ æ­£åœ¨æ‰«ææ–‡ä»¶ç»“æ„...\")\n\tfiles, stats, err := scanDirectory(cfg)\n\tif err != nil {\n\t\tfmt.Printf(\"âŒ æ‰«æå¤±è´¥: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\t// Phase 2: æµå¼å†™å…¥\n\tfmt.Printf(\"ğŸ’¾ æ­£åœ¨å†™å…¥æ–‡æ¡£ [æ–‡ä»¶æ•°: %d]...\\n\", len(files))\n\tif err := writeMarkdownStream(cfg, files, stats); err != nil {\n\t\tfmt.Printf(\"âŒ å†™å…¥å¤±è´¥: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tprintSummary(stats, cfg.OutputFile)\n}\n\n/*\n====================================================\n Flag Parsing\n====================================================\n*/\n\nfunc parseFlags() Config {\n\tvar cfg Config\n\tvar include, match, exclude, excludeMatch string\n\tvar maxKB int64\n\n\tflag.StringVar(&cfg.RootDir, \"dir\", \".\", \"Root directory to scan\")\n\tflag.StringVar(&cfg.OutputFile, \"o\", \"\", \"Output markdown file\")\n\tflag.StringVar(&include, \"i\", \"\", \"Include extensions (e.g. .go,.js)\")\n\tflag.StringVar(&match, \"m\", \"\", \"Include path keywords (e.g. _test.go)\")\n\tflag.StringVar(&exclude, \"x\", \"\", \"Exclude extensions (e.g. .exe,.o)\")\n\tflag.StringVar(&excludeMatch, \"xm\", \"\", \"Exclude path keywords (e.g. vendor/,node_modules/)\")\n\tflag.Int64Var(&maxKB, \"max-size\", 500, \"Max file size in KB\")\n\tflag.BoolVar(&cfg.NoSubdirs, \"no-subdirs\", false, \"Do not scan subdirectories\")\n\tflag.BoolVar(&cfg.NoSubdirs, \"ns\", false, \"Alias for --no-subdirs\")\n\tflag.BoolVar(&cfg.Verbose, \"v\", false, \"Verbose output\")\n\tflag.BoolVar(&cfg.Version, \"version\", false, \"Show version\")\n\n\tflag.Parse()\n\n\tif cfg.Version {\n\t\tfmt.Printf(\"gen-docs %s\\n\", versionStr)\n\t\tos.Exit(0)\n\t}\n\n\t// æ”¯æŒä½ç½®å‚æ•°\n\tif args := flag.Args(); len(args) > 0 {\n\t\tcfg.RootDir = args[0]\n\t}\n\n\t// è‡ªåŠ¨ç”Ÿæˆè¾“å‡ºæ–‡ä»¶å\n\tif cfg.OutputFile == \"\" {\n\t\tbaseName := \"project\"\n\t\tcleanRoot := filepath.Clean(cfg.RootDir)\n\n\t\tif cleanRoot == \".\" || cleanRoot == string(filepath.Separator) {\n\t\t\t// å¦‚æœæ˜¯å½“å‰ç›®å½•ï¼Œå°è¯•è·å–æ–‡ä»¶å¤¹çœŸå®åç§°\n\t\t\tif abs, err := filepath.Abs(cleanRoot); err == nil {\n\t\t\t\tbaseName = filepath.Base(abs)\n\t\t\t}\n\t\t} else {\n\t\t\t// å°†è·¯å¾„ä¸­çš„åˆ†éš”ç¬¦å’Œç‚¹æ›¿æ¢ä¸ºä¸‹åˆ’çº¿\n\t\t\tbaseName = cleanRoot\n\t\t\tbaseName = strings.ReplaceAll(baseName, string(filepath.Separator), \"_\")\n\t\t\tbaseName = strings.ReplaceAll(baseName, \".\", \"_\")\n\t\t\t// æ¸…ç†è¿ç»­çš„ä¸‹åˆ’çº¿\n\t\t\tfor strings.Contains(baseName, \"__\") {\n\t\t\t\tbaseName = strings.ReplaceAll(baseName, \"__\", \"_\")\n\t\t\t}\n\t\t\tbaseName = strings.Trim(baseName, \"_\")\n\t\t}\n\n\t\tdate := time.Now().Format(\"20060102\")\n\t\tcfg.OutputFile = fmt.Sprintf(\"%s-%s-docs.md\", baseName, date)\n\t}\n\n\tcfg.IncludeExts = normalizeExts(include)\n\tcfg.IncludeMatches = splitAndTrim(match)\n\tcfg.ExcludeExts = normalizeExts(exclude)\n\tcfg.ExcludeMatches = splitAndTrim(excludeMatch)\n\tcfg.MaxFileSize = maxKB * 1024\n\n\treturn cfg\n}\n\nfunc splitAndTrim(input string) []string {\n\tif input == \"\" {\n\t\treturn nil\n\t}\n\tparts := strings.Split(input, \",\")\n\tvar result []string\n\tfor _, p := range parts {\n\t\tp = strings.TrimSpace(p)\n\t\tif p != \"\" {\n\t\t\tresult = append(result, p)\n\t\t}\n\t}\n\treturn result\n}\n\n/*\n====================================================\n Startup & Summary\n====================================================\n*/\n\nfunc printStartupInfo(cfg Config) {\n\tfmt.Println(\"â–¶ Gen-Docs Started\")\n\tfmt.Printf(\"  Root: %s\\n\", cfg.RootDir)\n\tfmt.Printf(\"  Out : %s\\n\", cfg.OutputFile)\n\tfmt.Printf(\"  Max : %d KB\\n\", cfg.MaxFileSize/1024)\n\tif len(cfg.IncludeExts) > 0 {\n\t\tfmt.Printf(\"  Only Ext: %v\\n\", cfg.IncludeExts)\n\t}\n\tif len(cfg.IncludeMatches) > 0 {\n\t\tfmt.Printf(\"  Match   : %v\\n\", cfg.IncludeMatches)\n\t}\n\tif len(cfg.ExcludeExts) > 0 {\n\t\tfmt.Printf(\"  Skip Ext: %v\\n\", cfg.ExcludeExts)\n\t}\n\tif len(cfg.ExcludeMatches) > 0 {\n\t\tfmt.Printf(\"  Skip Key: %v\\n\", cfg.ExcludeMatches)\n\t}\n\tfmt.Println()\n}\n\nfunc printSummary(stats Stats, output string) {\n\tfmt.Println(\"\\nâœ” å®Œæˆ!\")\n\tfmt.Printf(\"  ç¬¦åˆåŒ…å«è§„åˆ™ (Potential) : %d\\n\", stats.PotentialMatches)\n\tfmt.Printf(\"  ç”±äºæ’é™¤è§„åˆ™è¢«è¸¢é™¤ (Excluded): %d\\n\", stats.ExplicitlyExcluded)\n\tfmt.Printf(\"  æœ€ç»ˆå†™å…¥æ–‡ä»¶æ•° (Final)    : %d\\n\", stats.FileCount)\n\tfmt.Printf(\"  æ€»è¡Œæ•° (Total Lines)      : %d\\n\", stats.TotalLines)\n\tfmt.Printf(\"  æ€»ç‰©ç†å¤§å° (Total Size)   : %.2f KB\\n\", float64(stats.TotalSize)/1024)\n\tfmt.Printf(\"  æ— éœ€å¤„ç†çš„æ— å…³æ–‡ä»¶          : %d\\n\", stats.Skipped)\n\tfmt.Printf(\"  è¾“å‡ºè·¯å¾„                  : %s\\n\", output)\n}\n\n/*\n====================================================\n Directory Scanning\n====================================================\n*/\n\nfunc scanDirectory(cfg Config) ([]FileMetadata, Stats, error) {\n\tvar files []FileMetadata\n\tvar stats Stats\n\n\tabsOutput, _ := filepath.Abs(cfg.OutputFile)\n\n\terr := filepath.WalkDir(cfg.RootDir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\tlogf(cfg.Verbose, \"âš  æ— æ³•è®¿é—®: %s\", path)\n\t\t\tstats.Skipped++\n\t\t\treturn nil\n\t\t}\n\n\t\trelPath, _ := filepath.Rel(cfg.RootDir, path)\n\t\tif relPath == \".\" {\n\t\t\treturn nil\n\t\t}\n\n\t\t// å¤„ç†ç›®å½•\n\t\tif d.IsDir() {\n\t\t\tif cfg.NoSubdirs && relPath != \".\" {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\tif shouldIgnoreDir(d.Name()) {\n\t\t\t\tlogf(cfg.Verbose, \"âŠ˜ è·³è¿‡ç›®å½•: %s\", relPath)\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// æ’é™¤è¾“å‡ºæ–‡ä»¶è‡ªèº«\n\t\tif absPath, _ := filepath.Abs(path); absPath == absOutput {\n\t\t\treturn nil\n\t\t}\n\n\t\t// è·å–æ–‡ä»¶ä¿¡æ¯\n\t\tinfo, err := d.Info()\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\t// --- ç»†åŒ–è¿‡æ»¤é€»è¾‘ ---\n\t\t// 1. åŸºç¡€è¿‡æ»¤ï¼šè¿‡å¤§æˆ–äºŒè¿›åˆ¶\n\t\tif info.Size() > cfg.MaxFileSize || isBinaryFile(path) {\n\t\t\tstats.Skipped++\n\t\t\treturn nil\n\t\t}\n\n\t\t// 2. æ£€æŸ¥æ˜¯å¦ç¬¦åˆâ€œåŒ…å«â€æ„å›¾\n\t\tisIncluded := true\n\t\tif len(cfg.IncludeExts) > 0 || len(cfg.IncludeMatches) > 0 {\n\t\t\textMatched := false\n\t\t\tif len(cfg.IncludeExts) > 0 {\n\t\t\t\text := strings.ToLower(filepath.Ext(relPath))\n\t\t\t\tfor _, e := range cfg.IncludeExts {\n\t\t\t\t\tif ext == e {\n\t\t\t\t\t\textMatched = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\textMatched = true // å¦‚æœæ²¡è®¾åç¼€ç™½åå•ï¼Œé»˜è®¤åç¼€é€šè¿‡\n\t\t\t}\n\n\t\t\tpathMatched := false\n\t\t\tif len(cfg.IncludeMatches) > 0 {\n\t\t\t\tfor _, m := range cfg.IncludeMatches {\n\t\t\t\t\tif strings.Contains(relPath, m) {\n\t\t\t\t\t\tpathMatched = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpathMatched = true // å¦‚æœæ²¡è®¾å…³é”®å­—åŒ¹é…ï¼Œé»˜è®¤è·¯å¾„é€šè¿‡\n\t\t\t}\n\t\t\tisIncluded = extMatched && pathMatched\n\t\t}\n\n\t\tif !isIncluded {\n\t\t\tstats.Skipped++\n\t\t\treturn nil\n\t\t}\n\n\t\t// 3. ç¬¦åˆåŒ…å«æ„å›¾ (Potential Match)\n\t\tstats.PotentialMatches++\n\n\t\t// 4. æ£€æŸ¥æ˜¯å¦è¢«â€œæ’é™¤â€è§„åˆ™æ‹¦æˆª\n\t\tisExcluded := false\n\t\text := strings.ToLower(filepath.Ext(relPath))\n\t\tfor _, e := range cfg.ExcludeExts {\n\t\t\tif ext == e {\n\t\t\t\tisExcluded = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isExcluded && len(cfg.ExcludeMatches) > 0 {\n\t\t\tfor _, m := range cfg.ExcludeMatches {\n\t\t\t\tif strings.Contains(relPath, m) {\n\t\t\t\t\tisExcluded = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif isExcluded {\n\t\t\tstats.ExplicitlyExcluded++\n\t\t\treturn nil\n\t\t}\n\n\t\t// --- æœ€ç»ˆé€šè¿‡ ---\n\t\tlineCount, _ := countLines(path)\n\t\tfiles = append(files, FileMetadata{\n\t\t\tRelPath:   relPath,\n\t\t\tFullPath:  path,\n\t\t\tSize:      info.Size(),\n\t\t\tLineCount: lineCount,\n\t\t})\n\t\tstats.FileCount++\n\t\tstats.TotalLines += lineCount\n\t\tstats.TotalSize += info.Size()\n\n\t\tlogf(cfg.Verbose, \"âœ“ æ·»åŠ : %s (%d lines)\", relPath, lineCount)\n\t\treturn nil\n\t})\n\n\t// æ’åºä¿è¯è¾“å‡ºä¸€è‡´æ€§\n\tsort.Slice(files, func(i, j int) bool {\n\t\treturn files[i].RelPath < files[j].RelPath\n\t})\n\n\treturn files, stats, err\n}\n\n/*\n====================================================\n Ignore Rules\n====================================================\n*/\n\nfunc shouldIgnoreDir(name string) bool {\n\tif strings.HasPrefix(name, \".\") && name != \".\" {\n\t\treturn true\n\t}\n\tfor _, pattern := range defaultIgnorePatterns {\n\t\tif name == pattern {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc shouldIgnoreFile(relPath string, size int64, cfg Config) bool {\n\t// å¤§å°é™åˆ¶\n\tif size > cfg.MaxFileSize {\n\t\tlogf(cfg.Verbose, \"âŠ˜ æ–‡ä»¶è¿‡å¤§: %s\", relPath)\n\t\treturn true\n\t}\n\n\text := strings.ToLower(filepath.Ext(relPath))\n\n\t// æ’é™¤è§„åˆ™ä¼˜å…ˆ\n\tfor _, e := range cfg.ExcludeExts {\n\t\tif ext == e {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// è§„åˆ™ 0: ç¡¬æ€§æ’é™¤ (å…³é”®å­—æ’é™¤) - ä¼˜å…ˆçº§æœ€é«˜\n\tif len(cfg.ExcludeMatches) > 0 {\n\t\tfor _, m := range cfg.ExcludeMatches {\n\t\t\tif strings.Contains(relPath, m) {\n\t\t\t\tlogf(cfg.Verbose, \"âŠ˜ åŒ¹é…æ’é™¤å…³é”®å­— [%s]: %s\", m, relPath)\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// è§„åˆ™ 1: åŒ…å«åç¼€ç™½åå•\n\tif len(cfg.IncludeExts) > 0 {\n\t\tfound := false\n\t\tfor _, i := range cfg.IncludeExts {\n\t\t\tif ext == i {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// è§„åˆ™ 2: å…³é”®å­—åŒ…å«åŒ¹é…\n\tif len(cfg.IncludeMatches) > 0 {\n\t\tfound := false\n\t\tfor _, m := range cfg.IncludeMatches {\n\t\t\tif strings.Contains(relPath, m) {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// è·¯å¾„åŒ…å«å¿½ç•¥æ¨¡å¼\n\tparts := strings.Split(relPath, string(filepath.Separator))\n\tfor _, part := range parts {\n\t\tfor _, pattern := range defaultIgnorePatterns {\n\t\t\tif part == pattern {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\n/*\n====================================================\n File Utilities\n====================================================\n*/\n\nfunc normalizeExts(input string) []string {\n\tif input == \"\" {\n\t\treturn nil\n\t}\n\tparts := strings.Split(input, \",\")\n\tvar exts []string\n\tfor _, p := range parts {\n\t\tp = strings.TrimSpace(strings.ToLower(p))\n\t\tif !strings.HasPrefix(p, \".\") {\n\t\t\tp = \".\" + p\n\t\t}\n\t\texts = append(exts, p)\n\t}\n\treturn exts\n}\n\nfunc isBinaryFile(path string) bool {\n\t// å¿«é€Ÿè·¯å¾„ï¼šå‹ç¼©æ–‡ä»¶\n\tif strings.Contains(path, \".min.\") {\n\t\treturn true\n\t}\n\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn true\n\t}\n\tdefer f.Close()\n\n\t// åªè¯»å‰ 512 å­—èŠ‚\n\tbuf := make([]byte, 512)\n\tn, err := f.Read(buf)\n\tif err != nil && err != io.EOF {\n\t\treturn false\n\t}\n\tbuf = buf[:n]\n\n\t// NULL å­—èŠ‚æ£€æµ‹\n\tfor _, b := range buf {\n\t\tif b == 0 {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// UTF-8 æœ‰æ•ˆæ€§æ£€æµ‹\n\treturn !utf8.Valid(buf)\n}\n\nfunc detectLanguage(path string) string {\n\text := strings.ToLower(filepath.Ext(path))\n\tif lang, ok := languageMap[ext]; ok {\n\t\treturn lang\n\t}\n\treturn \"text\"\n}\n\n/*\n====================================================\n Markdown Output\n====================================================\n*/\n\nfunc writeMarkdownStream(cfg Config, files []FileMetadata, stats Stats) error {\n\tf, err := os.Create(cfg.OutputFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tw := bufio.NewWriterSize(f, 64*1024)\n\n\t// å†™å…¥å¤´éƒ¨\n\tfmt.Fprintln(w, \"# Project Documentation\")\n\tfmt.Fprintln(w)\n\tfmt.Fprintf(w, \"- **Generated at:** %s\\n\", time.Now().Format(\"2006-01-02 15:04:05\"))\n\tfmt.Fprintf(w, \"- **Root Dir:** `%s`\\n\", cfg.RootDir)\n\tfmt.Fprintf(w, \"- **File Count:** %d\\n\", stats.FileCount)\n\tfmt.Fprintf(w, \"- **Total Size:** %.2f KB\\n\", float64(stats.TotalSize)/1024)\n\tfmt.Fprintln(w)\n\n\t// å†™å…¥ç›®å½•\n\tfmt.Fprintln(w, \"<a name=\\\"toc\\\"></a>\")\n\tfmt.Fprintln(w, \"## ğŸ“‚ æ‰«æç›®å½•\")\n\tfor _, file := range files {\n\t\t// ç”Ÿæˆé”šç‚¹ï¼Œæ–¹ä¾¿åœ¨ Markdown ä¸­ç‚¹å‡»è·³è½¬\n\t\t// æ³¨æ„ï¼šé”šç‚¹åç§°åœ¨ GitHub ä¸­é€šå¸¸æ˜¯å°†ç©ºæ ¼è½¬ä¸ºæ¨ªæ å¹¶å…¨å°å†™\n\t\tanchor := strings.ReplaceAll(file.RelPath, \" \", \"-\")\n\t\tanchor = strings.ReplaceAll(anchor, \".\", \"\")\n\t\tanchor = strings.ReplaceAll(anchor, \"/\", \"\")\n\t\tanchor = strings.ToLower(anchor)\n\n\t\tfmt.Fprintf(w, \"- [%s](#ğŸ“„-%s) (%d lines, %.2f KB)\\n\", file.RelPath, anchor, file.LineCount, float64(file.Size)/1024)\n\t}\n\tfmt.Fprintln(w, \"\\n---\")\n\n\t// æµå¼å†™å…¥æ–‡ä»¶å†…å®¹\n\ttotal := len(files)\n\tfor i, file := range files {\n\t\tif !cfg.Verbose && (i%10 == 0 || i == total-1) {\n\t\t\tfmt.Printf(\"\\rğŸš€ å†™å…¥è¿›åº¦: %d/%d (%.1f%%)\", i+1, total, float64(i+1)/float64(total)*100)\n\t\t}\n\n\t\tif err := copyFileContent(w, file); err != nil {\n\t\t\tlogf(true, \"\\nâš  è¯»å–å¤±è´¥ %s: %v\", file.RelPath, err)\n\t\t\tcontinue\n\t\t}\n\t}\n\tfmt.Println()\n\n\t//ã€è¡¥å……ç»Ÿè®¡ã€‘\n\tfmt.Fprintln(w, \"\\n---\")\n\tfmt.Fprintf(w, \"### ğŸ“Š æœ€ç»ˆç»Ÿè®¡æ±‡æ€»\\n\")\n\tfmt.Fprintf(w, \"- **æ–‡ä»¶æ€»æ•°:** %d\\n\", stats.FileCount)\n\tfmt.Fprintf(w, \"- **ä»£ç æ€»è¡Œæ•°:** %d\\n\", stats.TotalLines)\n\tfmt.Fprintf(w, \"- **ç‰©ç†æ€»å¤§å°:** %.2f KB\\n\", float64(stats.TotalSize)/1024)\n\n\treturn w.Flush()\n}\n\nfunc copyFileContent(w *bufio.Writer, file FileMetadata) error {\n\tsrc, err := os.Open(file.FullPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tlang := detectLanguage(file.RelPath)\n\n\tfmt.Fprintln(w)\n\tfmt.Fprintf(w, \"## ğŸ“„ %s\\n\\n\", file.RelPath)\n\tfmt.Fprintf(w, \"````%s\\n\", lang)\n\n\t// ä½¿ç”¨ io.Copy æ›¿ä»£ scannerï¼Œæ›´å®‰å…¨ä¸”ä¸é™è¡Œé•¿\n\tif _, err := io.Copy(w, src); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintln(w, \"\\n````\")\n\tfmt.Fprintln(w, \"\\n[â¬† å›åˆ°ç›®å½•](#toc)\")\n\treturn nil\n}\n\nfunc countLines(path string) (int, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer f.Close()\n\n\tcount := 0\n\tscanner := bufio.NewScanner(f)\n\t// å¢åŠ ç¼“å†²åŒºä»¥æ”¯æŒè¶…é•¿è¡Œ\n\tbuf := make([]byte, 0, 64*1024)\n\tscanner.Buffer(buf, 1024*1024)\n\tfor scanner.Scan() {\n\t\tcount++\n\t}\n\treturn count, scanner.Err()\n}\n\n/*\n====================================================\n Logging\n====================================================\n*/\n\nfunc logf(verbose bool, format string, a ...any) {\n\tif verbose {\n\t\tfmt.Printf(format+\"\\n\", a...)\n\t}\n}\n",
    "tokens": 3617,
    "importance": 0.5,
    "lastUsedAt": 1769309697254,
    "addedAt": 1769309697254,
    "status": "active"
  }
]