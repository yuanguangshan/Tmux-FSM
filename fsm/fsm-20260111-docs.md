# Project Documentation

- **Generated at:** 2026-01-11 16:02:42
- **Root Dir:** `.`
- **File Count:** 7
- **Total Size:** 29.88 KB

<a name="toc"></a>
## ğŸ“‚ æ‰«æç›®å½•
- [README.md](#ğŸ“„-readmemd) (437 lines, 6.07 KB)
- [engine.go](#ğŸ“„-enginego) (443 lines, 9.95 KB)
- [engine_test.go](#ğŸ“„-engine_testgo) (430 lines, 9.86 KB)
- [keymap.go](#ğŸ“„-keymapgo) (63 lines, 1.16 KB)
- [nvim.go](#ğŸ“„-nvimgo) (22 lines, 0.67 KB)
- [token.go](#ğŸ“„-tokengo) (15 lines, 0.17 KB)
- [ui_stub.go](#ğŸ“„-ui_stubgo) (88 lines, 2.01 KB)

---

## ğŸ“„ README.md

````markdown

# FSM (Finite State Machine) Module Documentation

> æœ¬æ–‡æ¡£**ä¸¥æ ¼å¯¹åº”å½“å‰ `fsm` åŒ…çš„ä»£ç å®ç°**ï¼ˆå…± 5 ä¸ªæ–‡ä»¶ï¼‰ï¼Œ  
> æè¿°çš„æ˜¯ä¸€ä¸ª **é”®é©±åŠ¨çš„ã€å±‚çº§åŒ–çš„ FSM å¼•æ“**ï¼Œç”¨äºåœ¨ tmux / nvim ç¯å¢ƒä¸­
> æ•è·æŒ‰é”®ã€ç»´æŠ¤çŠ¶æ€ã€å¹¶å‘å¤–éƒ¨ç³»ç»Ÿå‘å°„ tokenã€‚

---

## æ¨¡å—èŒè´£è¾¹ç•Œï¼ˆéå¸¸é‡è¦ï¼‰

### FSM **è´Ÿè´£**

- âœ… é”®è¾“å…¥ â†’ çŠ¶æ€è½¬ç§»
- âœ… æ•°å­—è®¡æ•°ï¼ˆVim é£æ ¼ï¼‰
- âœ… Layerï¼ˆæ¨¡å¼å±‚ï¼‰ç®¡ç†
- âœ… RawToken å‘å°„
- âœ… UI çŠ¶æ€æ´¾ç”Ÿï¼ˆå½“å‰ä¸ºä¸´æ—¶å®ç°ï¼‰

### FSM **ä¸è´Ÿè´£**

- âŒ æ–‡æœ¬ç¼–è¾‘
- âŒ åŠ¨ä½œè¯­ä¹‰è§£æï¼ˆIntent Resolver å·²åºŸå¼ƒï¼‰
- âŒ Buffer / Cursor è®¡ç®—
- âŒ çœŸæ­£çš„ tmux / nvim æ‰§è¡Œï¼ˆå½“å‰å­˜åœ¨æŠ€æœ¯å€ºæ¡¥æ¥ï¼‰

---

## æ ¸å¿ƒå¯¹è±¡å…³ç³»

```
Key Input
   â†“
Engine.Dispatch(key)
   â†“
FSM State Transition
   â†“
RawToken Emission
   â†“
(UI / Recorder / Debugger)
```

---

## `token.go` â€”â€” **æœ€å°è¾“å…¥è¯­ä¹‰å•å…ƒ**

### RawTokenKind

```go
type RawTokenKind int
```

å·²å®šä¹‰çš„ token ç±»å‹ï¼š

| Token | å«ä¹‰ |
|----|----|
| TokenDigit | æ•°å­—è®¡æ•°è¾“å…¥ï¼ˆå¦‚ 3ã€42ï¼‰ |
| TokenKey | æ™®é€šæŒ‰é”® |
| TokenRepeat | é‡å¤å‘½ä»¤ï¼ˆ`.`ï¼‰ |
| TokenSystem | ç³»ç»Ÿäº‹ä»¶ï¼ˆenter / exit / resetï¼‰ |

---

### RawToken

```go
type RawToken struct {
    Kind  RawTokenKind
    Value string
}
```

- FSM å¯¹å¤–çš„**å”¯ä¸€äº‹ä»¶è¾“å‡ºæ ¼å¼**
- ä¸æºå¸¦è¯­ä¹‰ï¼Œåªæºå¸¦**äº‹å®**

---

## `engine.go` â€”â€” **FSM å¼•æ“æ ¸å¿ƒ**

---

### RawTokenEmitterï¼ˆè¾“å‡ºæ¥å£ï¼‰

```go
type RawTokenEmitter interface {
    Emit(RawToken)
}
```

- FSM **ä¸å…³å¿ƒ token å»å“ª**
- å¯ä»¥æœ‰å¤šä¸ª emitterï¼ˆUIã€Recorderã€Debuggerï¼‰

---

### Engine ç»“æ„

```go
type Engine struct {
    Active     string
    Keymap     *Keymap
    layerTimer *time.Timer
    count      int
    emitters   []RawTokenEmitter
    visualMode intent.VisualMode
}
```

å­—æ®µè¯­ä¹‰ï¼š

| å­—æ®µ | è¯´æ˜ |
|----|----|
| Active | å½“å‰ FSM å±‚ï¼ˆstateï¼‰ |
| Keymap | çŠ¶æ€æœºå®šä¹‰ |
| layerTimer | å±‚è¶…æ—¶è‡ªåŠ¨ reset |
| count | æ•°å­—å‰ç¼€ï¼ˆVim é£æ ¼ï¼‰ |
| emitters | RawToken è®¢é˜…è€… |
| visualMode | å½“å‰å¯è§†æ¨¡å¼ï¼ˆä»…è®°å½•ï¼Œä¸é©±åŠ¨è¡Œä¸ºï¼‰ |

---

### Engine ç”Ÿå‘½å‘¨æœŸ

#### åˆ›å»º

```go
func NewEngine(km *Keymap) *Engine
```

- åˆå§‹å±‚ä¸º `"NAV"`
- ä¸è‡ªåŠ¨å¯åŠ¨
- ä¸æ³¨å†Œ UI

#### å…¨å±€å®ä¾‹

```go
var defaultEngine *Engine
```

é€šè¿‡ï¼š

```go
InitEngine(km)
GetDefaultEngine()
```

ç®¡ç†

---

### Dispatch â€”â€” **FSM çš„æ ¸å¿ƒå…¥å£**

```go
func (e *Engine) Dispatch(key string) bool
```

å¤„ç†é¡ºåºï¼ˆ**ä¸¥æ ¼æŒ‰ä»£ç é¡ºåº**ï¼‰ï¼š

#### 1ï¸âƒ£ æ•°å­—è®¡æ•°

- ä»»æ„å±‚éƒ½æ¥å—æ•°å­—
- `0` åœ¨ count == 0 æ—¶è§†ä¸ºæ™®é€šé”®
- å…¶ä»–æ•°å­—ç´¯ç§¯åˆ° `count`
- å‘å°„ `TokenDigit`

#### 2ï¸âƒ£ é‡å¤é”®

```go
key == "."
```

- å‘å°„ `TokenRepeat`
- ä¸æ”¹å˜ FSM çŠ¶æ€

#### 3ï¸âƒ£ Keymap åŒ¹é…

- åªåœ¨å½“å‰ `Active` å±‚æŸ¥æ‰¾
- å¦‚æœåŒ¹é…ï¼š

##### a. Layer åˆ‡æ¢

```go
KeyAction.Layer != ""
```

- åˆ‡æ¢ `Active`
- å¯åŠ¨è¶…æ—¶ï¼ˆå¦‚é…ç½®ï¼‰
- å‘å°„ `TokenKey`

##### b. æ™®é€šæŒ‰é”®

- ä¸æ‰§è¡Œ action
- åªå‘å°„ `TokenKey`

#### 4ï¸âƒ£ æœªå¤„ç†

è¿”å› `false`

---

### æ•°å­—è®¡æ•°è§„åˆ™ï¼ˆå®ç°äº‹å®ï¼‰

- FSM **åªè®°å½•æ•°å­—**
- FSM **ä¸æ¶ˆè´¹æ•°å­—**
- `count` åªå½±å“ UI & token æµ
- åŠ¨ä½œå±‚å¦‚ä½•ä½¿ç”¨ count ä¸å±äº FSM

---

### Reset / Reload

```go
func (e *Engine) Reset()
```

è¡Œä¸ºï¼š

- åœæ­¢ layerTimer
- å›åˆ° initial æˆ– NAV
- æ¸…ç©º count
- å‘å°„ `TokenSystem("reset")`

---

```go
func Reload(configPath string) error
```

- é‡æ–°åŠ è½½ Keymap
- é‡å»º Engine
- Reset FSM
- æ›´æ–° UI

---

### RunActionï¼ˆtmux åŠ¨ä½œæ¡¥æ¥ï¼‰

```go
func (e *Engine) RunAction(name string)
```

- **ç¡¬ç¼–ç åŠ¨ä½œå**
- ç›´æ¥æ˜ å°„åˆ° tmux å‘½ä»¤
- è¿™æ˜¯ä¸€ä¸ª**è¿‡æ¸¡æœŸå®ç°**
- FSM æœ¬èº«å¹¶ä¸ç†è§£è¿™äº›åŠ¨ä½œ

---

### EnterFSM / ExitFSM

#### EnterFSM

- åˆå§‹åŒ–å¼•æ“
- Reset åˆ° NAV
- å‘å°„ `TokenSystem("enter")`
- æ›´æ–° UI

#### ExitFSM

- Reset
- å‘å°„ `TokenSystem("exit")`
- éšè— UI

---

## `keymap.go` â€”â€” **FSM å®šä¹‰æ•°æ®ç»“æ„**

---

### Keymap

```go
type Keymap struct {
    Initial string
    States  map[string]StateDef
}
```

- `Initial`ï¼šåˆå§‹å±‚å
- `States`ï¼šFSM çš„æ‰€æœ‰çŠ¶æ€

---

### StateDef

```go
type StateDef struct {
    Hint   string
    Sticky bool
    Keys   map[string]KeyAction
}
```

å½“å‰ FSM **åªä½¿ç”¨ Keys**

- `Hint` / `Sticky` å°šæœªè¢« Engine ä½¿ç”¨

---

### KeyAction

```go
type KeyAction struct {
    Action    string
    Layer     string
    TimeoutMs int
}
```

FSM **åªå…³å¿ƒ**ï¼š

- `Layer`
- `TimeoutMs`

`Action` ä¸åœ¨ FSM ä¸­æ‰§è¡Œï¼Œåªç”¨äºä¸Šå±‚ã€‚

---

### Validate

```go
func (km *Keymap) Validate() error
```

å”¯ä¸€æ ¡éªŒè§„åˆ™ï¼š

- æ‰€æœ‰ `Layer` å¼•ç”¨å¿…é¡»å­˜åœ¨

---

## `ui_stub.go` â€”â€” **UI æ´¾ç”ŸçŠ¶æ€ï¼ˆä¸´æ—¶æ¡¥æ¥ï¼‰**

> âš ï¸ æœ¬æ–‡ä»¶æ˜ç¡®æ ‡æ³¨ä¸º **æŠ€æœ¯å€ºå®ç°**

---

### UI ä¸å˜é‡ï¼ˆå†™åœ¨ä»£ç é‡Œçš„ï¼‰

> **Invariant 9: UI æ˜¯ FSM æ´¾ç”ŸçŠ¶æ€**

---

### UpdateUI

```go
func UpdateUI(_ ...any)
```

å½“å‰è¡Œä¸ºï¼š

1. **ç›´æ¥æ“ä½œ tmux**
2. è®¾ç½®ï¼š
   - `@fsm_state`
   - `@fsm_keys`
3. åˆ·æ–° tmux client
4. è°ƒç”¨ `OnUpdateUI` å›è°ƒ

---

### HideUI

- æ¸…ç©º tmux å˜é‡
- åˆ·æ–° client

---

### UIDriverï¼ˆæœªä½¿ç”¨ï¼‰

```go
type UIDriver interface {
    SetUserOption(...)
    RefreshClient(...)
}
```

å½“å‰ä»£ç  **æœªä½¿ç”¨æ­¤æ¥å£**

---

## `nvim.go` â€”â€” **Neovim æ¨¡å¼è”åŠ¨**

---

### OnNvimMode

```go
func OnNvimMode(mode string)
```

è§„åˆ™ï¼š

- å½“ nvim è¿›å…¥ï¼š
  - insert
  - visual
  - select
- FSM **ç«‹å³ Exit**

FSM **ä¸å°è¯•åŒæ­¥ nvim çŠ¶æ€**

---

### NotifyNvimMode

- ç©ºå®ç°
- æ˜ç¡®å£°æ˜åº”ç”± Kernel / Weaver å¤„ç†

---

## å½“å‰ FSM çš„çœŸå®èƒ½åŠ›æ€»ç»“

âœ… **å·²å®ç°**

- å±‚çº§ FSM
- æ•°å­—è®¡æ•°
- RawToken æµ
- è¶…æ—¶è‡ªåŠ¨ reset
- tmux UI çŠ¶æ€å±•ç¤ºï¼ˆä¸´æ—¶ï¼‰

âŒ **æœªå®ç°**

- Intent è§£æ
- åŠ¨ä½œè¯­ä¹‰
- Buffer / Motion
- å¯é€†æ€§
- å†å²è®°å½•

---

## ä¸€å¥è¯ç»“è®º

> **è¿™æ˜¯ä¸€ä¸ªâ€œé”® â†’ çŠ¶æ€ â†’ tokenâ€çš„çº¯ FSM æ ¸å¿ƒï¼Œ**
> å®ƒåˆ»æ„ä¸ç†è§£ç¼–è¾‘è¯­ä¹‰ï¼Œåªä¿è¯ï¼š
>
> - è¾“å…¥æ˜¯ç¡®å®šçš„  
> - çŠ¶æ€æ˜¯å¯é¢„æµ‹çš„  
> - è¾“å‡ºæ˜¯å¯è®¢é˜…çš„  

---

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine.go

````go
package fsm

import (
	"fmt"
	"log"
	"strings"
	"time"
	"tmux-fsm/backend"
	"tmux-fsm/intent"
)

// RawTokenEmitter ç”¨äºå‘é€ RawToken çš„æ¥å£
type RawTokenEmitter interface {
	Emit(RawToken)
}

// EngineAdapter å®ç°resolver.EngineAdapteræ¥å£
type EngineAdapter struct {
	engine *Engine
}

func (ea *EngineAdapter) SendKeys(keys ...string) {
	// å°†é”®å‘é€åˆ°tmux
	args := append([]string{"send-keys", "-t", "."}, keys...)
	tmux(strings.Join(args, " "))
}

func (ea *EngineAdapter) RunAction(name string) {
	ea.engine.RunAction(name)
}

func (ea *EngineAdapter) GetVisualMode() intent.VisualMode {
	return ea.engine.visualMode
}

func (ea *EngineAdapter) SetVisualMode(mode intent.VisualMode) {
	ea.engine.visualMode = mode
}

func (ea *EngineAdapter) EnterVisualMode(mode intent.VisualMode) {
	ea.engine.visualMode = mode
	// å¯èƒ½éœ€è¦æ›´æ–°UIæ˜¾ç¤º
	UpdateUI()
}

func (ea *EngineAdapter) ExitVisualMode() {
	ea.engine.visualMode = intent.VisualNone
	// å¯èƒ½éœ€è¦æ›´æ–°UIæ˜¾ç¤º
	UpdateUI()
}

func (ea *EngineAdapter) GetCurrentCursor() interface{} {
	// è·å–å½“å‰å…‰æ ‡ä½ç½®ï¼ˆé€šè¿‡ tmux å‘½ä»¤ï¼‰
	// è¿™é‡Œéœ€è¦å®é™…ä» tmux è·å–å…‰æ ‡ä½ç½®
	return struct {
		Line int
		Col  int
	}{Line: 0, Col: 0} // ç®€åŒ–å®ç°
}

func (ea *EngineAdapter) ComputeMotion(m *intent.Motion) (interface{}, error) {
	// è®¡ç®—åŠ¨ä½œèŒƒå›´
	return struct{}{}, nil
}

func (ea *EngineAdapter) MoveCursor(r interface{}) error {
	// ç§»åŠ¨å…‰æ ‡
	return nil
}

func (ea *EngineAdapter) DeleteRange(r interface{}) error {
	// åˆ é™¤èŒƒå›´å†…å®¹
	return nil
}

func (ea *EngineAdapter) DeleteWithMotion(motion intent.MotionKind, count int) error {
	// æ ¹æ®åŠ¨ä½œç±»å‹æ‰§è¡Œåˆ é™¤
	switch motion {
	case intent.MotionWord:
		ea.SendKeys("Escape", "d", "w")
	case intent.MotionLine:
		ea.SendKeys("Escape", "d", "d")
	case intent.MotionChar:
		ea.SendKeys("Delete")
	default:
		ea.SendKeys("Delete")
	}
	return nil
}

func (ea *EngineAdapter) YankRange(r interface{}) error {
	// å¤åˆ¶èŒƒå›´å†…å®¹
	return nil
}

func (ea *EngineAdapter) YankWithMotion(motion intent.MotionKind, count int) error {
	// æ ¹æ®åŠ¨ä½œç±»å‹æ‰§è¡Œå¤åˆ¶
	switch motion {
	case intent.MotionWord:
		ea.SendKeys("Escape", "y", "w")
	case intent.MotionLine:
		ea.SendKeys("Escape", "y", "y")
	case intent.MotionChar:
		ea.SendKeys("Escape", "y", "l")
	default:
		ea.SendKeys("Escape", "y", "y")
	}
	return nil
}

func (ea *EngineAdapter) ChangeRange(r interface{}) error {
	// ä¿®æ”¹èŒƒå›´å†…å®¹
	return nil
}

func (ea *EngineAdapter) ChangeWithMotion(motion intent.MotionKind, count int) error {
	// æ ¹æ®åŠ¨ä½œç±»å‹æ‰§è¡Œä¿®æ”¹
	switch motion {
	case intent.MotionWord:
		ea.SendKeys("Escape", "c", "w")
	case intent.MotionLine:
		ea.SendKeys("Escape", "c", "c")
	case intent.MotionChar:
		ea.SendKeys("Escape", "c", "l")
	default:
		ea.SendKeys("Escape", "c", "c")
	}
	return nil
}

// Engine FSM å¼•æ“ç»“æ„ä½“
type Engine struct {
	Active          string
	Keymap          *Keymap
	layerTimer      *time.Timer
	count           int               // ç”¨äºå­˜å‚¨æ•°å­—è®¡æ•°
	emitters        []RawTokenEmitter // ç”¨äºå‘å¤–éƒ¨å‘é€tokençš„å¤šä¸ªæ¥æ”¶è€…
	visualMode      intent.VisualMode // è§†è§‰æ¨¡å¼çŠ¶æ€
	PendingOperator string            // å½“å‰ pending çš„æ“ä½œç¬¦ (ç”¨äº UI æ˜¾ç¤º)
}

// FSMStatus FSM çŠ¶æ€ä¿¡æ¯ï¼Œç”¨äºUIæ›´æ–°
type FSMStatus struct {
	Layer string
	Count int
}

// AddEmitter æ·»åŠ ä¸€ä¸ª token å‘é€æ¥æ”¶è€…
func (e *Engine) AddEmitter(emitter RawTokenEmitter) {
	e.emitters = append(e.emitters, emitter)
}

// RemoveEmitter ç§»é™¤ä¸€ä¸ª token å‘é€æ¥æ”¶è€…
func (e *Engine) RemoveEmitter(emitter RawTokenEmitter) {
	for i, em := range e.emitters {
		if em == emitter {
			e.emitters = append(e.emitters[:i], e.emitters[i+1:]...)
			break
		}
	}
}

// emitInternal å†…éƒ¨å‘é€ token ç»™æ‰€æœ‰è®¢é˜…è€…
func (e *Engine) emitInternal(token RawToken) {
	for _, emitter := range e.emitters {
		emitter.Emit(token)
	}
}

// å…¨å±€é»˜è®¤å¼•æ“å®ä¾‹
var defaultEngine *Engine

// NewEngine åˆ›å»ºæ–°çš„ FSM å¼•æ“å®ä¾‹ï¼ˆæ˜¾å¼æ³¨å…¥ Keymapï¼‰
func NewEngine(km *Keymap) *Engine {
	engine := &Engine{
		Active:     "NAV",
		Keymap:     km,
		count:      0,
		emitters:   make([]RawTokenEmitter, 0),
		visualMode: intent.VisualNone,
	}

	// åˆ›å»ºå¼•æ“é€‚é…å™¨
	// adapter := &EngineAdapter{engine: engine}

	// åˆå§‹åŒ–è§£æå™¨ï¼ˆå·²åºŸå¼ƒï¼‰
	// engine.resolver = resolver.New(adapter)

	return engine
}

// InitEngine åˆå§‹åŒ–å…¨å±€å”¯ä¸€ Engine
func InitEngine(km *Keymap) {
	defaultEngine = NewEngine(km)
}

// InLayer æ£€æŸ¥å½“å‰æ˜¯å¦å¤„äºéé»˜è®¤å±‚ï¼ˆå¦‚ GOTOï¼‰
func (e *Engine) InLayer() bool {
	return e.Active != "NAV" && e.Active != ""
}

// CanHandle æ£€æŸ¥å½“å‰å±‚æ˜¯å¦å®šä¹‰äº†è¯¥æŒ‰é”®
func (e *Engine) CanHandle(key string) bool {
	if e.Keymap == nil {
		return false
	}
	st, ok := e.Keymap.States[e.Active]
	if !ok {
		return false
	}
	_, exists := st.Keys[key]
	return exists
}

// Dispatch å¤„ç†æŒ‰é”®äº¤äº’
func (e *Engine) Dispatch(key string) bool {
	// æ£€æŸ¥æ˜¯å¦æ˜¯æ•°å­—é”®ï¼Œå³ä½¿å½“å‰å±‚æ²¡æœ‰å®šä¹‰
	if isDigit(key) {
		// Fix: Treat '0' as a motion/key if current count is 0
		if key == "0" && e.count == 0 {
			// Fall through to CanHandle check
		} else {
			e.count = e.count*10 + int(key[0]-'0')
			e.emitInternal(RawToken{Kind: TokenDigit, Value: key})
			return true
		}
	}

	// æ£€æŸ¥æ˜¯å¦æ˜¯é‡å¤é”®
	if key == "." {
		e.emitInternal(RawToken{Kind: TokenRepeat, Value: "."})
		return true
	}

	// å…¶ä»–æŒ‰é”®æŒ‰åŸæœ‰é€»è¾‘å¤„ç†ï¼ˆåªå¤„ç†å±‚åˆ‡æ¢ï¼Œä¸å¤„ç†åŠ¨ä½œï¼‰
	if e.CanHandle(key) {
		st := e.Keymap.States[e.Active]
		act := st.Keys[key]

		// 1. å¤„ç†å±‚åˆ‡æ¢
		if act.Layer != "" {
			e.Active = act.Layer
			e.resetLayerTimeout(act.TimeoutMs)
			e.emitInternal(RawToken{Kind: TokenKey, Value: key})
			return true
		}

		// 2. å‘é€æŒ‰é”® token
		e.emitInternal(RawToken{Kind: TokenKey, Value: key})
		return true
	}

	return false
}

// isDigit æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå•ä¸ªæ•°å­—å­—ç¬¦
func isDigit(s string) bool {
	return len(s) == 1 && s[0] >= '0' && s[0] <= '9'
}

// Reset é‡ç½®å¼•æ“çŠ¶æ€åˆ°åˆå§‹å±‚ï¼ˆInvariant 8: Reload = FSM é‡ç”Ÿï¼‰
func (e *Engine) Reset() {
	if e.layerTimer != nil {
		e.layerTimer.Stop()
		e.layerTimer = nil
	}
	// é‡ç½®åˆ°åˆå§‹çŠ¶æ€
	if e.Keymap != nil && e.Keymap.Initial != "" {
		e.Active = e.Keymap.Initial
	} else {
		e.Active = "NAV"
	}
	e.count = 0
	e.PendingOperator = ""

	e.emitInternal(RawToken{Kind: TokenSystem, Value: "reset"})
}

// Reload é‡æ–°åŠ è½½keymapå¹¶é‡ç½®FSMï¼ˆInvariant 8: Reload = atomic rebuildï¼‰
func Reload(configPath string) error {
	// Load + Validate
	if err := LoadKeymap(configPath); err != nil {
		return err
	}

	// NewEngine
	InitEngine(&KM)

	// Reset + UI refresh
	Reset()

	return nil
}

// GetActiveLayer è·å–å½“å‰å±‚åç§°
func GetActiveLayer() string {
	if defaultEngine == nil {
		return "NAV"
	}
	return defaultEngine.Active
}

// InLayer å…¨å±€æŸ¥è¯¢
func InLayer() bool {
	if defaultEngine == nil {
		return false
	}
	return defaultEngine.InLayer()
}

// CanHandle å…¨å±€æŸ¥è¯¢
func CanHandle(key string) bool {
	if defaultEngine == nil {
		return false
	}
	return defaultEngine.CanHandle(key)
}

// Reset å…¨å±€é‡ç½®
func Reset() {
	if defaultEngine != nil {
		defaultEngine.Reset()
	}
}

// ... (resetLayerTimeout remains same)
func (e *Engine) resetLayerTimeout(ms int) {
	if e.layerTimer != nil {
		e.layerTimer.Stop()
	}
	if ms > 0 {
		e.layerTimer = time.AfterFunc(
			time.Duration(ms)*time.Millisecond,
			func() {
				e.Reset()
				// è¿™é‡Œç”±äºæ˜¯å¼‚æ­¥è¶…æ—¶ï¼Œéœ€è¦æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡ UI åˆ·æ–°
				UpdateUI()
			},
		)
	}
}

// RunAction æ‰§è¡ŒåŠ¨ä½œ
func (e *Engine) RunAction(name string) {
	switch name {
	case "pane_left":
		tmux("select-pane -L")
	case "pane_right":
		tmux("select-pane -R")
	case "pane_up":
		tmux("select-pane -U")
	case "pane_down":
		tmux("select-pane -D")
	case "next_pane":
		tmux("select-pane -t :.+")
	case "prev_pane":
		tmux("select-pane -t :.-")
	case "far_left":
		tmux("select-pane -t :.0")
	case "far_right":
		tmux("select-pane -t :.$")
	case "goto_top":
		tmux("select-pane -t :.0")
	case "goto_bottom":
		tmux("select-pane -t :.$")
	case "goto_line_start":
		// å‘é€ Home é”®åˆ°å½“å‰çª—æ ¼ï¼Œè¿™é€šå¸¸ä¼šå°†å…‰æ ‡ç§»åˆ°è¡Œé¦–
		tmux("send-keys -t . Home")
	case "goto_line_end":
		// å‘é€ End é”®åˆ°å½“å‰çª—æ ¼ï¼Œè¿™é€šå¸¸ä¼šå°†å…‰æ ‡ç§»åˆ°è¡Œå°¾
		tmux("send-keys -t . End")
	case "move_left":
		// å‘é€å·¦ç®­å¤´é”®
		tmux("send-keys -t . Left")
	case "move_right":
		// å‘é€å³ç®­å¤´é”®
		tmux("send-keys -t . Right")
	case "move_up":
		// å‘é€ä¸Šç®­å¤´é”®
		tmux("send-keys -t . Up")
	case "move_down":
		// å‘é€ä¸‹ç®­å¤´é”®
		tmux("send-keys -t . Down")
	case "exit":
		ExitFSM()
	case "prompt":
		tmux("command-prompt")
	default:
		fmt.Println("unknown action:", name)
	}
}

// tmux å‡½æ•°ç°åœ¨é€šè¿‡ backend æ‰§è¡Œ tmux å‘½ä»¤
// å®é™…æ‰§è¡Œå°†ç”± Kernel æˆ– Executor å±‚å¤„ç†
func tmux(cmd string) {
	// æ³¨æ„ï¼šæ ¹æ®æ¶æ„åŸåˆ™ï¼ŒFSM ä¸åº”ç›´æ¥æ‰§è¡Œå‘½ä»¤
	// ä½†ç°åœ¨é€šè¿‡ backend æ‰§è¡Œå‘½ä»¤
	err := backend.GlobalBackend.ExecRaw(cmd)
	if err != nil {
		log.Printf("Error executing tmux command '%s': %v", cmd, err)
	}
}

// DispatchIntent åˆ†å‘æ„å›¾ç»™è§£æå™¨
func (e *Engine) DispatchIntent(i *intent.Intent) error {
	// è§£æå™¨å·²åºŸå¼ƒï¼Œç›´æ¥è¿”å›
	return nil
}

func EnterFSM() {
	if defaultEngine == nil {
		InitEngine(&KM)
	}

	engine := defaultEngine
	engine.Active = "NAV"
	// ç¡®ä¿è¿›å…¥æ—¶æ˜¯å¹²å‡€çš„ NAV
	engine.Reset()
	engine.emitInternal(RawToken{Kind: TokenSystem, Value: "enter"})
	UpdateUI() // ç¡®ä¿è¿›å…¥æ—¶æ›´æ–°UI
	// ShowUI() // Disable initial UI popup to prevent flashing/annoyance
}

// GetDefaultEngine è·å–é»˜è®¤å¼•æ“å®ä¾‹
func GetDefaultEngine() *Engine {
	return defaultEngine
}

func ExitFSM() {
	if defaultEngine != nil {
		defaultEngine.Reset()
		defaultEngine.emitInternal(RawToken{Kind: TokenSystem, Value: "exit"})
	}
	HideUI()
	UpdateUI() // ç¡®ä¿é€€å‡ºæ—¶æ›´æ–°UI
	// FSM ä¸åº”ç›´æ¥ä¾èµ– backend
	// æ‰§è¡Œå±‚çš„é€€å‡ºé€»è¾‘åº”è¯¥ç”±ä¸Šå±‚å¤„ç†
}

// GetCount è·å–å½“å‰è®¡æ•°
func (e *Engine) GetCount() int {
	return e.count
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ engine_test.go

````go
package fsm

import (
	"testing"
	"time"
)

// MockRawTokenEmitter ç”¨äºæµ‹è¯•çš„æ¨¡æ‹Ÿå‘å°„å™¨
type MockRawTokenEmitter struct {
	receivedTokens []RawToken
}

func (m *MockRawTokenEmitter) Emit(token RawToken) {
	m.receivedTokens = append(m.receivedTokens, token)
}

// TestEngineInitialization æµ‹è¯•å¼•æ“åˆå§‹åŒ–
func TestEngineInitialization(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"f": {Layer: "GOTO", TimeoutMs: 800},
				},
			},
			"GOTO": {
				Keys: map[string]KeyAction{
					"j": {Action: "move_down"},
					"k": {Action: "move_up"},
				},
			},
		},
	}

	engine := NewEngine(&km)

	if engine.Active != "NAV" {
		t.Errorf("Expected initial layer to be 'NAV', got '%s'", engine.Active)
	}

	if engine.Keymap != &km {
		t.Errorf("Expected keymap to be set correctly")
	}

	if engine.count != 0 {
		t.Errorf("Expected initial count to be 0, got %d", engine.count)
	}

	if engine.visualMode != 0 {
		t.Errorf("Expected initial visual mode to be VisualNone, got %d", engine.visualMode)
	}
}

// TestEngineDispatchBasic æµ‹è¯•åŸºæœ¬æŒ‰é”®åˆ†å‘
func TestEngineDispatchBasic(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"h": {Action: "move_left"},
					"j": {Action: "move_down"},
					"k": {Action: "move_up"},
					"l": {Action: "move_right"},
				},
			},
		},
	}

	engine := NewEngine(&km)
	mockEmitter := &MockRawTokenEmitter{}
	engine.AddEmitter(mockEmitter)

	// æµ‹è¯•åŸºæœ¬æŒ‰é”®
	result := engine.Dispatch("h")
	if !result {
		t.Error("Expected dispatch to return true for valid key")
	}

	if len(mockEmitter.receivedTokens) != 1 {
		t.Errorf("Expected 1 token to be emitted, got %d", len(mockEmitter.receivedTokens))
	}

	if mockEmitter.receivedTokens[0].Kind != TokenKey {
		t.Errorf("Expected TokenKey, got %v", mockEmitter.receivedTokens[0].Kind)
	}

	if mockEmitter.receivedTokens[0].Value != "h" {
		t.Errorf("Expected value 'h', got '%s'", mockEmitter.receivedTokens[0].Value)
	}
}

// TestEngineDispatchLayerSwitch æµ‹è¯•å±‚åˆ‡æ¢
func TestEngineDispatchLayerSwitch(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"f": {Layer: "GOTO", TimeoutMs: 800},
				},
			},
			"GOTO": {
				Keys: map[string]KeyAction{
					"j": {Action: "move_down"},
					"k": {Action: "move_up"},
				},
			},
		},
	}

	engine := NewEngine(&km)

	// åˆå§‹çŠ¶æ€åº”è¯¥æ˜¯ NAV
	if engine.Active != "NAV" {
		t.Errorf("Expected initial layer to be 'NAV', got '%s'", engine.Active)
	}

	// åˆ†å‘ 'f' é”®ï¼Œåº”è¯¥åˆ‡æ¢åˆ° GOTO å±‚
	result := engine.Dispatch("f")
	if !result {
		t.Error("Expected dispatch to return true for layer switch key")
	}

	if engine.Active != "GOTO" {
		t.Errorf("Expected layer to be 'GOTO' after dispatching 'f', got '%s'", engine.Active)
	}
}

// TestEngineDispatchNumber æµ‹è¯•æ•°å­—è¾“å…¥
func TestEngineDispatchNumber(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"d": {Action: "delete"},
				},
			},
		},
	}

	engine := NewEngine(&km)

	// æµ‹è¯•æ•°å­—è¾“å…¥
	engine.Dispatch("2")
	if engine.count != 2 {
		t.Errorf("Expected count to be 2 after dispatching '2', got %d", engine.count)
	}

	engine.Dispatch("3")
	if engine.count != 23 {
		t.Errorf("Expected count to be 23 after dispatching '2' and '3', got %d", engine.count)
	}

	// æµ‹è¯•æ•°å­—åè·ŸåŠ¨ä½œ
	engine.Dispatch("d")
	if engine.count != 23 {
		t.Errorf("Expected count to remain 23 after dispatching 'd', got %d", engine.count)
	}
}

// TestEngineCanHandle æµ‹è¯• CanHandle æ–¹æ³•
func TestEngineCanHandle(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"h": {Action: "move_left"},
				},
			},
			"GOTO": {
				Keys: map[string]KeyAction{
					"j": {Action: "move_down"},
				},
			},
		},
	}

	engine := NewEngine(&km)

	// æµ‹è¯•åœ¨ NAV å±‚
	if !engine.CanHandle("h") {
		t.Error("Expected 'h' to be handled in NAV layer")
	}

	if engine.CanHandle("j") {
		t.Error("Expected 'j' to not be handled in NAV layer")
	}

	// åˆ‡æ¢åˆ° GOTO å±‚
	engine.Active = "GOTO"
	if !engine.CanHandle("j") {
		t.Error("Expected 'j' to be handled in GOTO layer")
	}

	if engine.CanHandle("h") {
		t.Error("Expected 'h' to not be handled in GOTO layer")
	}
}

// TestEngineInLayer æµ‹è¯• InLayer æ–¹æ³•
func TestEngineInLayer(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{},
			},
		},
	}

	engine := NewEngine(&km)

	// åˆå§‹çŠ¶æ€åº”è¯¥ä¸åœ¨å…¶ä»–å±‚
	if engine.InLayer() {
		t.Error("Expected to not be in layer initially")
	}

	// è®¾ç½®ä¸ºéé»˜è®¤å±‚
	engine.Active = "GOTO"
	if !engine.InLayer() {
		t.Error("Expected to be in layer when active is 'GOTO'")
	}

	// è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²
	engine.Active = ""
	if engine.InLayer() {
		t.Error("Expected to not be in layer when active is empty")
	}
}

// TestEngineReset æµ‹è¯•é‡ç½®åŠŸèƒ½
func TestEngineReset(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{},
			},
		},
	}

	engine := NewEngine(&km)

	// è®¾ç½®ä¸€äº›çŠ¶æ€
	engine.Active = "GOTO"
	engine.count = 42
	engine.PendingOperator = "delete"

	// æ·»åŠ ä¸€ä¸ªæ¨¡æ‹Ÿå‘å°„å™¨
	mockEmitter := &MockRawTokenEmitter{}
	engine.AddEmitter(mockEmitter)

	// é‡ç½®å¼•æ“
	engine.Reset()

	// éªŒè¯çŠ¶æ€å·²è¢«é‡ç½®
	if engine.Active != "NAV" {
		t.Errorf("Expected active layer to be reset to 'NAV', got '%s'", engine.Active)
	}

	if engine.count != 0 {
		t.Errorf("Expected count to be reset to 0, got %d", engine.count)
	}

	if engine.PendingOperator != "" {
		t.Errorf("Expected pending operator to be reset to empty, got '%s'", engine.PendingOperator)
	}

	// éªŒè¯å‘é€äº†é‡ç½® token
	if len(mockEmitter.receivedTokens) != 1 {
		t.Errorf("Expected 1 token to be emitted during reset, got %d", len(mockEmitter.receivedTokens))
	}

	if mockEmitter.receivedTokens[0].Kind != TokenSystem || mockEmitter.receivedTokens[0].Value != "reset" {
		t.Errorf("Expected TokenSystem with value 'reset', got %v with value '%s'",
			mockEmitter.receivedTokens[0].Kind, mockEmitter.receivedTokens[0].Value)
	}
}

// TestEngineLayerTimeout æµ‹è¯•å±‚è¶…æ—¶åŠŸèƒ½
func TestEngineLayerTimeout(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"f": {Layer: "GOTO", TimeoutMs: 100}, // 100ms è¶…æ—¶
				},
			},
			"GOTO": {
				Keys: map[string]KeyAction{
					"j": {Action: "move_down"},
				},
			},
		},
	}

	engine := NewEngine(&km)

	// åˆ†å‘ 'f' é”®ï¼Œåˆ‡æ¢åˆ° GOTO å±‚
	engine.Dispatch("f")
	if engine.Active != "GOTO" {
		t.Errorf("Expected to be in 'GOTO' layer after dispatching 'f', got '%s'", engine.Active)
	}

	// ç­‰å¾…è¶…è¿‡è¶…æ—¶æ—¶é—´
	time.Sleep(150 * time.Millisecond)

	// æ­¤æ—¶åº”è¯¥å·²ç»è‡ªåŠ¨é‡ç½®å› NAV å±‚
	// æ³¨æ„ï¼šç”±äºå®šæ—¶å™¨æ˜¯å¼‚æ­¥çš„ï¼Œè¿™é‡Œå¯èƒ½éœ€è¦æ›´å¤æ‚çš„åŒæ­¥æœºåˆ¶æ¥å‡†ç¡®æµ‹è¯•
	// å¯¹äºè¿™ä¸ªæµ‹è¯•ï¼Œæˆ‘ä»¬ä¸»è¦éªŒè¯å®šæ—¶å™¨è¢«è®¾ç½®å’Œå·¥ä½œ
}

// TestEngineRepeat æµ‹è¯•é‡å¤é”® (.) åŠŸèƒ½
func TestEngineRepeat(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					".": {Action: "repeat_last"},
				},
			},
		},
	}

	engine := NewEngine(&km)
	mockEmitter := &MockRawTokenEmitter{}
	engine.AddEmitter(mockEmitter)

	// åˆ†å‘ '.' é”®
	result := engine.Dispatch(".")
	if !result {
		t.Error("Expected dispatch to return true for repeat key")
	}

	if len(mockEmitter.receivedTokens) != 1 {
		t.Errorf("Expected 1 token to be emitted, got %d", len(mockEmitter.receivedTokens))
	}

	if mockEmitter.receivedTokens[0].Kind != TokenRepeat {
		t.Errorf("Expected TokenRepeat, got %v", mockEmitter.receivedTokens[0].Kind)
	}

	if mockEmitter.receivedTokens[0].Value != "." {
		t.Errorf("Expected value '.', got '%s'", mockEmitter.receivedTokens[0].Value)
	}
}

// TestEngineRunAction æµ‹è¯•åŠ¨ä½œæ‰§è¡Œ
func TestEngineRunAction(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"x": {Action: "exit"},
				},
			},
		},
	}

	engine := NewEngine(&km)

	// æµ‹è¯• exit åŠ¨ä½œ
	// æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸èƒ½çœŸæ­£æµ‹è¯• ExitFSM çš„æ•ˆæœï¼Œå› ä¸ºå®ƒä¼šå½±å“å…¨å±€çŠ¶æ€
	// æ‰€ä»¥æˆ‘ä»¬åªæ˜¯éªŒè¯æ–¹æ³•è¢«è°ƒç”¨ä¸ä¼šå´©æºƒ
	engine.RunAction("exit")
}

// TestEngineGetCount æµ‹è¯•è·å–è®¡æ•°
func TestEngineGetCount(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{},
			},
		},
	}

	engine := NewEngine(&km)

	// åˆå§‹è®¡æ•°åº”è¯¥æ˜¯ 0
	if engine.GetCount() != 0 {
		t.Errorf("Expected initial count to be 0, got %d", engine.GetCount())
	}

	// è®¾ç½®è®¡æ•°
	engine.count = 42
	if engine.GetCount() != 42 {
		t.Errorf("Expected count to be 42, got %d", engine.GetCount())
	}
}

// TestEngineDispatchZeroAtStart æµ‹è¯•åœ¨è®¡æ•°ä¸º0æ—¶æŒ‰0é”®çš„è¡Œä¸º
func TestEngineDispatchZeroAtStart(t *testing.T) {
	km := Keymap{
		Initial: "NAV",
		States: map[string]StateDef{
			"NAV": {
				Keys: map[string]KeyAction{
					"0": {Action: "goto_line_start"},
				},
			},
		},
	}

	engine := NewEngine(&km)

	// åˆå§‹è®¡æ•°ä¸º0æ—¶æŒ‰0é”®ï¼Œåº”è¯¥è¢«è§†ä¸ºåŠ¨ä½œè€Œä¸æ˜¯æ•°å­—
	initialCount := engine.count
	if initialCount != 0 {
		t.Errorf("Expected initial count to be 0, got %d", initialCount)
	}

	// è¿™é‡Œæˆ‘ä»¬æ— æ³•ç›´æ¥æµ‹è¯•æ˜¯å¦è¿›å…¥äº†CanHandleæµç¨‹ï¼Œä½†æˆ‘ä»¬å¯ä»¥æµ‹è¯•è®¡æ•°æ˜¯å¦ä¿æŒä¸º0
	// åœ¨åŸå§‹ä»£ç ä¸­ï¼Œå½“countä¸º0ä¸”keyä¸º"0"æ—¶ï¼Œä¼šè·³è¿‡æ•°å­—å¤„ç†é€»è¾‘
	engine.Dispatch("0")

	// å¦‚æœ0è¢«å½“ä½œæ•°å­—å¤„ç†ï¼Œcountä¼šå˜æˆ0ï¼ˆ0*10+0ï¼‰ï¼Œä½†å®é™…ä¸Šå®ƒåº”è¯¥è¢«å½“ä½œåŠ¨ä½œå¤„ç†
	// æ‰€ä»¥countåº”è¯¥ä¿æŒä¸å˜
	if engine.count != 0 {
		t.Errorf("Expected count to remain 0 when '0' pressed at start, got %d", engine.count)
	}
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ keymap.go

````go
package fsm

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

type KeyAction struct {
	Action    string `yaml:"action"`
	Layer     string `yaml:"layer"`
	TimeoutMs int    `yaml:"timeout_ms"`
}

type StateDef struct {
	Hint   string               `yaml:"hint"`
	Sticky bool                 `yaml:"sticky"` // If true, don't reset to NAV after action
	Keys   map[string]KeyAction `yaml:"keys"`
}

type Keymap struct {
	Initial string              `yaml:"initial"`
	States  map[string]StateDef `yaml:"states"`
}

// Validate éªŒè¯ keymap é…ç½®çš„æ­£ç¡®æ€§
func (km *Keymap) Validate() error {
	for name, st := range km.States {
		for key, act := range st.Keys {
			if act.Layer != "" {
				if _, ok := km.States[act.Layer]; !ok {
					return fmt.Errorf("state %s references missing layer %s for key %s", name, act.Layer, key)
				}
			}
		}
	}
	return nil
}

func LoadKeymap(path string) error {
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	var km Keymap
	if err := yaml.Unmarshal(b, &km); err != nil {
		return err
	}

	// éªŒè¯é…ç½®
	if err := km.Validate(); err != nil {
		return fmt.Errorf("invalid keymap: %w", err)
	}

	KM = km
	return nil
}

var (
	KM Keymap
)

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ nvim.go

````go
package fsm

import (
	"strings"
)

// OnNvimMode å¤„ç†æ¥è‡ª Neovim çš„æ¨¡å¼å˜åŒ–
func OnNvimMode(mode string) {
	// å¦‚æœ Neovim è¿›å…¥æ’å…¥æ¨¡å¼æˆ–å¯è§†æ¨¡å¼ï¼Œé€€å‡º FSM
	if mode == "i" || mode == "v" || mode == "V" || strings.HasPrefix(mode, "s") {
		ExitFSM()
	}
}

// NotifyNvimMode é€šçŸ¥ Neovim å½“å‰ FSM æ¨¡å¼
// æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•° currently would need to use intents to communicate
// with the backend, but Phase-3 requires that FSM doesn't directly call backend
func NotifyNvimMode() {
	// Phase-3 invariant: FSM does not directly call backend
	// This functionality should be handled by Kernel/Weaver layer
	// using intents to communicate with the backend
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ token.go

````go
package fsm

type RawTokenKind int

const (
	TokenDigit RawTokenKind = iota
	TokenKey
	TokenRepeat
	TokenSystem
)

type RawToken struct {
	Kind  RawTokenKind
	Value string
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

## ğŸ“„ ui_stub.go

````go
package fsm

import (
	"fmt"
	"os/exec"
)

// UIDriver å®šä¹‰UIé©±åŠ¨æ¥å£
type UIDriver interface {
	SetUserOption(option, value string) error
	RefreshClient(clientName string) error
}

var uiDriver UIDriver

// OnUpdateUI å½“UIéœ€è¦æ›´æ–°æ—¶è°ƒç”¨çš„å›è°ƒå‡½æ•°
var OnUpdateUI func()

// SetUIDriver è®¾ç½®UIé©±åŠ¨å®ç°
func SetUIDriver(driver UIDriver) {
	uiDriver = driver
}

// UpdateUI æ›´æ–°UIæ˜¾ç¤ºå½“å‰FSMçŠ¶æ€ï¼ˆInvariant 9: UI æ´¾ç”ŸçŠ¶æ€ï¼‰
func UpdateUI(_ ...any) {
	// TEMPORARY: debug-only UI bridge
	// This is a technical debt - FSM should NOT directly touch tmux
	// TODO: Move to Kernel â†’ Weaver â†’ Backend pipeline
	updateTmuxVariables()

	// è°ƒç”¨å¤–éƒ¨æ³¨å†Œçš„UIæ›´æ–°å›è°ƒ
	if OnUpdateUI != nil {
		OnUpdateUI()
	}
}

// updateTmuxVariables æ›´æ–° tmux çŠ¶æ€å˜é‡
func updateTmuxVariables() {
	if defaultEngine == nil {
		return
	}

	// æ›´æ–°çŠ¶æ€å˜é‡
	activeLayer := defaultEngine.Active
	if activeLayer == "" {
		activeLayer = "NAV"
	}

	// è®¾ç½®çŠ¶æ€å˜é‡
	displayState := activeLayer
	if defaultEngine.PendingOperator != "" {
		displayState = fmt.Sprintf("%s [%s]", activeLayer, defaultEngine.PendingOperator)
	}
	setTmuxOption("@fsm_state", displayState)

	// å¦‚æœæœ‰è®¡æ•°å™¨ï¼Œä¹Ÿæ˜¾ç¤ºå®ƒ
	if defaultEngine.count > 0 {
		setTmuxOption("@fsm_keys", fmt.Sprintf("%d", defaultEngine.count))
	} else {
		setTmuxOption("@fsm_keys", "")
	}

	// åˆ·æ–°å®¢æˆ·ç«¯ä»¥æ›´æ–°çŠ¶æ€æ 
	refreshTmuxClient()
}

// setTmuxOption è®¾ç½® tmux é€‰é¡¹
func setTmuxOption(option, value string) {
	cmd := exec.Command("tmux", "set", "-g", option, value)
	_ = cmd.Run()
}

// refreshTmuxClient åˆ·æ–° tmux å®¢æˆ·ç«¯
func refreshTmuxClient() {
	cmd := exec.Command("tmux", "refresh-client", "-S")
	_ = cmd.Run()
}

// HideUI éšè—UI
func HideUI() {
	// Phaseâ€‘3 invariant:
	// FSM does NOT touch UI / backend directly.
	// UI update must be handled by Kernel / Weaver.
	// ä½†æ˜¯ï¼Œä¸ºäº†éšè—çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦é‡ç½® tmux å˜é‡
	setTmuxOption("@fsm_state", "")
	setTmuxOption("@fsm_keys", "")
	refreshTmuxClient()
}

````

[â¬† å›åˆ°ç›®å½•](#toc)

---
### ğŸ“Š æœ€ç»ˆç»Ÿè®¡æ±‡æ€»
- **æ–‡ä»¶æ€»æ•°:** 7
- **ä»£ç æ€»è¡Œæ•°:** 1498
- **ç‰©ç†æ€»å¤§å°:** 29.88 KB
