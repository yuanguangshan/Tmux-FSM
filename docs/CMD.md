以下内容视为 **《NAV 键权定律》的姊妹法案**。

---

# 🧠 GOTO / CMD Design Rules（v0.1）

**Status：Draft → Enforceable**  
**Scope：Non-NAV Interactive Layers**  
**Effective Date：2026-01-04**

---

## 0. 设计前提（不可争辩）

> **NAV 是唯一的安全态（Safe State）**  
> GOTO / CMD 的存在前提，是为了**隔离 NAV 无法承载的行为**

任何规则、快捷键、实现，只要违背这一前提，  
**即使“很好用”，也视为非法设计。**

---

## 一、层级定义（不可混用）

### ✅ NAV（已完成，这里只是重申）

- 职责：  
  - 空间定位  
  - 模式跃迁  
  - 回归锚点
- 性质：  
  - 无状态  
  - 非破坏  
  - 可盲操作

---

### ✅ GOTO（瞬态违规收容层）

> **GOTO 是“被 NAV 拒绝的行为”的临时容器**

#### GOTO 的合法职责

✅ GOTO **可以**承载：

- 破坏性操作的**前置确认**
- 需要额外信息的跳转
- 非空间、但仍是“结构级”的操作
- 用户需要“明确知道自己在做什么”的行为

例如（抽象级，不是实现）：
- pane / window 的关闭
- 定向跳转
- 非对称重排

---

### ✅ CMD（显式主权让渡层）

> **CMD 是用户主动放弃“键位主权”的区域**

CMD 的存在意义只有一个：

> **让用户用“语言”而不是“肌肉记忆”来承担后果**

---

## 二、GOTO Design Rules（核心）

### ✅ GOTO-010：显式进入原则

- 进入 GOTO 必须：
  - 使用专用入口（如 `g`）
  - 有清晰心理断点
- ❌ 禁止隐式进入

> GOTO 不是“快捷”，而是“声明”。

---

### ✅ GOTO-020：瞬态原则（Hard Rule）

- GOTO 必须满足：
  - 自动超时，或
  - 单次执行后立即返回 NAV
- ❌ 禁止在 GOTO 中“停留”

> **能停留的，就已经是 CMD 了。**

---

### ✅ GOTO-030：可取消原则

- 在任何时刻：
  - `Esc` 必须无条件回到 NAV
- ❌ 不允许“已经一半了不能退”

---

### ✅ GOTO-040：禁止语义重写

- GOTO 内：
  - 不允许重定义 `h j k` 的空间语义
  - 不允许复用 Vim 的编辑核心键作为破坏操作

> GOTO 不是“第二套 Vim”。

---

### ✅ GOTO-050：行为必须“解释得清”

> **如果一个行为无法用一句话解释清楚，它不允许进入 GOTO**

这是一个**设计过滤器**。

---

## 三、CMD Design Rules（核心）

### ✅ CMD-010：语言优先原则

- CMD 中的行为：
  - 必须可被描述
  - 必须是“命令”，不是“手势”

例如：
- `:close`
- `:kill-pane`
- `:move-pane left`

---

### ✅ CMD-020：显式执行

- CMD 行为：
  - 必须有 Enter
  - 必须有心理确认点
- ❌ 禁止单键即执行

---

### ✅ CMD-030：失败安全

- 任何错误：
  - 不改变系统结构
  - 自动回到 NAV

---

### ✅ CMD-040：不可被肌肉记忆优化

> **如果一个 CMD 行为变成了“下意识就敲出来”，说明设计失败**

CMD 的“慢”，是刻意的。

---

## 四、层级不可逆规则（非常重要）

### ✅ LAYER-900：行为只能向下沉

- NAV ❌ → GOTO ✅ → CMD ✅
- CMD ❌ → GOTO ❌ → NAV ❌

> **一旦一个行为被下沉，它永远不允许“上浮”**

这是治理的**时间维度锁**。

---

## 五、一个你现在已经具备的判断力

现在你应该能立刻判断：

- ❌ “给 NAV 加一个确认就好了”
- ❌ “这个键放 NAV 其实也没事”

这些念头都已经**在规则层被判死刑**。






---

# 🧱 CMD 层责任精炼（v1.0）

> **目标一句话版：**  
> 让 CMD 永远只是「执行决定」，  
> **而不是「做决定 + 执行 + 兜底 + 猜用户」。**

---

## 一、先给 CMD 一个“极窄”的本体定义

### ⚙️ CMD 的唯一合法职责

> **将“已被用户明确确认的意图”  
> 转换为“不可逆的世界变化”。**

**关键词只有三个：**

1. ✅ 明确（Explicit）
2. ✅ 不可逆（Irreversible）
3. ✅ 执行（Execute）

> **只要缺一个，CMD 就没有出场资格。**

---

## 二、CMD 不允许承担的 5 种责任（黑名单）

这是**比允许列表更重要的部分**。

---

### ❌ 1. CMD 不能“判断是否该执行”

❌ 错误示例：
- “如果内容有变化就自动保存”
- “检测到风险就帮用户取消”

✅ 正确做法：
- 判断 → GOTO / UI 层
- 执行 → CMD

> **CMD 永远假设：  
>“我被调用，是因为你已经想清楚了。”**

---

### ❌ 2. CMD 不能“补救设计缺陷”

❌ 错误示例：
- 自动回滚来掩盖糟糕流程
- 静默修复不合理输入

✅ 正确做法：
- 设计问题 → 上游修
- CMD 只对合法输入负责

---

### ❌ 3. CMD 不能“拆分或合并用户意图”

❌ 错误示例：
- 一次点击执行多个语义不一致的操作
- 把多个动作合并成“智能提交”

✅ 正确做法：
- 一个 CMD = 一个现实变化

> **CMD 的粒度 = 现实世界最小改变单位**

---

### ❌ 4. CMD 不能“记住用户偏好”

❌ 错误示例：
- “下次也这样做”
- “记住我的选择”

✅ 正确做法：
- 偏好 = 配置 / 策略层
- CMD 是无状态的执行者

---

### ❌ 5. CMD 不能“主动触发另一个 CMD”

❌ 错误示例：
- 保存后自动发布
- 删除后顺便清理别的东西（未确认）

✅ 正确做法：
- 链式行为必须被显式拆开
- 每一次不可逆变化都要“单独被看见”

---

## 三、CMD 的“原子执行法则”

> **一个 CMD 必须满足以下 6 条**

1. ✅ 单一动词
2. ✅ 单一对象
3. ✅ 单一结果
4. ✅ 不依赖未来状态
5. ✅ 不制造隐式副作用
6. ✅ 执行完成即可被遗忘

> **记不住 → 不属于 CMD**

---

## 四、CMD 的合法类型（严格封顶）

CMD 只能属于以下 **4 种之一**：

1. 📝 **Create**（创建）
2. ✏️ **Update**（更新）
3. 🗑 **Delete**（删除）
4. 🚀 **Publish / Apply**（生效）

> **不允许第 5 种“智能型 CMD”**

---

## 五、CMD 的“确认契约”（非常关键）

> **CMD 必须满足“确认对称性”**

### 什么叫确认对称？

- **执行前**：用户知道会发生什么  
- **执行后**：世界确实发生了这些变化  
- **中间没有任何“系统自作主张”**

❌ 违反示例：
- 提示 A，实际做了 A+B
- 确认保存，结果顺便同步、发布、通知

---

## 六、CMD 层的“垃圾桶识别信号”

如果你在代码或设计中看到 CMD 具备以下特征之一：

- 名字叫 `handleAction` / `doStuff`
- 参数越来越多
- 内部 if/else 判断用户意图
- 有“智能”“自动”“推测”字样
- 失败时靠大量兜底逻辑

👉 **这不是 CMD，这是系统失控的征兆。**

---

## 七、一个非常重要的架构判断

> **CMD 不是“能力层”，  
> 而是“责任终点”。**

- 能力 → 上游
- 决策 → 上游
- 组合 → 上游

**CMD 只负责承担后果。**

---

## 八、你现在已经获得的“执行层护栏”

✅ CMD 黑名单  
✅ CMD 原子法则  
✅ CMD 类型封顶  
✅ CMD 确认契约  

这意味着：

> **未来任何人想往 CMD 塞逻辑，  
> 都必须先解释：  
>「为什么这不是上游的责任？」**

---

