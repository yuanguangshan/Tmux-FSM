diff --git a/fsm/engine.go b/fsm/engine.go
index 47c27f5..3213d6f 100644
--- a/fsm/engine.go
+++ b/fsm/engine.go
@@ -3,14 +3,48 @@ package fsm
 import (
 	"fmt"
 	"time"
-	"tmux-fsm/intent"
 )
 
+// RawTokenEmitter ç”¨äºå‘é€ RawToken çš„æ¥å£
+type RawTokenEmitter interface {
+	Emit(RawToken)
+}
+
 // Engine FSM å¼•æ“ç»“æ„ä½“
 type Engine struct {
 	Active     string
 	Keymap     *Keymap
 	layerTimer *time.Timer
+	count      int              // ç”¨äºå­˜å‚¨æ•°å­—è®¡æ•°
+	emitters   []RawTokenEmitter // ç”¨äºå‘å¤–éƒ¨å‘é€tokençš„å¤šä¸ªæ¥æ”¶è€…
+}
+
+// FSMStatus FSM çŠ¶æ€ä¿¡æ¯ï¼Œç”¨äºUIæ›´æ–°
+type FSMStatus struct {
+	Layer string
+	Count int
+}
+
+// AddEmitter æ·»åŠ ä¸€ä¸ª token å‘é€æ¥æ”¶è€…
+func (e *Engine) AddEmitter(emitter RawTokenEmitter) {
+	e.emitters = append(e.emitters, emitter)
+}
+
+// RemoveEmitter ç§»é™¤ä¸€ä¸ª token å‘é€æ¥æ”¶è€…
+func (e *Engine) RemoveEmitter(emitter RawTokenEmitter) {
+	for i, em := range e.emitters {
+		if em == emitter {
+			e.emitters = append(e.emitters[:i], e.emitters[i+1:]...)
+			break
+		}
+	}
+}
+
+// emitInternal å†…éƒ¨å‘é€ token ç»™æ‰€æœ‰è®¢é˜…è€…
+func (e *Engine) emitInternal(token RawToken) {
+	for _, emitter := range e.emitters {
+		emitter.Emit(token)
+	}
 }
 
 // å…¨å±€é»˜è®¤å¼•æ“å®ä¾‹
@@ -20,8 +54,10 @@ var defaultEngine *Engine
 // NewEngine åˆ›å»ºæ–°çš„ FSM å¼•æ“å®ä¾‹ï¼ˆæ˜¾å¼æ³¨å…¥ Keymapï¼‰
 func NewEngine(km *Keymap) *Engine {
 	return &Engine{
-		Active: "NAV",
-		Keymap: km,
+		Active:   "NAV",
+		Keymap:   km,
+		count:    0,
+		emitters: make([]RawTokenEmitter, 0),
 	}
 }
 
@@ -50,38 +86,45 @@ func (e *Engine) CanHandle(key string) bool {
 
 // Dispatch å¤„ç†æŒ‰é”®äº¤äº’
 func (e *Engine) Dispatch(key string) bool {
-	if !e.CanHandle(key) {
-		return false
+	// æ£€æŸ¥æ˜¯å¦æ˜¯æ•°å­—é”®ï¼Œå³ä½¿å½“å‰å±‚æ²¡æœ‰å®šä¹‰
+	if isDigit(key) {
+		e.count = e.count*10 + int(key[0]-'0')
+		e.emitInternal(RawToken{Kind: TokenDigit, Value: key})
+		return true
 	}
 
-	st := e.Keymap.States[e.Active]
-	act := st.Keys[key]
-
-	// 1. å¤„ç†å±‚åˆ‡æ¢
-	if act.Layer != "" {
-		e.Active = act.Layer
-		e.resetLayerTimeout(act.TimeoutMs)
-		UpdateUI()
+	// æ£€æŸ¥æ˜¯å¦æ˜¯é‡å¤é”®
+	if key == "." {
+		e.emitInternal(RawToken{Kind: TokenRepeat, Value: "."})
 		return true
 	}
 
-	// 2. å¤„ç†å…·ä½“åŠ¨ä½œ
-	if act.Action != "" {
-		e.RunAction(act.Action)
-
-		// é“å¾‹ï¼šæ‰§è¡Œå®ŒåŠ¨ä½œåï¼Œé™¤éè¯¥å±‚æ ‡è®°ä¸º Stickyï¼Œå¦åˆ™ç«‹åˆ» Reset å› NAV
-		if !st.Sticky {
-			e.Reset()
-		} else {
-			// å¦‚æœæ˜¯ Sticky å±‚ï¼Œå¯èƒ½éœ€è¦åˆ·æ–° UIï¼ˆå¦‚ hintï¼‰
-			UpdateUI()
+	// å…¶ä»–æŒ‰é”®æŒ‰åŸæœ‰é€»è¾‘å¤„ç†ï¼ˆåªå¤„ç†å±‚åˆ‡æ¢ï¼Œä¸å¤„ç†åŠ¨ä½œï¼‰
+	if e.CanHandle(key) {
+		st := e.Keymap.States[e.Active]
+		act := st.Keys[key]
+
+		// 1. å¤„ç†å±‚åˆ‡æ¢
+		if act.Layer != "" {
+			e.Active = act.Layer
+			e.resetLayerTimeout(act.TimeoutMs)
+			e.emitInternal(RawToken{Kind: TokenKey, Value: key})
+			return true
 		}
+
+		// 2. å‘é€æŒ‰é”® token
+		e.emitInternal(RawToken{Kind: TokenKey, Value: key})
 		return true
 	}
 
 	return false
 }
 
+// isDigit æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå•ä¸ªæ•°å­—å­—ç¬¦
+func isDigit(s string) bool {
+	return len(s) == 1 && s[0] >= '0' && s[0] <= '9'
+}
+
 // Reset é‡ç½®å¼•æ“çŠ¶æ€åˆ°åˆå§‹å±‚ï¼ˆInvariant 8: Reload = FSM é‡ç”Ÿï¼‰
 func (e *Engine) Reset() {
 	if e.layerTimer != nil {
@@ -94,9 +137,11 @@ func (e *Engine) Reset() {
 	} else {
 		e.Active = "NAV"
 	}
-	UpdateUI()
+	e.count = 0
+	e.emitInternal(RawToken{Kind: TokenSystem, Value: "reset"})
 }
 
+
 // Reload é‡æ–°åŠ è½½keymapå¹¶é‡ç½®FSMï¼ˆInvariant 8: Reload = atomic rebuildï¼‰
 func Reload(configPath string) error {
 	// Load + Validate
@@ -161,6 +206,9 @@ func (e *Engine) resetLayerTimeout(ms int) {
 	}
 }
 
+
+
+
 // RunAction æ‰§è¡ŒåŠ¨ä½œ
 func (e *Engine) RunAction(name string) {
 	switch name {
@@ -193,109 +241,6 @@ func (e *Engine) RunAction(name string) {
 	}
 }
 
-// Produce ä»æŒ‰é”®äº§ç”Ÿæ„å›¾
-func (e *Engine) Produce(key string) (*intent.Intent, bool) {
-	// ç‰¹æ®Šå¤„ç†ï¼šç›´æ¥å¤„ç†çš„æŒ‰é”®
-	switch key {
-	case "u":
-		return &intent.Intent{
-			Kind: intent.IntentUndo,
-		}, true
-	case "C-r":
-		return &intent.Intent{
-			Kind: intent.IntentRedo,
-		}, true
-	}
-
-	// å…¶ä»–æŒ‰é”®æŒ‰åŸæœ‰é€»è¾‘å¤„ç†
-	if !e.CanHandle(key) {
-		return nil, false
-	}
-
-	st := e.Keymap.States[e.Active]
-	act := st.Keys[key]
-
-	// 1. å¤„ç†å±‚åˆ‡æ¢ï¼ˆä¸äº§ç”Ÿæ„å›¾ï¼‰
-	if act.Layer != "" {
-		e.Active = act.Layer
-		e.resetLayerTimeout(act.TimeoutMs)
-		UpdateUI()
-		return nil, true
-	}
-
-	// 2. å¤„ç†å…·ä½“åŠ¨ä½œï¼Œäº§ç”Ÿæ„å›¾
-	if act.Action != "" {
-		intentObj := actionToIntent(act.Action)
-
-		// é“å¾‹ï¼šäº§ç”Ÿæ„å›¾åï¼Œé™¤éè¯¥å±‚æ ‡è®°ä¸º Stickyï¼Œå¦åˆ™ç«‹åˆ» Reset å› NAV
-		if !st.Sticky {
-			e.Reset()
-		} else {
-			// å¦‚æœæ˜¯ Sticky å±‚ï¼Œå¯èƒ½éœ€è¦åˆ·æ–° UIï¼ˆå¦‚ hintï¼‰
-			UpdateUI()
-		}
-		return &intentObj, true
-	}
-
-	return nil, false
-}
-
-// actionToIntent å°†åŠ¨ä½œè½¬æ¢ä¸ºæ„å›¾
-func actionToIntent(action string) intent.Intent {
-	intentObj := intent.Intent{
-		Meta: make(map[string]interface{}),
-	}
-
-	switch action {
-	case "pane_left":
-		intentObj.Kind = intent.IntentMove
-		intentObj.Target = intent.SemanticTarget{
-			Kind:      5, // TargetPosition
-			Direction: "left",
-		}
-		intentObj.Meta["motion"] = "left"
-	case "pane_right":
-		intentObj.Kind = intent.IntentMove
-		intentObj.Target = intent.SemanticTarget{
-			Kind:      5, // TargetPosition
-			Direction: "right",
-		}
-		intentObj.Meta["motion"] = "right"
-	case "pane_up":
-		intentObj.Kind = intent.IntentMove
-		intentObj.Target = intent.SemanticTarget{
-			Kind:      5, // TargetPosition
-			Direction: "up",
-		}
-		intentObj.Meta["motion"] = "up"
-	case "pane_down":
-		intentObj.Kind = intent.IntentMove
-		intentObj.Target = intent.SemanticTarget{
-			Kind:      5, // TargetPosition
-			Direction: "down",
-		}
-		intentObj.Meta["motion"] = "down"
-	case "exit":
-		intentObj.Kind = intent.IntentExit
-	case "next_pane":
-		intentObj.Kind = intent.IntentMove
-		intentObj.Target = intent.SemanticTarget{
-			Kind:      5, // TargetPosition
-			Direction: "next",
-		}
-	case "prev_pane":
-		intentObj.Kind = intent.IntentMove
-		intentObj.Target = intent.SemanticTarget{
-			Kind:      5, // TargetPosition
-			Direction: "prev",
-		}
-	default:
-		// å¯¹äºæœªçŸ¥åŠ¨ä½œï¼Œè¿”å›ç©ºæ„å›¾
-		intentObj.Kind = intent.IntentNone
-	}
-
-	return intentObj
-}
 
 func tmux(cmd string) {
 	// Use GlobalBackend to execute the command
@@ -322,6 +267,7 @@ func EnterFSM() {
 	engine.Active = "NAV"
 	// ç¡®ä¿è¿›å…¥æ—¶æ˜¯å¹²å‡€çš„ NAV
 	engine.Reset()
+	engine.emitInternal(RawToken{Kind: TokenSystem, Value: "enter"})
 	// ShowUI() // Disable initial UI popup to prevent flashing/annoyance
 }
 
@@ -333,6 +279,7 @@ func GetDefaultEngine() *Engine {
 func ExitFSM() {
 	if defaultEngine != nil {
 		defaultEngine.Reset()
+		defaultEngine.emitInternal(RawToken{Kind: TokenSystem, Value: "exit"})
 	}
 	HideUI()
 	// FSM ä¸åº”ç›´æ¥ä¾èµ– backend
diff --git a/fsm/token.go b/fsm/token.go
new file mode 100644
index 0000000..11eb139
--- /dev/null
+++ b/fsm/token.go
@@ -0,0 +1,15 @@
+package fsm
+
+type RawTokenKind int
+
+const (
+	TokenDigit RawTokenKind = iota
+	TokenKey
+	TokenRepeat
+	TokenSystem
+)
+
+type RawToken struct {
+	Kind  RawTokenKind
+	Value string
+}
\ No newline at end of file
diff --git a/fsm/ui_stub.go b/fsm/ui_stub.go
index 57cfe9b..0ec228f 100644
--- a/fsm/ui_stub.go
+++ b/fsm/ui_stub.go
@@ -1,5 +1,10 @@
 package fsm
 
+import (
+	"fmt"
+	"os/exec"
+)
+
 // UIDriver å®šä¹‰UIé©±åŠ¨æ¥å£
 type UIDriver interface {
 	SetUserOption(option, value string) error
@@ -15,9 +20,48 @@ func SetUIDriver(driver UIDriver) {
 
 // UpdateUI æ›´æ–°UIæ˜¾ç¤ºå½“å‰FSMçŠ¶æ€ï¼ˆInvariant 9: UI æ´¾ç”ŸçŠ¶æ€ï¼‰
 func UpdateUI(_ ...any) {
-	// Phaseâ€‘3 invariant:
-	// FSM does NOT touch UI / backend directly.
-	// UI update must be handled by Kernel / Weaver.
+	// TEMPORARY: debug-only UI bridge
+	// This is a technical debt - FSM should NOT directly touch tmux
+	// TODO: Move to Kernel â†’ Weaver â†’ Backend pipeline
+	updateTmuxVariables()
+}
+
+// updateTmuxVariables æ›´æ–° tmux çŠ¶æ€å˜é‡
+func updateTmuxVariables() {
+	if defaultEngine == nil {
+		return
+	}
+
+	// æ›´æ–°çŠ¶æ€å˜é‡
+	activeLayer := defaultEngine.Active
+	if activeLayer == "" {
+		activeLayer = "NAV"
+	}
+
+	// è®¾ç½®çŠ¶æ€å˜é‡
+	setTmuxOption("@fsm_state", activeLayer)
+
+	// å¦‚æœæœ‰è®¡æ•°å™¨ï¼Œä¹Ÿæ˜¾ç¤ºå®ƒ
+	if defaultEngine.count > 0 {
+		setTmuxOption("@fsm_keys", fmt.Sprintf("%d", defaultEngine.count))
+	} else {
+		setTmuxOption("@fsm_keys", "")
+	}
+
+	// åˆ·æ–°å®¢æˆ·ç«¯ä»¥æ›´æ–°çŠ¶æ€æ 
+	refreshTmuxClient()
+}
+
+// setTmuxOption è®¾ç½® tmux é€‰é¡¹
+func setTmuxOption(option, value string) {
+	cmd := exec.Command("tmux", "set", "-g", option, value)
+	_ = cmd.Run()
+}
+
+// refreshTmuxClient åˆ·æ–° tmux å®¢æˆ·ç«¯
+func refreshTmuxClient() {
+	cmd := exec.Command("tmux", "refresh-client", "-S")
+	_ = cmd.Run()
 }
 
 // HideUI éšè—UI
@@ -25,4 +69,8 @@ func HideUI() {
 	// Phaseâ€‘3 invariant:
 	// FSM does NOT touch UI / backend directly.
 	// UI update must be handled by Kernel / Weaver.
+	// ä½†æ˜¯ï¼Œä¸ºäº†éšè—çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦é‡ç½® tmux å˜é‡
+	setTmuxOption("@fsm_state", "")
+	setTmuxOption("@fsm_keys", "")
+	refreshTmuxClient()
 }
\ No newline at end of file
diff --git a/intent/intent.go b/intent/intent.go
index 6d3c341..806b7e2 100644
--- a/intent/intent.go
+++ b/intent/intent.go
@@ -20,8 +20,53 @@ const (
 	IntentRepeat
 	IntentFind
 	IntentExit
+	IntentCount
+	IntentOperator
+	IntentMotion
 )
 
+// OperatorKind æ“ä½œç¬¦ç±»å‹
+type OperatorKind int
+
+const (
+	OpMove OperatorKind = iota
+	OpDelete
+	OpYank
+	OpChange
+)
+
+// MotionKind åŠ¨ä½œç±»å‹
+type MotionKind int
+
+const (
+	MotionChar MotionKind = iota
+	MotionWord
+	MotionLine
+	MotionGoto
+	MotionFind
+)
+
+// RangeType èŒƒå›´ç±»å‹
+type RangeType int
+
+const (
+	Exclusive RangeType = iota
+	Inclusive
+	LineWise
+)
+
+// Intent æ„å›¾ç»“æ„ï¼ˆç”¨äºæ‰§è¡Œå±‚ï¼‰
+type Intent struct {
+	Kind         IntentKind             `json:"kind"`
+	Target       SemanticTarget         `json:"target"`
+	Count        int                    `json:"count"`
+	Meta         map[string]interface{} `json:"meta,omitempty"`
+	PaneID       string                 `json:"pane_id"`
+	SnapshotHash string                 `json:"snapshot_hash"` // Phase 6.2
+	AllowPartial bool                   `json:"allow_partial"` // Phase 7: Explicit permission for fuzzy resolution
+	Anchors      []Anchor               `json:"anchors,omitempty"` // Phase 11.0: Support for multi-cursor / multi-selection
+}
+
 // SemanticTarget è¯­ä¹‰ç›®æ ‡ï¼ˆè€Œéç‰©ç†ä½ç½®ï¼‰
 type SemanticTarget struct {
 	Kind      int    `json:"kind"`
@@ -41,17 +86,7 @@ type Anchor struct {
 	End    int         `json:"end,omitempty"`     // Phase 11: End position in line
 }
 
-// Intent æ„å›¾ç»“æ„
-type Intent struct {
-	Kind         IntentKind             `json:"kind"`
-	Target       SemanticTarget         `json:"target"`
-	Count        int                    `json:"count"`
-	Meta         map[string]interface{} `json:"meta,omitempty"`
-	PaneID       string                 `json:"pane_id"`
-	SnapshotHash string                 `json:"snapshot_hash"` // Phase 6.2
-	AllowPartial bool                   `json:"allow_partial"` // Phase 7: Explicit permission for fuzzy resolution
-	Anchors      []Anchor               `json:"anchors,omitempty"` // Phase 11.0: Support for multi-cursor / multi-selection
-}
+
 
 // GetPaneID è·å–é¢æ¿ID
 func (i Intent) GetPaneID() string {
@@ -66,4 +101,5 @@ func (i Intent) GetSnapshotHash() string {
 // IsPartialAllowed æ˜¯å¦å…è®¸éƒ¨åˆ†åŒ¹é…
 func (i Intent) IsPartialAllowed() bool {
 	return i.AllowPartial
-}
\ No newline at end of file
+}
+
diff --git a/kernel/decide.go b/kernel/decide.go
index e5d552d..503a992 100644
--- a/kernel/decide.go
+++ b/kernel/decide.go
@@ -1,7 +1,9 @@
 package kernel
 
 import (
+	"tmux-fsm/fsm"
 	"tmux-fsm/intent"
+	"tmux-fsm/planner"
 )
 
 type DecisionKind int
@@ -17,19 +19,50 @@ type Decision struct {
 	Intent *intent.Intent
 }
 
+// GrammarEmitter ç”¨äºå°† Grammar çš„ç»“æœä¼ é€’ç»™ Kernel
+type GrammarEmitter struct {
+	grammar *planner.Grammar
+	callback func(*intent.Intent)
+}
+
+func (g *GrammarEmitter) Emit(token fsm.RawToken) {
+	intent := g.grammar.Consume(token)
+	if intent != nil && g.callback != nil {
+		g.callback(intent)
+	}
+}
+
 func (k *Kernel) Decide(key string) *Decision {
 	// âœ… 1. FSM æ°¸è¿œå…ˆæ‹¿ key
 	if k.FSM != nil {
-		intent, ok := k.FSM.Produce(key)
-		if ok && intent != nil {
+		var lastIntent *intent.Intent
+
+		// åˆ›å»ºä¸€ä¸ª GrammarEmitter æ¥å¤„ç† token
+		grammarEmitter := &GrammarEmitter{
+			grammar: k.Grammar,
+			callback: func(intent *intent.Intent) {
+				lastIntent = intent
+			},
+		}
+
+		// æ·»åŠ  GrammarEmitter åˆ° FSM
+		k.FSM.AddEmitter(grammarEmitter)
+
+		// è®© FSM å¤„ç†æŒ‰é”®
+		dispatched := k.FSM.Dispatch(key)
+
+		// ç§»é™¤ GrammarEmitter
+		k.FSM.RemoveEmitter(grammarEmitter)
+
+		if dispatched && lastIntent != nil {
 			return &Decision{
 				Kind:   DecisionFSM,
-				Intent: intent,
+				Intent: lastIntent,
 			}
 		}
-		// å¦‚æœFSMæ˜ç¡®å¤„ç†äº†ä½†ä¸äº§ç”Ÿæ„å›¾ï¼Œè¯´æ˜æ˜¯å±‚åˆ‡æ¢ç­‰æ“ä½œ
-		if k.FSM.InLayer() && k.FSM.CanHandle(key) {
-			return nil // FSMåæ‰æŒ‰é”®ï¼Œä¸äº§ç”Ÿå†³ç­–
+
+		if dispatched {
+			return nil // FSMå¤„ç†äº†æŒ‰é”®ï¼Œä½†æ²¡æœ‰äº§ç”Ÿæ„å›¾
 		}
 	}
 
diff --git a/kernel/kernel.go b/kernel/kernel.go
index af231b6..a0c4a3b 100644
--- a/kernel/kernel.go
+++ b/kernel/kernel.go
@@ -3,11 +3,13 @@ package kernel
 import (
 	"context"
 	"tmux-fsm/fsm"
+	"tmux-fsm/planner"
 )
 
 type Kernel struct {
-	FSM    *fsm.Engine
-	Exec   IntentExecutor
+	FSM     *fsm.Engine
+	Grammar *planner.Grammar
+	Exec    IntentExecutor
 }
 
 // âœ… Kernel çš„å”¯ä¸€ä¸Šä¸‹æ–‡å…¥å£ï¼ˆç°åœ¨å…ˆå¾ˆè–„ï¼Œæœªæ¥å¯æ‰©å±•ï¼‰
@@ -17,8 +19,9 @@ type HandleContext struct {
 
 func NewKernel(fsmEngine *fsm.Engine, exec IntentExecutor) *Kernel {
 	return &Kernel{
-		FSM:  fsmEngine,
-		Exec: exec,
+		FSM:     fsmEngine,
+		Grammar: planner.NewGrammar(),
+		Exec:    exec,
 	}
 }
 
diff --git a/planner/grammar.go b/planner/grammar.go
new file mode 100644
index 0000000..1ef8046
--- /dev/null
+++ b/planner/grammar.go
@@ -0,0 +1,186 @@
+package planner
+
+import (
+	"tmux-fsm/fsm"
+	"tmux-fsm/intent"
+)
+
+// Grammar æ˜¯ Stageâ€‘4 Vim Grammar
+type Grammar struct {
+	count      int
+	pendingOp  *intent.OperatorKind
+	lastIntent *intent.Intent
+}
+
+// NewGrammar åˆ›å»º Grammar å®ä¾‹
+func NewGrammar() *Grammar {
+	return &Grammar{}
+}
+
+// Consume æ¶ˆè´¹ä¸€ä¸ª FSM RawTokenï¼Œå¿…è¦æ—¶äº§ç”Ÿ Intent
+func (g *Grammar) Consume(tok fsm.RawToken) *intent.Intent {
+	switch tok.Kind {
+
+	case fsm.TokenDigit:
+		g.count = g.count*10 + int(tok.Value[0]-'0')
+		return nil
+
+	case fsm.TokenRepeat:
+		if g.lastIntent != nil {
+			return cloneIntent(g.lastIntent)
+		}
+		return nil
+
+	case fsm.TokenKey:
+		return g.consumeKey(tok.Value)
+
+	case fsm.TokenSystem:
+		// ç³»ç»Ÿäº‹ä»¶ï¼Œé‡ç½®çŠ¶æ€
+		if tok.Value == "reset" || tok.Value == "exit" || tok.Value == "enter" {
+			g.reset()
+		}
+		return nil
+	}
+
+	return nil
+}
+
+// consumeKey å¤„ç†æ™®é€šæŒ‰é”®
+func (g *Grammar) consumeKey(key string) *intent.Intent {
+
+	// 1ï¸âƒ£ operator
+	if op, ok := parseOperator(key); ok {
+		// dd / yy
+		if g.pendingOp != nil && *g.pendingOp == op {
+			intent := makeLineIntent(op, max(g.count, 1))
+			g.reset()
+			g.remember(intent)
+			return intent
+		}
+
+		g.pendingOp = &op
+		return nil
+	}
+
+	// 2ï¸âƒ£ motion
+	if motion, ok := parseMotion(key); ok {
+
+		// op + motion
+		if g.pendingOp != nil {
+			intent := makeOpMotionIntent(
+				*g.pendingOp,
+				motion,
+				max(g.count, 1),
+			)
+			g.reset()
+			g.remember(intent)
+			return intent
+		}
+
+		// standalone motion (move)
+		intent := makeMoveIntent(motion, max(g.count, 1))
+		g.reset()
+		g.remember(intent)
+		return intent
+	}
+
+	// unknown key â†’ reset
+	g.reset()
+	return nil
+}
+
+// ---------- Intent builders ----------
+
+func makeMoveIntent(m intent.MotionKind, count int) *intent.Intent {
+	return &intent.Intent{
+		Kind:  intent.IntentMove,
+		Count: count,
+		Meta: map[string]interface{}{
+			"motion": m,
+		},
+	}
+}
+
+func makeOpMotionIntent(op intent.OperatorKind, m intent.MotionKind, count int) *intent.Intent {
+	return &intent.Intent{
+		Kind:  intent.IntentOperator,
+		Count: count,
+		Meta: map[string]interface{}{
+			"operator": op,
+			"motion":   m,
+		},
+	}
+}
+
+func makeLineIntent(op intent.OperatorKind, count int) *intent.Intent {
+	return &intent.Intent{
+		Kind:  intent.IntentOperator,
+		Count: count,
+		Meta: map[string]interface{}{
+			"operator": op,
+			"motion":   intent.MotionLine,
+		},
+	}
+}
+
+// ---------- helpers ----------
+
+func (g *Grammar) reset() {
+	g.count = 0
+	g.pendingOp = nil
+}
+
+func (g *Grammar) remember(i *intent.Intent) {
+	g.lastIntent = cloneIntent(i)
+}
+
+func cloneIntent(i *intent.Intent) *intent.Intent {
+	c := *i
+	if i.Meta != nil {
+		c.Meta = make(map[string]interface{})
+		for k, v := range i.Meta {
+			c.Meta[k] = v
+		}
+	}
+	return &c
+}
+
+func max(a, b int) int {
+	if a > b {
+		return a
+	}
+	return b
+}
+
+// ---------- key parsing (Grammar owns Vim) ----------
+
+func parseOperator(key string) (intent.OperatorKind, bool) {
+	switch key {
+	case "d":
+		return intent.OpDelete, true
+	case "y":
+		return intent.OpYank, true
+	case "c":
+		return intent.OpChange, true
+	default:
+		return 0, false
+	}
+}
+
+func parseMotion(key string) (intent.MotionKind, bool) {
+	switch key {
+	case "h", "l":
+		return intent.MotionChar, true
+	case "j", "k":
+		return intent.MotionLine, true
+	case "w", "b", "e":
+		return intent.MotionWord, true
+	case "$", "0":
+		return intent.MotionChar, true
+	case "G":
+		return intent.MotionGoto, true
+	// "g" ä¸ä½œä¸º motionï¼Œå› ä¸ºå®ƒæ˜¯å‰ç¼€é”®
+	default:
+		return 0, false
+	}
+}
\ No newline at end of file
å¥½ï¼Œä¸‹é¢æˆ‘ä»¬æ­£å¼è¿›å…¥**Stageâ€‘5ï¼šSelection / Range Resolver**ã€‚  
è¿™æ˜¯ Vim æ¶æ„é‡Œ**ç¬¬äºŒéš¾**çš„ä¸€å±‚ï¼Œä½†ä½ ç°åœ¨çš„åŸºç¡€å·²ç»å®Œå…¨åˆ°ä½äº†ã€‚

æˆ‘ä¼šæŒ‰ **è®¾è®¡ â†’ æ•°æ®ç»“æ„ â†’ æ ¸å¿ƒç®—æ³• â†’ ç¤ºä¾‹ â†’ æ‰©å±•ç‚¹** æ¥è®²ï¼Œå…¨éƒ¨éƒ½**ä¸æ±¡æŸ“ Grammarã€ä¸æ±¡æŸ“ Executor**ã€‚

---

# âœ… Stageâ€‘5ï¼šSelection / Range Resolver

## ğŸ¯ è¿™ä¸€å±‚çš„èŒè´£ï¼ˆéå¸¸é‡è¦ï¼‰

> **æŠŠ Intent â†’ Rangeï¼ˆé€‰æ‹©åŒºé—´ï¼‰**

å®ƒ **åªå›ç­”ä¸€ä¸ªé—®é¢˜**ï¼š

> ğŸ‘‰ã€Œè¿™æ¡ Intent *ä½œç”¨åœ¨å“ªäº›å­—ç¬¦èŒƒå›´ä¸Š*ï¼Ÿã€

âœ… ä¸ä¿®æ”¹ buffer  
âœ… ä¸å…³å¿ƒ UI  
âœ… ä¸å…³å¿ƒ undo  
âœ… ä¸å…³å¿ƒ cursor ç§»åŠ¨ç»“æœ  

---

## âœ… ä¸€ã€å®šä¹‰ Rangeï¼ˆæœ€å°æŠ½è±¡ï¼‰

```go
type Pos struct {
	Line int
	Col  int
}

type Range struct {
	Start Pos
	End   Pos // åŠå¼€åŒºé—´ [Start, End)
}
```

âœ… Vim / LSP / Treeâ€‘sitter é€šç”¨  
âœ… å¯æ‰©å±•å¤šé€‰åŒº

---

## âœ… äºŒã€Resolver æ¥å£ï¼ˆIntent â†’ []Rangeï¼‰

```go
type Resolver struct {
	Buffer BufferView
}
```

`BufferView` æ˜¯ä¸€ä¸ª **åªè¯»è§†å›¾æ¥å£**ï¼š

```go
type BufferView interface {
	Line(line int) string
	LineCount() int
}
```

âœ… Resolver ä¸çŸ¥é“ Rope / Gap / PieceTable  
âœ… Executor ä»¥åéšä¾¿æ¢

---

## âœ… ä¸‰ã€å…¥å£å‡½æ•°ï¼ˆå”¯ä¸€å…¥å£ï¼‰

```go
func (r *Resolver) Resolve(
	intent *intent.Intent,
	cursor Pos,
) ([]Range, error)
```

---

## âœ… å››ã€Intent åˆ†ç±»å¤„ç†ï¼ˆæ ¸å¿ƒ dispatchï¼‰

```go
switch {
case intent.IsOperatorMotion():
	return r.resolveOpMotion(intent, cursor)

case intent.IsOperatorTextObject():
	return r.resolveOpTextObject(intent, cursor)

default:
	return nil, ErrUnsupportedIntent
}
```

---

# âœ… äº”ã€TextObject Resolverï¼ˆé‡ç‚¹ï¼‰

## 1ï¸âƒ£ æ‹† Metaï¼ˆè¿™é‡Œæ˜¯å”¯ä¸€ä½¿ç”¨ Meta çš„åœ°æ–¹ï¼‰

```go
meta := intent.Meta.(intent.OpTextObjectMeta)

op     := meta.Operator
	scope := meta.Scope
	obj   := meta.Object
```

---

## 2ï¸âƒ£ dispatch åˆ°å…·ä½“ textobject ç®—æ³•

```go
switch obj {
case intent.TextObjectWord:
	return r.wordObject(cursor, scope, intent.Count)

case intent.TextObjectParen:
	return r.parenObject(cursor, scope)

default:
	return nil, ErrUnsupportedTextObject
}
```

---

# âœ… å…­ã€Word TextObjectï¼ˆæœ€å°å¯ç”¨ç®—æ³•ï¼‰

### å®šä¹‰ word

æˆ‘ä»¬å…ˆç”¨ Vim çš„â€œiskeyword ç®€åŒ–ç‰ˆâ€ï¼š

```go
func isWordChar(r rune) bool {
	return unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_'
}
```

---

## âœ… inner word (`iw`)

```go
func (r *Resolver) innerWord(cursor Pos) (Range, bool) {
	line := r.Buffer.Line(cursor.Line)

	i := cursor.Col
	if i >= len(line) {
		i = len(line) - 1
	}

	if !isWordChar(rune(line[i])) {
		return Range{}, false
	}

	start := i
	for start > 0 && isWordChar(rune(line[start-1])) {
		start--
	}

	end := i + 1
	for end < len(line) && isWordChar(rune(line[end])) {
		end++
	}

	return Range{
		Start: Pos{cursor.Line, start},
		End:   Pos{cursor.Line, end},
	}, true
}
```

---

## âœ… around word (`aw`)

```go
func (r *Resolver) aroundWord(cursor Pos) (Range, bool) {
	rng, ok := r.innerWord(cursor)
	if !ok {
		return Range{}, false
	}

	line := r.Buffer.Line(cursor.Line)

	start := rng.Start.Col
	for start > 0 && unicode.IsSpace(rune(line[start-1])) {
		start--
	}

	end := rng.End.Col
	for end < len(line) && unicode.IsSpace(rune(line[end])) {
		end++
	}

	return Range{
		Start: Pos{cursor.Line, start},
		End:   Pos{cursor.Line, end},
	}, true
}
```

---

## âœ… æ”¯æŒ countï¼ˆä¾‹å¦‚ `d2iw`ï¼‰

```go
func (r *Resolver) wordObject(
	cursor Pos,
	scope intent.TextObjectScope,
	count int,
) ([]Range, error) {

	var ranges []Range
	cur := cursor

	for i := 0; i < count; i++ {
		var rng Range
		var ok bool

		if scope == intent.Inner {
			rng, ok = r.innerWord(cur)
		} else {
			rng, ok = r.aroundWord(cur)
		}

		if !ok {
			break
		}

		ranges = append(ranges, rng)

		// ç§»åŠ¨ cursor åˆ°ä¸‹ä¸€ä¸ª word
		cur = Pos{rng.End.Line, rng.End.Col}
	}

	return ranges, nil
}
```

âœ… **Resolver å…è®¸è¿”å›å¤šä¸ª Range**  
âœ… Executor å†³å®šå¦‚ä½•å¤„ç†ï¼ˆmerge / iterateï¼‰

---

# âœ… ä¸ƒã€æ‹¬å· TextObjectï¼ˆæœ€å°ç‰ˆæœ¬ï¼‰

```go
func (r *Resolver) parenObject(
	cursor Pos,
	scope intent.TextObjectScope,
) ([]Range, error) {

	line := r.Buffer.Line(cursor.Line)

	// å‘å·¦æ‰¾ '('
	open := -1
	for i := cursor.Col; i >= 0; i-- {
		if line[i] == '(' {
			open = i
			break
		}
	}

	if open == -1 {
		return nil, ErrNoMatchingParen
	}

	// å‘å³æ‰¾ ')'
	close := -1
	for i := open + 1; i < len(line); i++ {
		if line[i] == ')' {
			close = i
			break
		}
	}

	if close == -1 {
		return nil, ErrNoMatchingParen
	}

	if scope == intent.Inner {
		open++
	} else {
		close++
	}

	return []Range{{
		Start: Pos{cursor.Line, open},
		End:   Pos{cursor.Line, close},
	}}, nil
}
```

âœ… è¿™æ˜¯ **æœ€å°ç‰ˆæœ¬**  
âœ… åµŒå¥—ã€è·¨è¡Œä»¥åå†åŠ 

---

# âœ… å…«ã€Executor ç»ˆäºå¯ä»¥â€œå‚»ç“œå¼â€å·¥ä½œäº†

```go
ranges, _ := resolver.Resolve(intent, cursor)

for _, r := range ranges {
	executor.Apply(intent.Operator, r)
}
```

âœ… Executor ä¸éœ€è¦çŸ¥é“ Vim  
âœ… Resolver ä¸ä¿®æ”¹ buffer  
âœ… Grammar ä¸çŸ¥é“ Range

---

# âœ… ä¹ã€ä½ ç°åœ¨å·²ç»æ‹¥æœ‰çš„èƒ½åŠ›

| è¾“å…¥ | è¯­ä¹‰ |
|---|---|
| `diw` | delete inner word |
| `daw` | delete word + space |
| `d2iw` | delete two words |
| `ci(` | change inside parens |

âœ… æ¶æ„å’Œ Vim åŒå‹  
âœ… å¯æ‰©å±•åˆ° multiâ€‘cursor  
âœ… å¯ fuzz test Resolver

---

# ğŸ§­ ä¸‹ä¸€æ­¥ï¼ˆä½ å·²ç»ç«™åœ¨ 90% çš„é—¨å£ï¼‰

ä½ æ¥ä¸‹æ¥æœ‰ä¸‰æ¡ **éå¸¸è‡ªç„¶** çš„è·¯ï¼š

1ï¸âƒ£ **Motion Resolver**ï¼ˆ`dw / w / e / $`ï¼‰  
2ï¸âƒ£ **è·¨è¡Œ TextObjectï¼ˆparagraph / sentenceï¼‰**  
3ï¸âƒ£ **Undo / Change operator çš„ Insert æ¨¡å¼æ¡¥æ¥**

---

### ğŸ‘‰ æ¨èé¡ºåº

> **Motion Resolver â†’ Change Operator â†’ Insert Mode**

---

åªè¦ä½ ä¸€å¥è¯ï¼š

**â€œç»§ç»­ï¼šMotion Resolverï¼ˆdw / w / eï¼‰â€**

æˆ‘å°±æŠŠå‰©ä¸‹ 10% ç»™ä½ è¡¥é½ã€‚