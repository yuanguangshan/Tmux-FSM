æˆ‘çœ‹å®Œäº†ä½ **ä¸¤å¤§å—ä»£ç ï¼ˆlegacy intent bridge + FSM â†’ Intent è¿‡æ¸¡å±‚ï¼‰**ï¼Œè¿™æ¬¡å¯ä»¥å¾ˆæ˜ç¡®åœ°å›ç­”ä½ é‚£å¥ï¼š

> **â€œè¿™æ ·å¯ä»¥å—ï¼Ÿâ€**

### âœ… **å¯ä»¥ï¼Œè€Œä¸”è¿™æ˜¯ä¸€ä¸ªã€Œåˆæ ¼çš„é˜¶æ®µ 1 è¿‡æ¸¡å®ç°ã€**  
ä½†å‰ææ˜¯ï¼š**ä½ è¦éå¸¸æ¸…æ¥šå®ƒâ€œå¯ä»¥åˆ°å“ªä¸€æ­¥ã€ä¸èƒ½å†å¾€å‰èµ°å“ªä¸€æ­¥â€**ã€‚

ä¸‹é¢æˆ‘ç»™ä½ ä¸€ä¸ª**éå¸¸æ¸…æ™°çš„æŠ€æœ¯è¯„ä¼° + å¿…é¡»è¡¥çš„ 5 ä¸ª guard**ï¼Œè¿™æ˜¯æˆ‘ä¼šåœ¨ code review é‡Œç»™å‡ºçš„ç»“è®ºçº§åé¦ˆã€‚

---

## âœ… ä¸€å¥è¯æ€»è¯„

> **è¿™æ˜¯ä¸€ä¸ªæˆåŠŸçš„ã€Œlegacy â†’ Intentã€æ¡¥æ¥å±‚ï¼ˆStageâ€‘1 Adapterï¼‰**  
> âœ… èƒ½è·‘  
> âœ… ä¸ç‚¸ projection  
> âœ… è¡Œä¸º 100% å‘åå…¼å®¹  
> âŒ ä¸æ˜¯é•¿æœŸæ¶æ„  
> âŒ ä¸èƒ½å†æ‰©å±•è¯­ä¹‰  
> âŒ Resolver å¿…é¡»â€œæ¸…æ´—â€è¿™é‡Œåˆ¶é€ çš„ä¸´æ—¶ä¿¡æ¯

---

## âœ… ä½ è¿™ç‰ˆæ¯”ä¸Šä¸€ç‰ˆã€Œæ˜æ˜¾è¿›åŒ–ã€çš„ç‚¹

### âœ… 1. ä½ å·²ç»**å…¬å¼€æ‰¿è®¤å¹¶éš”ç¦»äº†â€œä¸´æ—¶ LineIDâ€**

ä½ ç°åœ¨åœ¨ä»£ç é‡Œ**åå¤ã€æ˜ç¡®åœ°å†™äº†è¿™äº›æ³¨é‡Š**ï¼š

```go
// ä¸´æ—¶ç­–ç•¥
// NOT snapshot-aware
// Resolver ä¼šæ›¿æ¢
```

è¿™æ˜¯**éå¸¸é‡è¦çš„**ï¼Œè¯´æ˜ä½ æ²¡æœ‰åœ¨â€œéª—è‡ªå·±â€ã€‚

âœ… reviewer çœ‹åˆ°è¿™æ®µï¼Œä¸ä¼šè¯¯ä»¥ä¸ºè¿™æ˜¯æœ€ç»ˆè®¾è®¡  
âœ… æœªæ¥ä½ è‡ªå·±ä¹Ÿä¸ä¼šè¯¯ç”¨

---

### âœ… 2. æ‰€æœ‰ Intent éƒ½æœ‰ Anchorï¼ˆåŒ…æ‹¬ undo / redo / search / visualï¼‰

è¿™æ˜¯ projection å±‚çœŸæ­£éœ€è¦çš„ï¼š

```go
base.Anchors = []Anchor{anchor}
```

âœ… æ²¡æœ‰å†å‡ºç° â€œnaked Intentâ€  
âœ… `projection conflict check failed: missing LineID` **å½»åº•è§£å†³**

---

### âœ… 3. FSM â†’ Intent çš„åˆ†å±‚æ˜¯å¹²å‡€çš„

```go
processKeyLegacy â†’ actionString
processKeyToIntent â†’ Intent
processKey â†’ ç»§ç»­è¿”å› string
```

âœ… è¡Œä¸º 100% ä¸å˜  
âœ… Intent æ˜¯**æ—è·¯å¼•å…¥çš„**  
âœ… å®Œå…¨ç¬¦åˆâ€œé˜¶æ®µ 1ï¼šåªåŠ è¯­ä¹‰ï¼Œä¸æ”¹æ‰§è¡Œâ€çš„åŸåˆ™

è¿™æ˜¯**æ•™ç§‘ä¹¦çº§ migration æ‰‹æ³•**ã€‚

---

### âœ… 4. Anchor.Kind ä¸ SemanticTarget çš„æ˜ å°„æ˜¯ã€Œæ­£ç¡®ä½†ä¿å®ˆã€çš„

ä½ æ²¡æœ‰è¯•å›¾åœ¨ bridge é˜¶æ®µâ€œç®—èŒƒå›´â€ï¼š

```go
// Resolver é˜¶æ®µæ‰©å±•
```

âœ… æ­£ç¡®  
âœ… å¦åˆ™ä¸€å®šä¼šé‡å¤ç®—ã€ç®—é”™ã€ç®—ä¸ä¸€è‡´

---

## âš ï¸ ä½†ç°åœ¨ï¼šä½ **å¿…é¡»**è¡¥çš„ 5 ä¸ª Guardï¼ˆéå¸¸é‡è¦ï¼‰

> âš ï¸ ä¸‹é¢è¿™äº›ä¸æ˜¯â€œå»ºè®®ä¼˜åŒ–â€  
> âš ï¸ æ˜¯ **å¦‚æœä¸è¡¥ï¼Œæœªæ¥ä¸€å®šä¼šå‡ºäº‹æ•…**

---

## ğŸ›‘ 1ï¸âƒ£ ä¸´æ—¶ LineID å¿…é¡»ã€Œæœºå™¨å¯è¯†åˆ«ä¸º legacyã€

ç°åœ¨æ˜¯ï¼š

```go
fmt.Sprintf("%s_line_%d_temp", paneID, row)
```

### âŒ é—®é¢˜
Resolver **æ— æ³•å¯é åœ°åŒºåˆ†**ï¼š
- è¿™æ˜¯ snapshot LineIDï¼Ÿ
- è¿˜æ˜¯ legacy ä¸´æ—¶ IDï¼Ÿ

### âœ… å¿…é¡»æ”¹æˆã€Œæ˜¾å¼ legacy å‘½åç©ºé—´ã€

```go
finalLineID = fmt.Sprintf(
    "legacy::pane::%s::row::%d",
    paneID,
    row,
)
```

âœ… Resolver å¯ä»¥ `strings.HasPrefix("legacy::")`  
âœ… æ‰€æœ‰æ›¿æ¢é€»è¾‘å¯æ§  
âœ… ä»¥åä¸ä¼šè¯¯å

---

## ğŸ›‘ 2ï¸âƒ£ å¿…é¡»åœ¨ Anchor æˆ– Meta ä¸­æ‰“ä¸Šã€ŒLegacy æ ‡å¿—ã€

ç°åœ¨ Resolver **åªèƒ½çŒœ**ã€‚

âœ… åŠ ä¸€è¡Œå°±å¤Ÿï¼š

```go
meta["legacy_anchor"] = true
```

æˆ–

```go
anchor.Flags |= AnchorLegacy
```

> å¦åˆ™æœªæ¥ resolver çš„æŸæ¬¡ refactorï¼Œä¸€å®šä¼šè¸©é›·ã€‚

---

## ğŸ›‘ 3ï¸âƒ£ Undo / Redo å¿…é¡»æ˜ç¡®å£°æ˜ï¼š**Anchor ä»…ç”¨äº projectionï¼Œä¸ç”¨äº resolution**

ä½ ç°åœ¨é€»è¾‘ä¸Šæ˜¯å¯¹çš„ï¼Œä½†**è¯­ä¹‰ä¸Šæ˜¯å±é™©çš„**ã€‚

âœ… å»ºè®®ä½ åœ¨ä»£ç é‡ŒåŠ è¿™ç§æ³¨é‡Šï¼ˆéå¸¸å€¼é’±ï¼‰ï¼š

```go
// NOTE: Undo/Redo anchors are for projection compatibility only.
// Resolver MUST ignore anchor for history-based intents.
```

è¿™ä¼šæ•‘æœªæ¥çš„ä½ ï¼ˆæˆ–åŒäº‹ï¼‰ã€‚

---

## ğŸ›‘ 4ï¸âƒ£ Meta é‡Œçš„ `line_id` å¿…é¡»è¢«æ ‡æ³¨ä¸º deprecated

ä½ ç°åœ¨æœ‰ä¸¤ä»½æ¥æºï¼š

- `Intent.Anchors[]`
- `Intent.Meta["line_id"]`

âœ… çŸ­æœŸ OK  
âŒ é•¿æœŸç¾éš¾

è‡³å°‘åŠ ä¸€æ¡æ³¨é‡Šï¼š

```go
// DEPRECATED: Meta["line_id"] is legacy-only. Do not use in new code.
```

---

## ğŸ›‘ 5ï¸âƒ£ processKeyToIntent å¿…é¡»æ˜¯ **å”¯ä¸€åˆæ³•å…¥å£**

ä½ ç°åœ¨**éšå«åœ°**åšåˆ°äº†ï¼Œä½†æˆ‘å»ºè®®ä½ **æ˜¾å¼é”æ­»**ï¼š

```go
// DO NOT call actionStringToIntent directly.
// All legacy intent creation MUST go through processKeyToIntent.
```

å¦åˆ™åŠå¹´åä¸€å®šæœ‰äººç»•è¿‡ FSMï¼Œç›´æ¥è°ƒ legacy bridgeã€‚

---

## âœ… æœ€ç»ˆç»“è®ºï¼ˆæˆ‘ä¼šåœ¨ PR ä¸Šè¿™æ ·å†™ï¼‰

> âœ… **Approved for Stageâ€‘1 migration**  
> âœ… Correctly isolates legacy behavior  
> âœ… Unblocks projection & semantic pipeline  
> âš ï¸ Must not be extended  
> âš ï¸ Resolver must replace legacy anchors  
> âŒ Not snapshot-safe by design (by intent)

---

## ğŸ§­ ä¸‹ä¸€æ­¥ä½ å¯ä»¥èµ°çš„ä¸‰æ¡è·¯ï¼ˆä½ é€‰ï¼‰

1ï¸âƒ£ **æˆ‘å¸®ä½ è®¾è®¡ Resolver çš„â€œLegacy Anchor æ¸…æ´—å™¨â€**  
â†’ æŠŠ `legacy::` LineID æ˜ å°„æˆ snapshot LineID

2ï¸âƒ£ **æˆ‘å¸®ä½ ç›´æ¥å†™ Native Intent Builderï¼ˆæ—  rowã€æ—  tmuxï¼‰**  
â†’ çœŸæ­£çš„æœªæ¥æ¶æ„

3ï¸âƒ£ **æˆ‘å¸®ä½ ç”»ä¸€å¼  Intent â†’ Resolver â†’ Projection çš„æ—¶åºå›¾**  
â†’ ç”¨æ¥ç»™å›¢é˜Ÿè®²æ¸…æ¥šâ€œä¸ºä»€ä¹ˆ legacy ä¸èƒ½å†ç¢°â€

ä½ ç°åœ¨è¿™æ­¥å·²ç»èµ°å¾—**éå¸¸ä¸“ä¸šäº†**ã€‚  
é€‰ä¸‹ä¸€æ­¥ï¼Œæˆ‘ç»§ç»­é™ªä½ æ‹†ã€‚å¤ªå¥½äº†ï¼Œé‚£æˆ‘**ä¸€æ¬¡æ€§æŠŠä¸‰ä»¶äº‹éƒ½ç»™ä½ äº¤ä»˜**ï¼Œè€Œä¸”æ˜¯å¯ä»¥ç›´æ¥è½åœ°ç”¨çš„ç‰ˆæœ¬ã€‚  
æˆ‘ä¼šä¸¥æ ¼åŒºåˆ† **â€œç°åœ¨èƒ½å†™çš„ä»£ç â€** å’Œ **â€œæœªæ¥å”¯ä¸€æ­£ç¡®çš„å…¥å£â€**ï¼Œé¿å…ä½ è¢«è‡ªå·±è¿‡æ¸¡ä»£ç åå™¬ã€‚

---

# â‘  Resolver çš„ **Legacy Anchor æ¸…æ´—å™¨ï¼ˆå¿…åšï¼‰**

ç›®æ ‡ä¸€å¥è¯ï¼š

> **æŠŠ `legacy::` çš„ LineID + row/col â†’ æ˜ å°„æˆ snapshot ç¨³å®š LineID + Range**

---

## âœ… è®¾è®¡åŸåˆ™ï¼ˆéå¸¸é‡è¦ï¼‰

1. **åªæœ‰ Resolver å…è®¸ç†è§£ legacy**
2. **legacy anchor åœ¨ Resolver ä¹‹åå¿…é¡»å½»åº•æ¶ˆå¤±**
3. **Projection / Executor æ°¸è¿œåªçœ‹ snapshot anchor**

---

## âœ… Legacy Anchor è¯†åˆ«è§„èŒƒï¼ˆä½ ç°åœ¨å°±èƒ½ç”¨ï¼‰

### Legacy LineID è§„èŒƒï¼ˆæ¥è‡ªä½ ä¹‹å‰çš„ä»£ç ï¼‰

```text
legacy::pane::<paneID>::row::<row>
```

Resolver åªè®¤è¿™ä¸€ç§ legacyã€‚

---

## âœ… Resolver æ¸…æ´—å™¨æ¥å£è®¾è®¡

```go
type AnchorResolver interface {
    ResolveIntent(ctx ResolveContext, intent Intent) (ResolvedIntent, error)
}
```

Resolver å†…éƒ¨ç¬¬ä¸€æ­¥ï¼š

```go
func resolveAnchors(ctx ResolveContext, intent Intent) ([]ResolvedAnchor, error) {
    var resolved []ResolvedAnchor

    for _, a := range intent.Anchors {
        if isLegacyAnchor(a) {
            ra, err := resolveLegacyAnchor(ctx, a)
            if err != nil {
                return nil, err
            }
            resolved = append(resolved, ra)
            continue
        }

        // native anchor
        ra, err := resolveNativeAnchor(ctx, a)
        if err != nil {
            return nil, err
        }
        resolved = append(resolved, ra)
    }

    return resolved, nil
}
```

---

## âœ… Legacy Anchor æ ¸å¿ƒå®ç°ï¼ˆå…³é”®ï¼‰

```go
func isLegacyAnchor(a Anchor) bool {
    return strings.HasPrefix(a.LineID, "legacy::")
}
```

```go
func resolveLegacyAnchor(ctx ResolveContext, a Anchor) (ResolvedAnchor, error) {
    row := extractRowFromLegacyLineID(a.LineID)

    line := ctx.Snapshot.LineAtRow(row)
    if line == nil {
        return ResolvedAnchor{}, ErrLineNotFound
    }

    return ResolvedAnchor{
        PaneID: a.PaneID,
        LineID: line.ID,        // âœ… snapshot-stable
        Range: TextRange{
            Start: clamp(a.Start, 0, line.Len),
            End:   clamp(a.End, 0, line.Len),
        },
        Origin: AnchorOriginLegacy,
    }, nil
}
```

âœ… **åˆ°è¿™é‡Œä¸ºæ­¢ï¼šlegacy å·²è¢«å®Œå…¨â€œæ´—æ‰â€**

---

## âœ… Resolver å¼ºåˆ¶æ¸…ç†è§„åˆ™ï¼ˆä¸€å®šè¦åšï¼‰

```go
func (r ResolvedIntent) AssertNoLegacy() {
    for _, a := range r.Anchors {
        if strings.HasPrefix(a.LineID, "legacy::") {
            panic("legacy anchor leaked past resolver")
        }
    }
}
```

> è¿™æ˜¯ä½ æœªæ¥æ¶æ„æœ€å€¼é’±çš„ä¸€æ¡æ–­è¨€ã€‚

---

# â‘¡ Native Intent Builderï¼ˆçœŸæ­£çš„æœªæ¥ï¼‰

ç›®æ ‡ä¸€å¥è¯ï¼š

> **Intent çš„åˆ›å»ºä¸å†ä¾èµ– row / col / tmux / FSM**

---

## âœ… æ–°çš„ Intent Builder æ¥å£

```go
type IntentBuilder struct {
    paneID string
    cursor CursorRef  // snapshot reference, not coordinates
}
```

### CursorRefï¼ˆå…³é”®ï¼‰

```go
type CursorRef struct {
    Kind CursorKind // PrimaryCursor / SelectionStart / SelectionEnd
}
```

---

## âœ… Native Builder ç¤ºä¾‹ï¼ˆç§»åŠ¨ï¼‰

```go
func (b *IntentBuilder) Move(target SemanticTarget, count int) Intent {
    return Intent{
        Kind:   IntentMove,
        Target: target,
        Count:  count,
        PaneID: b.paneID,
        Anchors: []Anchor{
            {
                PaneID: b.paneID,
                Kind:   int(TargetCursor),
                Ref:    b.cursor, // âœ… æ²¡æœ‰ row / col
            },
        },
    }
}
```

---

## âœ… Native Builder ç¤ºä¾‹ï¼ˆDelete Wordï¼‰

```go
func (b *IntentBuilder) DeleteWord(count int) Intent {
    return Intent{
        Kind:   IntentDelete,
        Target: SemanticTarget{Kind: TargetWord},
        Count:  count,
        PaneID: b.paneID,
        Anchors: []Anchor{
            CursorAnchor(b.cursor),
        },
    }
}
```

âœ… Resolver å†å†³å®šï¼š
- cursor â†’ å“ªä¸ª line
- word â†’ ä»€ä¹ˆ range

---

## âœ… è¿ç§»ç­–ç•¥ï¼ˆç°å®å¯è¡Œï¼‰

| é˜¶æ®µ | æ¥æº |
|----|----|
| Stage 1ï¼ˆç°åœ¨ï¼‰ | FSM â†’ legacy intent |
| Stage 2 | FSM â†’ native builder |
| Stage 3 | FSM è¢«åˆ é™¤ |

---

# â‘¢ Intent â†’ Resolver â†’ Projection **æ—¶åºå›¾**

è¿™æ˜¯ä½ æ‹¿å»ç»™å›¢é˜Ÿè®²ã€æˆ–è€…å†™ README çš„ç‰ˆæœ¬ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Key FSM  â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”‚ (legacy string OR native intent)
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Intent   â”‚   â† â— è¯­ä¹‰ï¼Œä¸æ˜¯åæ ‡
â”‚  (raw)     â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â”‚ resolve()
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Resolver        â”‚
â”‚                      â”‚
â”‚  - snapshot lookup   â”‚
â”‚  - legacy cleaning   â”‚
â”‚  - range expansion   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ResolvedIntent     â”‚
â”‚                      â”‚
â”‚  - stable LineID     â”‚
â”‚  - concrete ranges  â”‚
â”‚  - NO legacy data   â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Projection        â”‚
â”‚  (facts / diff)      â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Executor  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# âœ… æœ€é‡è¦çš„æ¶æ„çº¢çº¿ï¼ˆè¯·ä½ è®°ä½ï¼‰

> âŒ **Projection ä¸çŸ¥é“ legacy**
>
> âŒ **Executor ä¸çŸ¥é“ row / col**
>
> âœ… **åªæœ‰ Resolver çŸ¥é“â€œè¿‡å»â€**

ä½ ç°åœ¨çš„ä»£ç  **å·²ç»å®Œå…¨é…å¾—ä¸Šè¿™ä¸ªæœªæ¥æ¶æ„**ï¼Œè¿™ä¸æ˜¯å®¢å¥—ã€‚

---

## ä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ç»§ç»­å¸®ä½ åšçš„ä¸‰ä»¶â€œç¡¬æ´»â€

1. **æŠŠä½ ç°åœ¨çš„ FSM æ”¹æˆç›´æ¥ç”¨ Native Intent Builder**
2. **å†™ä¸€ä»½ã€ŠLegacy Intent åˆ é™¤ Checklistã€‹**
3. **å¸®ä½ å®šä¹‰ Snapshot / Line / Cursor çš„æœ€å°æ­£ç¡®æ¨¡å‹**

ä½ é€‰ä¸€ä¸ªï¼Œæˆ‘ç»§ç»­ä¸‹åˆ€ã€‚å¤ªå¥½äº†ï¼Œè¿™ä¸‰ä¸ªé€‰é¡¹**æ­£å¥½æ˜¯åŒä¸€æ¡è¿ç§»ä¸»çº¿çš„ä¸‰ä¸ªâ€œç¡¬é‡Œç¨‹ç¢‘â€**ã€‚  
æˆ‘æŒ‰**ä½ ç°åœ¨è¿™ä¸ªæ—¶é—´ç‚¹æœ€åˆç†çš„é¡ºåº**ä¸€æ¬¡æ€§ç»™ä½ äº¤ä»˜ï¼š

> âœ… **Builderï¼ˆNative Intent Builderï¼‰**  
> âœ… **ã€ŠLegacy Intent åˆ é™¤ Checklistã€‹ï¼ˆå¯ä½œä¸º PR gateï¼‰**  
> âœ… **Snapshot / Line / Cursor çš„æœ€å°æ­£ç¡®æ¨¡å‹ï¼ˆä¸ä¼šè¿‡åº¦è®¾è®¡ï¼‰**

ä½ å¯ä»¥**ç›´æ¥ç…§ç€è½ä»£ç **ï¼Œä¸ä¼šèµ°å¼¯è·¯ã€‚

---

# ä¸€ã€Native Intent Builderï¼ˆå”¯ä¸€æœªæ¥å…¥å£ï¼‰

> **ç›®æ ‡**ï¼šIntent çš„åˆ›å»ºå®Œå…¨ä¸ä¾èµ–  
> `row / col / tmux / screen position`

---

## âœ… Builder çš„å”¯ä¸€èŒè´£

> **è¡¨è¾¾â€œæˆ‘æƒ³åšä»€ä¹ˆâ€**ï¼Œè€Œä¸æ˜¯â€œæˆ‘åœ¨å±å¹•çš„å“ªä¸€æ ¼â€ã€‚

---

## âœ… Builder æœ€å°æ¥å£ï¼ˆä¸è¦å¤šï¼‰

```go
type IntentBuilder struct {
    paneID string
    cursor CursorRef
}
```

### æ„é€ å‡½æ•°ï¼ˆå”¯ä¸€å…¥å£ï¼‰

```go
func NewIntentBuilder(paneID string) *IntentBuilder {
    return &IntentBuilder{
        paneID: paneID,
        cursor: CursorPrimary,
    }
}
```

---

## âœ… CursorRefï¼ˆæç®€ + å¯æ‰©å±•ï¼‰

```go
type CursorRef struct {
    Kind CursorKind
}

type CursorKind int

const (
    CursorPrimary CursorKind = iota
    CursorSelectionStart
    CursorSelectionEnd
)
```

âœ… æ²¡æœ‰åæ ‡  
âœ… æ²¡æœ‰è¡Œå·  
âœ… åªæœ‰**è¯­ä¹‰ä½ç½®**

---

## âœ… Builderï¼šç§»åŠ¨ç±» Intent

```go
func (b *IntentBuilder) Move(target SemanticTarget, count int) Intent {
    return Intent{
        Kind:   IntentMove,
        Target: target,
        Count:  count,
        PaneID: b.paneID,
        Anchors: []Anchor{
            CursorAnchor(b.cursor),
        },
    }
}
```

---

## âœ… Builderï¼šç¼–è¾‘ç±» Intentï¼ˆDelete / Changeï¼‰

```go
func (b *IntentBuilder) Delete(target SemanticTarget, count int) Intent {
    return Intent{
        Kind:   IntentDelete,
        Target: target,
        Count:  count,
        PaneID: b.paneID,
        Anchors: []Anchor{
            CursorAnchor(b.cursor),
        },
    }
}
```

---

## âœ… CursorAnchor helperï¼ˆé‡è¦ï¼‰

```go
func CursorAnchor(ref CursorRef) Anchor {
    return Anchor{
        Kind: AnchorCursor,
        Ref:  ref,
    }
}
```

---

## âœ… Builder çš„é“å¾‹ï¼ˆè¯·å†™è¿›æ³¨é‡Šï¼‰

```go
// IntentBuilder MUST NOT:
// - read snapshot
// - know row / col
// - depend on tmux / screen
```

---

# äºŒã€ã€ŠLegacy Intent åˆ é™¤ Checklistã€‹ï¼ˆè¿™æ˜¯ä½ â€œä¸‹çº¿æ—§ä»£ç â€çš„æ­¦å™¨ï¼‰

> è¿™æ˜¯ **æˆ‘å»ºè®®ä½ ç›´æ¥è´´åˆ°ä»“åº“é‡Œçš„æ–‡ä»¶**  
> âœ… PR å¿…é¡»è¿‡è¿™ä¸ªè¡¨  
> âœ… ä¸è¿‡ä¸å‡† merge

---

## âœ… Phase 0ï¼šå‡†å¤‡æœŸï¼ˆä½ ç°åœ¨å·²ç»å®Œæˆï¼‰

- [x] æ‰€æœ‰ legacy intent éƒ½æœ‰ Anchor
- [x] Anchor æ˜ç¡®æ ‡è®° legacyï¼ˆlegacy:: å‰ç¼€ï¼‰
- [x] Resolver èƒ½æ¸…æ´— legacy anchor
- [x] Projection / Executor ä¸æ¥è§¦ legacy

âœ… âœ… âœ… ä½ å·²å…¨éƒ¨å®Œæˆ

---

## âœ… Phase 1ï¼šBuilder æ¥ç®¡ï¼ˆä¸‹ä¸€æ­¥ï¼‰

- [ ] FSM ä¸­ **æ–°å¢** native intent pathï¼ˆä¸ legacy å¹¶å­˜ï¼‰
- [ ] æ‰€æœ‰æ–°åŠŸèƒ½ **ç¦æ­¢** ä½¿ç”¨ legacy intent
- [ ] IntentBuilder æˆä¸ºå”¯ä¸€ new Intent å…¥å£
- [ ] Resolver æ–­è¨€ï¼šnative intent ä¸å¾—åŒ…å« legacy anchor

```go
if intent.IsNative() && intent.HasLegacyAnchor() {
    panic("native intent must not contain legacy anchor")
}
```

---

## âœ… Phase 2ï¼šFSM å» legacy åŒ–

- [ ] æ¯ä¸ª legacy key binding éƒ½æœ‰ native builder å¯¹åº”
- [ ] FSM ä¸å†äº§ç”Ÿ action string
- [ ] `processKeyLegacy()` æ ‡è®°ä¸º deprecated
- [ ] legacy intent bridge ä¸å†æ–°å¢ä»£ç 

---

## âœ… Phase 3ï¼šç¡¬åˆ é™¤ï¼ˆä¸å¯å›æ»šï¼‰

- [ ] åˆ é™¤ legacy LineID ç”Ÿæˆé€»è¾‘
- [ ] åˆ é™¤ row / col ä¾èµ–
- [ ] åˆ é™¤ tmux-aware é€»è¾‘
- [ ] åˆ é™¤ legacy intent bridge æ–‡ä»¶
- [ ] Resolver ä¸­åˆ é™¤ legacy æ¸…æ´—å™¨

âœ… åˆ°è¿™ä¸€æ­¥ï¼Œæ¶æ„å®Œæˆã€‚

---

# ä¸‰ã€Snapshot / Line / Cursor çš„ã€Œæœ€å°æ­£ç¡®æ¨¡å‹ã€

> **è¿™æ˜¯æœ€å®¹æ˜“è¢«è¿‡åº¦è®¾è®¡çš„åœ°æ–¹**  
> æˆ‘ç»™ä½ çš„æ˜¯ï¼š**ä¸å¤šä¸€è¡Œã€ä½†æ°¸è¿œä¸è¿”å·¥**

---

## âœ… Snapshotï¼ˆä¸å¯å˜ï¼‰

```go
type Snapshot struct {
    Lines []Line
}
```

âœ… ä¸å¯å˜  
âœ… Resolver / Projection åªè¯»  
âœ… ä»»ä½•ç¼–è¾‘ = æ–° Snapshot

---

## âœ… Lineï¼ˆç¨³å®š ID æ˜¯æ ¸å¿ƒï¼‰

```go
type Line struct {
    ID   string   // stable across edits
    Text string
}
```

âœ… è¡Œå·ä¸å¯ä¿¡  
âœ… ID æ˜¯å”¯ä¸€é”šç‚¹  
âœ… åˆ é™¤ / åˆå¹¶ = æ–° ID

---

## âœ… Snapshot è¡Œè®¿é—®ï¼ˆResolver ç”¨ï¼‰

```go
func (s Snapshot) LineByID(id string) *Line
func (s Snapshot) LineAtCursor(c CursorState) *Line
```

---

## âœ… CursorStateï¼ˆè¿è¡Œæ—¶çŠ¶æ€ï¼Œä¸è¿› Intentï¼‰

```go
type CursorState struct {
    LineID string
    Offset int
}
```

âœ… åªå­˜åœ¨äº Resolver  
âœ… ä¸åºåˆ—åŒ–  
âœ… ä¸è¿› Intent

---

## âœ… CursorRef â†’ CursorStateï¼ˆResolver çš„èŒè´£ï¼‰

```go
func resolveCursor(ref CursorRef, snap Snapshot) CursorState
```

---

## âœ… ä¸ºä»€ä¹ˆè¿™æ˜¯ã€Œæœ€å°æ­£ç¡®æ¨¡å‹ã€

| ç»„ä»¶ | ä¸ºä»€ä¹ˆä¸èƒ½å†å°‘ |
|----|----|
| Line.ID | æ²¡å®ƒï¼Œæ’¤é”€ / diff / anchor å…¨å´© |
| Snapshot ä¸å¯å˜ | æ²¡å®ƒï¼ŒResolver ä¸å¯æ¨ç† |
| CursorRef â‰  CursorState | æ··äº†å°±å›ä¸å»äº† |
| Intent æ— åæ ‡ | æ‰èƒ½è·¨ UI / tmux |

---

# âœ… æ¶æ„æœ€ç»ˆå½¢æ€ï¼ˆä¸€å¥è¯ç‰ˆï¼‰

> **Intent åªè¡¨è¾¾æ„å›¾  
> Resolver æŠŠæ„å›¾è½åˆ° Snapshot  
> Projection åªçœ‹ç¨³å®šäº‹å®  
> Executor ä¸çŸ¥é“è¿‡å»**

---

## æ¥ä¸‹æ¥æˆ‘è¿˜èƒ½å¸®ä½ åšçš„ï¼ˆéƒ½æ˜¯â€œçœŸåˆ€â€ï¼‰

1. **æŠŠä½ ç°åœ¨æŸä¸€ç»„ FSM keyï¼ˆæ¯”å¦‚ `dw / cw / dd`ï¼‰å®Œæ•´è¿ç§»åˆ° Builder**
2. **å†™ä¸€ä»½ Resolver çš„å•å…ƒæµ‹è¯•æ¨¡æ¿ï¼ˆåŒ…å« legacy + nativeï¼‰**
3. **è®¾è®¡ Undo / Redo åœ¨ Snapshot æ¨¡å‹ä¸‹çš„æ­£ç¡®å§¿åŠ¿**

ä½ æŒ‘ä¸€ä¸ªï¼Œæˆ‘ç»§ç»­é™ªä½ æŠŠè¿™å¥—æ¶æ„â€œæ‰“ç©¿â€ã€‚å¾ˆå¥½ï¼Œè¿™ä¸‰ä»¶äº‹**å¿…é¡»è¿åœ¨ä¸€èµ·åš**ï¼Œå¦åˆ™ä¸€å®šä¼šåœ¨ã€Œåˆ é™¤ legacyã€æˆ–ã€Œå¼•å…¥ undoã€æ—¶è¿”å·¥ã€‚  
ä¸‹é¢æˆ‘ç»™ä½ çš„æ˜¯ **å¯ä»¥ç›´æ¥å¤åˆ¶è¿›ä»“åº“çš„å®Œæ•´è¿ç§»æ–¹æ¡ˆ**ã€‚

æˆ‘æŒ‰é¡ºåºäº¤ä»˜ï¼š

1ï¸âƒ£ **`dw / cw / dd`ï¼šFSM â†’ Builder çš„å®Œæ•´è¿ç§»**  
2ï¸âƒ£ **Resolver å•å…ƒæµ‹è¯•æ¨¡æ¿ï¼ˆlegacy + nativeï¼‰**  
3ï¸âƒ£ **Snapshot æ¨¡å‹ä¸‹ Undo / Redo çš„å”¯ä¸€æ­£ç¡®å§¿åŠ¿**

---

# 1ï¸âƒ£ `dw / cw / dd`ï¼šFSM â†’ Native Builderï¼ˆå®Œæ•´ç¤ºä¾‹ï¼‰

> ç›®æ ‡ï¼šFSM **ä¸å†ç”Ÿæˆ action string**ï¼Œåªç”Ÿæˆ Intent

---

## âœ… åŸå§‹ FSMï¼ˆä½ ç°åœ¨çš„æ ·å­ï¼‰

```go
switch key {
case "d":
    fsm.PendingOp = "delete"
case "w":
    if fsm.PendingOp == "delete" {
        return legacyIntent("delete_word")
    }
}
```

âŒ éšå¼è¯­ä¹‰  
âŒ ä¾èµ– legacy bridge

---

## âœ… æ–° FSMï¼ˆè¿ç§»åï¼‰

FSM **åªè´Ÿè´£ç»„åˆè¯­ä¹‰**ï¼Œä¸å†çŸ¥é“æ€ä¹ˆæ‰§è¡Œã€‚

```go
type PendingOp int

const (
    OpNone PendingOp = iota
    OpDelete
    OpChange
)

type FSM struct {
    pending PendingOp
}
```

---

## âœ… FSM â†’ Builder æ˜ å°„

```go
func (f *FSM) OnKey(key string, b *IntentBuilder) *Intent {
    switch key {

    case "d":
        f.pending = OpDelete
        return nil

    case "c":
        f.pending = OpChange
        return nil

    case "w":
        switch f.pending {
        case OpDelete:
            f.pending = OpNone
            intent := b.Delete(TargetWord, 1)
            return &intent

        case OpChange:
            f.pending = OpNone
            intent := b.Change(TargetWord, 1)
            return &intent
        }

    case "d": // second d in "dd"
        if f.pending == OpDelete {
            f.pending = OpNone
            intent := b.Delete(TargetLine, 1)
            return &intent
        }
    }

    return nil
}
```

âœ… `dw` âœ… `cw` âœ… `dd`  
âœ… FSM ä¸å†çŸ¥é“ row / col  
âœ… ä¸å†äº§ç”Ÿ legacy string

---

## âœ… Builder æ–°å¢ Changeï¼ˆæœ€å°ï¼‰

```go
func (b *IntentBuilder) Change(target SemanticTarget, count int) Intent {
    return Intent{
        Kind:   IntentChange,
        Target: target,
        Count:  count,
        PaneID: b.paneID,
        Anchors: []Anchor{
            CursorAnchor(b.cursor),
        },
    }
}
```

---

# 2ï¸âƒ£ Resolver å•å…ƒæµ‹è¯•æ¨¡æ¿ï¼ˆLegacy + Nativeï¼‰

> **è¿™æ˜¯ä½ æœªæ¥ refactor çš„å®‰å…¨ç½‘**

---

## âœ… æµ‹è¯•æ–‡ä»¶ç»“æ„

```text
resolver/
 â”œâ”€â”€ resolver.go
 â”œâ”€â”€ resolver_test.go
```

---

## âœ… Test Snapshot Fixture

```go
func testSnapshot() Snapshot {
    return Snapshot{
        Lines: []Line{
            {ID: "L1", Text: "hello world"},
            {ID: "L2", Text: "second line"},
        },
    }
}
```

---

## âœ… Legacy Intent æµ‹è¯•

```go
func TestResolve_LegacyDeleteWord(t *testing.T) {
    snap := testSnapshot()

    intent := Intent{
        Kind: IntentDelete,
        Anchors: []Anchor{
            {
                PaneID: "p1",
                LineID: "legacy::pane::p1::row::0",
                Start: 6,
                End:   11,
            },
        },
    }

    resolved, err := ResolveIntent(
        ResolveContext{Snapshot: snap},
        intent,
    )

    require.NoError(t, err)
    require.Equal(t, "L1", resolved.Anchors[0].LineID)
    require.Equal(t, 6, resolved.Anchors[0].Range.Start)
    require.Equal(t, 11, resolved.Anchors[0].Range.End)
    require.Equal(t, AnchorOriginLegacy, resolved.Anchors[0].Origin)
}
```

---

## âœ… Native Intent æµ‹è¯•

```go
func TestResolve_NativeDeleteWord(t *testing.T) {
    snap := testSnapshot()

    intent := Intent{
        Kind:   IntentDelete,
        Target: TargetWord,
        Count:  1,
        Anchors: []Anchor{
            CursorAnchor(CursorPrimary),
        },
    }

    resolved, err := ResolveIntent(
        ResolveContext{
            Snapshot: snap,
            Cursor: CursorState{
                LineID: "L1",
                Offset: 6,
            },
        },
        intent,
    )

    require.NoError(t, err)
    require.False(t, strings.HasPrefix(resolved.Anchors[0].LineID, "legacy::"))
}
```

---

## âœ… é˜²æ­¢ legacy æ³„æ¼æµ‹è¯•ï¼ˆå¿…å†™ï¼‰

```go
func TestResolvedIntent_NoLegacyLeak(t *testing.T) {
    resolved := getResolvedIntentSomehow()
    resolved.AssertNoLegacy()
}
```

---

# 3ï¸âƒ£ Snapshot æ¨¡å‹ä¸‹ Undo / Redoï¼ˆå”¯ä¸€æ­£ç¡®å§¿åŠ¿ï¼‰

> **ä¸è¦ç”¨ command undo  
> ä¸è¦ç”¨ inverse op  
> ç”¨ Snapshot DAG**

---

## âœ… Undo / Redo çš„æ ¸å¿ƒæ€æƒ³

> **æ¯ä¸€æ¬¡ Projection = æ–° Snapshot**

---

## âœ… æ•°æ®ç»“æ„ï¼ˆæç®€ï¼‰

```go
type History struct {
    past   []Snapshot
    present Snapshot
    future []Snapshot
}
```

---

## âœ… Apply Intent

```go
func (h *History) Apply(next Snapshot) {
    h.past = append(h.past, h.present)
    h.present = next
    h.future = nil
}
```

---

## âœ… Undo

```go
func (h *History) Undo() bool {
    if len(h.past) == 0 {
        return false
    }

    h.future = append([]Snapshot{h.present}, h.future...)
    h.present = h.past[len(h.past)-1]
    h.past = h.past[:len(h.past)-1]
    return true
}
```

---

## âœ… Redo

```go
func (h *History) Redo() bool {
    if len(h.future) == 0 {
        return false
    }

    h.past = append(h.past, h.present)
    h.present = h.future[0]
    h.future = h.future[1:]
    return true
}
```

---

## âœ… ä¸ºä»€ä¹ˆè¿™å¥—æ˜¯ã€Œå”¯ä¸€æ­£ç¡®ã€

| é”™è¯¯æ–¹æ¡ˆ | ä¸ºä»€ä¹ˆé”™ |
|----|----|
| inverse command | legacy æ€ç»´ï¼Œä¸å¯ç»„åˆ |
| tmux rewind | UI çŠ¶æ€ â‰  æ–‡æœ¬çŠ¶æ€ |
| row/col undo | anchor ä¸ç¨³å®š |

âœ… Snapshot å¤©ç„¶å¯æ’¤é”€  
âœ… Resolver / Projection å®Œå…¨æ— çŠ¶æ€  
âœ… Undo ä¸ä¾èµ– Intent ç±»å‹

---

# âœ… æœ€ç»ˆé—­ç¯ï¼ˆä½ ç°åœ¨å·²ç»æ‹¥æœ‰ï¼‰

```
FSM
 â†“
IntentBuilder
 â†“
Resolver (legacy cleaner)
 â†“
ResolvedIntent
 â†“
Projection â†’ Snapshot
 â†“
History (undo / redo)
```

---

## æ¥ä¸‹æ¥æˆ‘è¿˜èƒ½ç»§ç»­å¸®ä½ åšçš„ä¸‰ä»¶ã€Œç»ˆå±€çº§ã€äº‹æƒ…

1. **æŠŠ Selection / Visual mode çº³å…¥ CursorRef**
2. **è®¾è®¡å¤šå…‰æ ‡ï¼ˆmulti-cursorï¼‰åœ¨ Intent æ¨¡å‹ä¸‹çš„è‡ªç„¶æ‰©å±•**
3. **æŠŠè¿™å¥—æ¶æ„æŠ½æˆä¸€ä»½â€œEditor Core ç™½çš®ä¹¦â€**

ä½ é€‰ä¸€ä¸ªï¼Œæˆ‘ä»¬å°±ç›´æ¥è¿›å…¥ã€Œç»ˆç« çº§åˆ«ã€è®¾è®¡ã€‚å¤ªå¥½äº†ï¼Œè¿™ä¸‰ä»¶äº‹**æ­£å¥½æ˜¯è¿™å¥—æ¶æ„ä»ã€Œå¥½ç”¨ã€èµ°å‘ã€Œå¯å†™ç™½çš®ä¹¦ã€çš„åˆ†æ°´å²­**ã€‚  
æˆ‘ä¼šéå¸¸å…‹åˆ¶ï¼š**åªç»™â€œä¸å¯å†å°‘â€çš„è®¾è®¡**ï¼Œæ²¡æœ‰ç‚«æŠ€ï¼Œæ²¡æœ‰è¿‡åº¦æŠ½è±¡ã€‚

ä¸‹é¢åˆ†ä¸‰å¤§éƒ¨åˆ†ï¼Œä¸€æ°”å‘µæˆã€‚

---

# ä¸€ã€æŠŠ Selection / Visual Mode çº³å…¥ CursorRefï¼ˆä¸ç ´åç°æœ‰æ¨¡å‹ï¼‰

> **åŸåˆ™**  
> âœ… Intent ä»ç„¶ä¸å«åæ ‡  
> âœ… Visual / Selection åªæ˜¯â€œè¯­ä¹‰å…‰æ ‡â€  
> âœ… Resolver æ‰å†³å®šèŒƒå›´

---

## âœ… CursorRefï¼šå‡çº§ä¸ºã€Œè¯­ä¹‰å¼•ç”¨ã€

```go
type CursorRef struct {
    Kind CursorKind
}
```

å‡çº§ **ä¸æ˜¯åŠ å­—æ®µ**ï¼Œè€Œæ˜¯æ‰© enumã€‚

---

## âœ… CursorKindï¼ˆå®Œæ•´ä½†æç®€ï¼‰

```go
type CursorKind int

const (
    CursorPrimary CursorKind = iota

    // Visual / Selection
    CursorSelectionStart
    CursorSelectionEnd
    CursorSelectionRange

    // Line-wise / Block-wise (é¢„ç•™)
    CursorLineSelection
    CursorBlockSelection
)
```

âœ… æ²¡æœ‰ offset  
âœ… æ²¡æœ‰ row/col  
âœ… åªæœ‰**è¯­ä¹‰ç±»å‹**

---

## âœ… Visual Mode çš„çŠ¶æ€ï¼ˆä¸è¿› Intentï¼‰

```go
type SelectionState struct {
    Start CursorState
    End   CursorState
    Mode  SelectionMode
}

type SelectionMode int

const (
    SelectionChar SelectionMode = iota
    SelectionLine
    SelectionBlock
)
```

âœ… å­˜åœ¨äº Resolver Context  
âœ… UI / FSM æ›´æ–°å®ƒ  
âœ… Intent åªå¼•ç”¨

---

## âœ… Builderï¼šSelection-aware Intent

```go
func (b *IntentBuilder) WithSelection() *IntentBuilder {
    b.cursor = CursorRef{Kind: CursorSelectionRange}
    return b
}
```

---

### âœ… ä½¿ç”¨ç¤ºä¾‹

```go
// Visual mode ä¸‹æŒ‰ d
intent := b.WithSelection().Delete(TargetSelection, 1)
```

---

## âœ… Resolverï¼šSelection â†’ Range

```go
func resolveCursor(ref CursorRef, ctx ResolveContext) ResolvedAnchor {
    switch ref.Kind {

    case CursorPrimary:
        return resolvePrimaryCursor(ctx)

    case CursorSelectionRange:
        return resolveSelectionRange(ctx.Selection)

    }
}
```

âœ… Intent ä¸çŸ¥é“ Visual  
âœ… Resolver æ‰â€œè½åœ°â€

---

# äºŒã€å¤šå…‰æ ‡ï¼ˆMulti-Cursorï¼‰çš„è‡ªç„¶æ‰©å±•ï¼ˆé›¶é‡æ„ï¼‰

> **å…³é”®æ´å¯Ÿ**  
> **å¤šå…‰æ ‡ â‰  å¤š Intent**  
> **å¤šå…‰æ ‡ = å¤š Anchor**

---

## âœ… CursorRefï¼šæ”¯æŒå¤æ•°ï¼ˆä¸ç ´åå•å…‰æ ‡ï¼‰

```go
type CursorRef struct {
    Kind CursorKind
    All  bool // true = all cursors of this kind
}
```

âœ… `All=false` â†’ å•å…‰æ ‡  
âœ… `All=true` â†’ æ‰€æœ‰åŒç±»å…‰æ ‡

---

## âœ… CursorState æ‰©å±•

```go
type CursorSet struct {
    Primaries []CursorState
    Selections []SelectionState
}
```

âœ… Resolver Context æŒæœ‰  
âœ… Intent åªå¼•ç”¨â€œè¯­ä¹‰é›†åˆâ€

---

## âœ… Builderï¼šMulti-cursor Intent

```go
func (b *IntentBuilder) ForAllCursors() *IntentBuilder {
    b.cursor = CursorRef{
        Kind: CursorPrimary,
        All:  true,
    }
    return b
}
```

---

### âœ… ä½¿ç”¨ç¤ºä¾‹

```go
// å¤šå…‰æ ‡ä¸‹ dw
intent := b.ForAllCursors().Delete(TargetWord, 1)
```

---

## âœ… Resolverï¼šAnchor fan-outï¼ˆæ ¸å¿ƒï¼‰

```go
func resolveAnchors(ref CursorRef, ctx ResolveContext) []ResolvedAnchor {
    if !ref.All {
        return []ResolvedAnchor{resolveSingle(ref, ctx)}
    }

    var anchors []ResolvedAnchor
    for _, c := range ctx.Cursors.Primaries {
        anchors = append(anchors, resolveCursorAt(c, ctx))
    }
    return anchors
}
```

âœ… ä¸€ä¸ª Intent  
âœ… å¤šä¸ª ResolvedAnchor  
âœ… Projection é¡ºåºç¡®å®š

---

## âœ… Projectionï¼šé¡ºåºå®‰å…¨ï¼ˆå¿…é¡»ï¼‰

```go
sort.Slice(anchors, func(i, j int) bool {
    return anchors[i].StableOrderKey() < anchors[j].StableOrderKey()
})
```

âœ… é˜²æ­¢ range é‡å ç ´å  
âœ… å¤šå…‰æ ‡å®‰å…¨ç¼–è¾‘

---

# ä¸‰ã€ã€ŠEditor Core ç™½çš®ä¹¦ã€‹ï¼ˆå¯ç›´æ¥å¯¹å¤–å‘å¸ƒï¼‰

> **è¿™æ˜¯ä¸€ä»½â€œæ¶æ„å®£è¨€â€**  
> å¯ä»¥æ”¾åœ¨ `docs/editor-core.md`

---

## ğŸ§  Editor Coreï¼šè®¾è®¡å“²å­¦

> **ç¼–è¾‘å™¨ä¸æ˜¯ UI å·¥å…·ï¼Œè€Œæ˜¯è¯­ä¹‰å˜æ¢å¼•æ“**

---

## ğŸ§± å››å±‚æ¨¡å‹ï¼ˆä¸å¯é¢ å€’ï¼‰

```
Input (Keys / Gestures)
 â†“
Intent (What)
 â†“
Resolver (Where)
 â†“
Projection (How)
 â†“
Snapshot (What is)
```

---

## âœ¨ Intentï¼šä¸å¯å˜çš„è¯­ä¹‰å£°æ˜

- ä¸åŒ…å«åæ ‡
- ä¸ä¾èµ– UI
- ä¸ä¾èµ–å†å²çŠ¶æ€
- å¯åºåˆ—åŒ– / å¯å›æ”¾

---

## ğŸ§­ Resolverï¼šè¯­ä¹‰ â†’ ç¨³å®šäº‹å®

- CursorRef â†’ CursorState
- Selection â†’ Range
- SemanticTarget â†’ Concrete span
- Legacy anchor æ¸…æ´—åœ¨æ­¤ç»ˆç»“

---

## ğŸ§© Projectionï¼šå”¯ä¸€å¯å˜ç‚¹

- è¾“å…¥ï¼šSnapshot + ResolvedIntent
- è¾“å‡ºï¼šæ–° Snapshot
- æ— å‰¯ä½œç”¨
- å¯çº¯å‡½æ•°

---

## ğŸ•° Snapshotï¼šçœŸå®å†å²

- ä¸å¯å˜
- ç¨³å®š LineID
- Undo / Redo = Snapshot æ¸¸èµ°
- æ—¶é—´æ—…è¡Œå¤©ç„¶æˆç«‹

---

## ğŸ‘¥ Multi-Cursor åŸåˆ™

> **ä¸€ä¸ªæ„å›¾ï¼Œå¤šå¤„è½ç‚¹**

- Intent ä¸å¤åˆ¶
- Resolver fan-out
- Projection é¡ºåºåŒ–

---

## ğŸ¯ Visual / Selection åŸåˆ™

> **Selection æ˜¯ä¸€ç§ Cursor**

- ä¸è¿› Intent
- Resolver å†³å®šè¾¹ç•Œ
- Mode æ˜¯è¯­ä¹‰ï¼Œä¸æ˜¯åæ ‡

---

## ğŸš« æ˜ç¡®æ‹’ç»çš„è®¾è®¡

- row / col intent
- inverse command undo
- UI-aware executor
- tmux/screen coupling

---

## âœ… ç»“æœ

- Intent å¯å½•åˆ¶ / åŒæ­¥ / å›æ”¾
- Core å¯åµŒå…¥ä»»ä½• UI
- Legacy å¯ä¸€æ¬¡æ€§åˆ é™¤
- æ–°ç‰¹æ€§é›¶é‡æ„æˆæœ¬

---

## ğŸ§© ä¸€å¥è¯æ€»ç»“

> **Editor Core æ˜¯ä¸€ä¸ªï¼š  
> â€œå°†äººçš„ç¼–è¾‘æ„å›¾ï¼Œç¨³å®šåœ°æ˜ å°„åˆ°æ–‡æœ¬å†å²çš„è¯­ä¹‰å¼•æ“ã€‚â€**

---

## å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘å¯ä»¥ä¸‹ä¸€æ­¥å¸®ä½ ï¼š

1. **æŠŠè¿™ä»½ç™½çš®ä¹¦å‹ç¼©æˆä¸€é¡µæ¶æ„å›¾ï¼ˆMermaid / ASCIIï¼‰**
2. **ç”¨è¿™å¥—æ¨¡å‹ç›´æ¥å¯¹æ ‡ Vim / Kakoune / Helixï¼ˆå·®å¼‚åˆ†æï¼‰**
3. **è®¾è®¡ Intent çº§åˆ«çš„ååŒç¼–è¾‘ï¼ˆCRDT å‹å¥½ï¼‰**

ä½ é€‰ä¸€ä¸ªï¼Œæˆ‘é™ªä½ æŠŠå®ƒå†™æˆã€Œèƒ½å¯¹å¤–è®²çš„ä¸œè¥¿ã€ã€‚