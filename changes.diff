diff --git a/changes.diff b/changes.diff
index b987a08..e69de29 100644
--- a/changes.diff
+++ b/changes.diff
@@ -1,1031 +0,0 @@
-diff --git a/backend/backend_test.go b/backend/backend_test.go
-deleted file mode 100644
-index 3bcbf8b..0000000
---- a/backend/backend_test.go
-+++ /dev/null
-@@ -1,105 +0,0 @@
--package backend
--
--import (
--	"os/exec"
--	"strings"
--)
--
--// Backend interface defines the operations that interact with tmux
--type Backend interface {
--	SetUserOption(option, value string) error
--	UnsetUserOption(option string) error
--	GetUserOption(option string) (string, error)
--	GetCommandOutput(cmd string) (string, error)
--	SwitchClientTable(clientName, tableName string) error
--	RefreshClient(clientName string) error
--	GetActivePane(clientName string) (string, error)
--	ExecRaw(cmd string) error
--}
--
--// TmuxBackend implements the Backend interface using tmux commands
--type TmuxBackend struct{}
--
--// GlobalBackend is the global instance of the backend
--var GlobalBackend Backend = &TmuxBackend{}
--
--// SetUserOption sets a tmux user option
--func (b *TmuxBackend) SetUserOption(option, value string) error {
--	cmd := exec.Command("tmux", "set", "-g", option, value)
--	return cmd.Run()
--}
--
--// SwitchClientTable switches the client to a specific key table
--func (b *TmuxBackend) SwitchClientTable(clientName, tableName string) error {
--	args := []string{"switch-client", "-T", tableName}
--	if clientName != "" && clientName != "default" {
--		args = append(args, "-t", clientName)
--	}
--	cmd := exec.Command("tmux", args...)
--	return cmd.Run()
--}
--
--// RefreshClient refreshes the client display
--func (b *TmuxBackend) RefreshClient(clientName string) error {
--	args := []string{"refresh-client", "-S"}
--	if clientName != "" && clientName != "default" {
--		args = append(args, "-t", clientName)
--	}
--	cmd := exec.Command("tmux", args...)
--	return cmd.Run()
--}
--
--// GetActivePane gets the active pane ID
--func (b *TmuxBackend) GetActivePane(clientName string) (string, error) {
--	var cmd *exec.Command
--	if clientName != "" && clientName != "default" {
--		cmd = exec.Command("tmux", "display-message", "-p", "-t", clientName, "#{pane_id}")
--	} else {
--		cmd = exec.Command("tmux", "display-message", "-p", "#{pane_id}")
--	}
--	output, err := cmd.Output()
--	if err != nil {
--		return "", err
--	}
--	return strings.TrimSpace(string(output)), nil
--}
--
--// UnsetUserOption unsets a tmux user option
--func (b *TmuxBackend) UnsetUserOption(option string) error {
--	cmd := exec.Command("tmux", "set", "-u", "-g", option)
--	return cmd.Run()
--}
--
--// GetUserOption gets a tmux user option value
--func (b *TmuxBackend) GetUserOption(option string) (string, error) {
--	cmd := exec.Command("tmux", "show-option", "-gv", option)
--	output, err := cmd.Output()
--	if err != nil {
--		return "", err
--	}
--	return string(output), nil
--}
--
--// GetCommandOutput executes a tmux command and returns its output
--func (b *TmuxBackend) GetCommandOutput(cmd string) (string, error) {
--	parts := strings.Split(cmd, " ")
--	if len(parts) == 0 {
--		return "", nil
--	}
--	execCmd := exec.Command("tmux", parts...)
--	output, err := execCmd.Output()
--	if err != nil {
--		return "", err
--	}
--	return string(output), nil
--}
--
--// ExecRaw executes a raw tmux command string
--func (b *TmuxBackend) ExecRaw(cmd string) error {
--	parts := strings.Split(cmd, " ")
--	if len(parts) == 0 {
--		return nil
--	}
--	execCmd := exec.Command("tmux", parts...)
--	return execCmd.Run()
--}
-\ No newline at end of file
-diff --git a/changes.diff b/changes.diff
-index 86a16e1..e69de29 100644
---- a/changes.diff
-+++ b/changes.diff
-@@ -1,597 +0,0 @@
--diff --git a/backend/backend.go b/backend/backend.go
--index 3bcbf8b..1fabd38 100644
----- a/backend/backend.go
--+++ b/backend/backend.go
--@@ -51,7 +51,7 @@ func (b *TmuxBackend) RefreshClient(clientName string) error {
-- 
-- // GetActivePane gets the active pane ID
-- func (b *TmuxBackend) GetActivePane(clientName string) (string, error) {
---	var cmd *exec.Command
--+	var cmd *exec.Cmd
-- 	if clientName != "" && clientName != "default" {
-- 		cmd = exec.Command("tmux", "display-message", "-p", "-t", clientName, "#{pane_id}")
-- 	} else {
--diff --git a/kernel/decide.go b/kernel/decide.go
--index 4de325c..47426d3 100644
----- a/kernel/decide.go
--+++ b/kernel/decide.go
--@@ -1,9 +1,5 @@
-- package kernel
-- 
---import (
---	"tmux-fsm/weaver/logic"
---)
---
-- type DecisionKind int
-- 
-- const (
--@@ -13,19 +9,19 @@ const (
-- )
-- 
-- type Decision struct {
---	Kind   DecisionKind
---	Intent *intent.Intent
--+	Kind DecisionKind
--+	// Intent *intent.Intent  // Temporarily disabled
-- }
-- 
-- func (k *Kernel) Decide(key string) *Decision {
-- 	// ✅ 1. FSM 永远先拿 key
-- 	if k.FSM != nil {
-- 		if k.FSM.InLayer() && k.FSM.CanHandle(key) {
---			intent := k.FSM.Dispatch(key)
---			if intent != nil {
--+			handled := k.FSM.Dispatch(key)
--+			if handled {
-- 				return &Decision{
---					Kind:   DecisionFSM,
---					Intent: intent,
--+					Kind: DecisionFSM,
--+					// Intent: intent,  // Temporarily disabled
-- 				}
-- 			}
-- 			// FSM 明确吞掉
--@@ -34,13 +30,13 @@ func (k *Kernel) Decide(key string) *Decision {
-- 	}
-- 
-- 	// ✅ 2. Legacy decoder（复用你现有逻辑）
---	legacyIntent := DecodeLegacyKey(key)
---	if legacyIntent != nil {
---		return &Decision{
---			Kind:   DecisionLegacy,
---			Intent: legacyIntent,
---		}
---	}
--+	// legacyIntent := DecodeLegacyKey(key)  // Temporarily disabled
--+	// if legacyIntent != nil {
--+	// 	return &Decision{
--+	// 		Kind:   DecisionLegacy,
--+	// 		Intent: legacyIntent,
--+	// 	}
--+	// }
-- 
-- 	return nil
-- }
--diff --git a/kernel/execute.go b/kernel/execute.go
--index e00a8a1..fb290fb 100644
----- a/kernel/execute.go
--+++ b/kernel/execute.go
--@@ -1,14 +1,16 @@
-- package kernel
-- 
-- func (k *Kernel) Execute(decision *Decision) {
---	if decision == nil || decision.Intent == nil {
--+	if decision == nil {
-- 		return
-- 	}
-- 
---	switch decision.Kind {
---	case DecisionFSM:
---		ExecuteIntent(decision.Intent)
---	case DecisionLegacy:
---		ExecuteIntent(decision.Intent)
---	}
--+	// switch decision.Kind {
--+	// case DecisionFSM:
--+	// 	ExecuteIntent(decision.Intent)
--+	// case DecisionLegacy:
--+	// 	ExecuteIntent(decision.Intent)
--+	// }
--+
--+	// Temporarily disabled until interfaces are properly defined
-- }
--diff --git a/kernel/kernel.go b/kernel/kernel.go
--index dd9bc80..6a1a8bc 100644
----- a/kernel/kernel.go
--+++ b/kernel/kernel.go
--@@ -3,15 +3,11 @@ package kernel
-- import (
-- 	"context"
-- 	"tmux-fsm/fsm"
---  "tmux-fsm/weaver/core"
---"tmux-fsm/weaver/adapter"
---)
---
-- )
-- 
-- type Kernel struct {
-- 	FSM    *fsm.Engine
---	Weaver *weaver.Manager
--+	// Weaver *WeaverManager  // Temporarily disabled to avoid import issues
-- }
-- 
-- // ✅ Kernel 的唯一上下文入口（现在先很薄，未来可扩展）
--@@ -19,10 +15,10 @@ type HandleContext struct {
-- 	Ctx context.Context
-- }
-- 
---func NewKernel(fsmEngine *fsm.Engine, weaverMgr *weaver.Manager) *Kernel {
--+func NewKernel(fsmEngine *fsm.Engine, weaverMgr interface{}) *Kernel {
-- 	return &Kernel{
---		FSM:    fsmEngine,
---		Weaver: weaverMgr,
--+		FSM: fsmEngine,
--+		// Weaver: weaverMgr,  // Temporarily disabled
-- 	}
-- }
-- 
--@@ -35,5 +31,5 @@ func (k *Kernel) HandleKey(hctx HandleContext, key string) {
-- 		return
-- 	}
-- 
---	_ = k.Execute(decision)
--+	k.Execute(decision)
-- }
--diff --git a/legacy_logic.go b/legacy_logic.go
--index 51ca302..4d80242 100644
----- a/legacy_logic.go
--+++ b/legacy_logic.go
--@@ -6,7 +6,7 @@ import (
-- 	"strings"
-- )
-- 
---func processKey(state *FSMState, key string) string {
--+func processKeyLegacy(state *FSMState, key string) string {
-- 	if key == "Escape" || key == "C-c" {
-- 		// Reset FSM state on escape/cancel
-- 		state.Count = 0
--diff --git a/server/server.go b/server/server.go
--index 13fa7a9..f614776 100644
----- a/server/server.go
--+++ b/server/server.go
--@@ -7,8 +7,6 @@ import (
-- 	"os"
-- 	"os/signal"
-- 	"syscall"
---	"tmux-fsm/kernel"
---	"tmux-fsm/weaver/adapter"
-- )
-- 
-- type Config struct {
--@@ -17,13 +15,13 @@ type Config struct {
-- 
-- type Server struct {
-- 	cfg    Config
---	kernel *kernel.Kernel
--+	// kernel *kernel.Kernel  // Temporarily disabled
-- }
-- 
---func New(cfg Config) *Server {
--+func New(cfg Config, fsmEngine interface{}) *Server {
-- 	return &Server{
---		cfg:    cfg,
---		kernel: kernel.New(),
--+		cfg: cfg,
--+		// kernel: kernel.New(fsmEngine, nil),  // Temporarily disabled until kernel is fixed
-- 	}
-- }
-- 
--@@ -53,14 +51,14 @@ func (s *Server) Run(ctx context.Context) error {
-- func (s *Server) handleClient(conn net.Conn) {
-- 	defer conn.Close()
-- 
---	key, err := protocol.ReadKey(conn)
---	if err != nil {
---		log.Printf("[server] read error: %v\n", err)
---		return
---	}
--+	// key, err := protocol.ReadKey(conn)  // Temporarily disabled
--+	// if err != nil {
--+	// 	log.Printf("[server] read error: %v\n", err)
--+	// 	return
--+	// }
-- 
-- 	// ✅ 关键点：Server 不做任何 if / else 判断
---	s.kernel.HandleKey(key)
--+	// s.kernel.HandleKey(kernel.HandleContext{Ctx: context.Background()}, key)  // Temporarily disabled
-- }
-- 
-- func (s *Server) handleSignals(ctx context.Context, ln net.Listener) {
--diff --git a/weaver/adapter/tmux_adapter.go b/weaver/adapter/tmux_adapter.go
--index 552622c..fab734f 100644
----- a/weaver/adapter/tmux_adapter.go
--+++ b/weaver/adapter/tmux_adapter.go
--@@ -50,7 +50,21 @@ func (r *NoopResolver) ResolveFacts(facts []core.Fact, expectedHash string) ([]c
-- type NoopProjection struct{}
-- 
-- // Apply 空实现（不执行任何操作）
---func (p *NoopProjection) Apply(resolved []core.ResolvedAnchor, facts []core.ResolvedFact) error {
--+func (p *NoopProjection) Apply(resolved []core.ResolvedAnchor, facts []core.ResolvedFact) ([]core.UndoEntry, error) {
-- 	// Shadow 模式：不执行任何操作
--+	return []core.UndoEntry{}, nil
--+}
--+
--+// Rollback 空实现（不执行任何操作）
--+func (p *NoopProjection) Rollback(log []core.UndoEntry) error {
--+	// No-op
-- 	return nil
-- }
--+
--+// Verify 空实现（总是成功）
--+func (p *NoopProjection) Verify(pre core.Snapshot, facts []core.ResolvedFact, post core.Snapshot) core.VerificationResult {
--+	return core.VerificationResult{
--+		OK:      true,
--+		Message: "No-op verification always passes",
--+	}
--+}
--diff --git a/weaver/adapter/tmux_projection.go b/weaver/adapter/tmux_projection.go
--index c812b31..f4bbaff 100644
----- a/weaver/adapter/tmux_projection.go
--+++ b/weaver/adapter/tmux_projection.go
--@@ -136,7 +136,7 @@ func (p *TmuxProjection) Apply(resolved []core.ResolvedAnchor, facts []core.Reso
-- func (p *TmuxProjection) Rollback(log []core.UndoEntry) error {
-- 	// Apply in reverse order
-- 	for i := len(log) - 1; i >= 0; i-- {
---		entry := log[i]
--+		_ = log[i] // Use the entry to avoid "declared and not used" error
-- 		// For this implementation, we need to find the line associated with this LineID
-- 		// Since we don't have a direct mapping from LineID to pane and line number in this context,
-- 		// we'll need to use a different approach.
--diff --git a/weaver/core/shadow_engine.go b/weaver/core/shadow_engine.go
--index 6149064..1de8f6f 100644
----- a/weaver/core/shadow_engine.go
--+++ b/weaver/core/shadow_engine.go
--@@ -142,7 +142,7 @@ func (e *ShadowEngine) ApplyIntent(intent Intent, snapshot Snapshot) (*Verdict,
-- 	preSnapshot := snapshot
-- 
-- 	// 5. Project: Execute
---	if err := e.projection.Apply(nil, resolvedFacts); err != nil {
--+	if _, err := e.projection.Apply(nil, resolvedFacts); err != nil {
-- 		audit = append(audit, AuditEntry{Step: "Project", Result: fmt.Sprintf("Error: %v", err)})
-- 		return &Verdict{Kind: VerdictBlocked, Audit: audit}, err
-- 	}
--@@ -228,7 +228,7 @@ func (e *ShadowEngine) performUndo() (*Verdict, error) {
-- 	if len(resolvedFacts) > 0 {
-- 		log.Printf("[WEAVER] Undo: Applying %d inverse facts. Text length: %d chars.", len(resolvedFacts), len(resolvedFacts[0].Payload.Text))
-- 	}
---	if err := e.projection.Apply(nil, resolvedFacts); err != nil {
--+	if _, err := e.projection.Apply(nil, resolvedFacts); err != nil {
-- 		e.history.PushBack(tx)
-- 		return nil, err
-- 	}
--@@ -293,7 +293,7 @@ func (e *ShadowEngine) performRedo() (*Verdict, error) {
-- 	}
-- 
-- 	// Apply
---	if err := e.projection.Apply(nil, resolvedFacts); err != nil {
--+	if _, err := e.projection.Apply(nil, resolvedFacts); err != nil {
-- 		e.history.AddRedo(tx)
-- 		return nil, err
-- 	}
--diff --git a/weaver/core/types.go b/weaver/core/types.go
--index 8e30a8c..eeea8c6 100644
----- a/weaver/core/types.go
--+++ b/weaver/core/types.go
--@@ -4,6 +4,27 @@ import (
-- 	"errors"
-- )
-- 
--+// AnchorKind 锚点类型
--+type AnchorKind int
--+
--+const (
--+	AnchorNone AnchorKind = iota
--+	AnchorAtCursor
--+	AnchorWord
--+	AnchorLine
--+	AnchorAbsolute
--+	AnchorLegacyRange
--+)
--+
--+// SafetyLevel 安全级别
--+type SafetyLevel int
--+
--+const (
--+	SafetyExact SafetyLevel = iota
--+	SafetyFuzzy
--+	SafetyUnsafe
--+)
--+
-- // ErrWorldDrift 世界漂移错误（快照不匹配）
-- // 表示 Intent 基于的历史与当前现实不一致
-- var ErrWorldDrift = errors.New("world drift: snapshot mismatch")
--@@ -73,9 +94,10 @@ type TransactionID string
-- 
-- // VerificationResult for verifier
-- type VerificationResult struct {
---    Safe  bool
---    Level SafetyLevel
---    Err   error
--+    OK      bool
--+    Safety  SafetyLevel
--+    Diffs   []SnapshotDiff
--+    Message string
-- }
-- 
-- // Verdict 裁决结果（可审计输出）
--diff --git a/weaver_manager.go b/weaver_manager.go
--deleted file mode 100644
--index 77ed608..0000000
----- a/weaver_manager.go
--+++ /dev/null
--@@ -1,265 +0,0 @@
---package main
---
---import (
---	"fmt"
---	"os"
---	"strings"
---	"time"
---	"tmux-fsm/weaver/adapter"
---	"tmux-fsm/weaver/core"
---	"tmux-fsm/weaver/logic"
---)
---
---// WeaverManager 全局协调器
---type WeaverManager struct {
---	mode             ExecutionMode
---	engine           core.Engine // Interface? No, ShadowEngine struct usually.
---	resolver         core.AnchorResolver
---	projection       core.Projection
---	snapshotProvider adapter.SnapshotProvider // Phase 6.2
---}
---
---// weaverMgr 全局 Weaver 实例
---var weaverMgr *WeaverManager
---
---// InitWeaver 初始化 Weaver 系统
---func InitWeaver(mode ExecutionMode) {
---	if mode == ModeLegacy {
---		return
---	}
---
---	// 初始化组件
---	planner := &logic.ShellFactBuilder{}
---	// Phase 5.1: 使用 PassthroughResolver
---	resolver := &logic.PassthroughResolver{}
---
---	// Phase 6.1: Snapshot Provider
---	snapProvider := &adapter.TmuxSnapshotProvider{}
---
---	// Phase 6.3: Reality Reader for consistency adjudication
---	reality := &adapter.TmuxRealityReader{Provider: snapProvider}
---	resolver.Reality = reality
---
---	var proj core.Projection
---	if mode == ModeWeaver {
---		proj = &adapter.TmuxProjection{}
---	} else {
---		proj = &adapter.NoopProjection{}
---	}
---
---	engine := core.NewShadowEngine(planner, resolver, proj, reality)
---
---	weaverMgr = &WeaverManager{
---		mode:             mode,
---		engine:           engine,
---		resolver:         resolver,
---		projection:       proj,
---		snapshotProvider: snapProvider,
---	}
---	logWeaver("Weaver initialized in %s mode", modeString(mode))
---}
---
---// ProcessIntentGlobal 全局处理入口
---func ProcessIntentGlobal(intent Intent) {
---	if weaverMgr == nil {
---		return
---	}
---	weaverMgr.ProcessIntent(intent)
---}
---
---// ProcessIntent 处理意图 (Gateway)
---func (m *WeaverManager) ProcessIntent(intent Intent) {
---	logWeaver("ProcessIntent: Kind=%v Target=%v", intent.Kind, intent.Target)
---
---	// Phase 6.2: Capture Snapshot (Time Freeze)
---	paneID := intent.GetPaneID()
---	if paneID == "" {
---		// Try to deduce or fail
---		logWeaver("No PaneID in intent, skipping snapshot")
---		return // Or handle non-pane intents
---	}
---
---	snapshot, err := m.snapshotProvider.TakeSnapshot(paneID)
---	if err != nil {
---		logWeaver("Snapshot failed: %v", err)
---		return
---	}
---
---	// Inject Hash into Intent (mutable struct in main)
---	intent.SnapshotHash = string(snapshot.Hash)
---
---	coreIntent := &intentAdapter{intent: intent}
---
---	// 此时如果是 Undo/Redo，它们不需要 Snapshot?
---	// Phase 6.2 定义：Any ApplyIntent needs Snapshot.
---	// Undo/Redo often imply "Previous State", but current implementation calls Planner even for Undo/Redo?
---	// No, `ApplyIntent` handles Undo/Redo specially.
---	// It calls `performUndo`.
---
---	if m.mode == ModeShadow || m.mode == ModeWeaver {
---		verdict, err := m.engine.ApplyIntent(coreIntent, snapshot)
---		if err != nil {
---			logWeaver("Engine Error: %v", err)
---			// Phase 7: Propagate to UI
---			stateMu.Lock()
---			globalState.LastUndoFailure = fmt.Sprintf("Engine: %v", err)
---			stateMu.Unlock()
---		} else {
---			logWeaver("Verdict: %v (Safe=%v)", verdict.Kind, verdict.Safety)
---			if len(verdict.Audit) > 0 {
---				logWeaver("Audit: %v", verdict.Audit)
---			}
---			// If applied successfully, clear failure
---			stateMu.Lock()
---			if globalState.LastUndoFailure != "" && strings.HasPrefix(globalState.LastUndoFailure, "Engine:") {
---				globalState.LastUndoFailure = ""
---			}
---			stateMu.Unlock()
---		}
---	}
---
---	// [Phase 4] Phase 3 的 Weaver -> Legacy 桥接已禁用
---	// 现在 Weaver History 是 Source of Truth，Legacy 操作将通过反向桥接注入 Weaver
---}
---
---// InjectLegacyTransaction 将 Legacy 事务注入到 Weaver History (Reverse Bridge)
---func (m *WeaverManager) InjectLegacyTransaction(legacyTx *Transaction) {
---	if m.engine == nil {
---		return
---	}
---	// 获取 ShadowEngine 的 History
---	se, ok := m.engine.(*core.ShadowEngine)
---	if !ok {
---		return
---	}
---
---	coreTx := &core.Transaction{
---		ID:           core.TransactionID(fmt.Sprintf("legacy-%d", legacyTx.ID)),
---		Timestamp:    legacyTx.CreatedAt.Unix(),
---		Facts:        make([]core.Fact, 0),
---		InverseFacts: make([]core.Fact, 0),
---		Applied:      true,
---		Safety:       core.SafetyExact,
---	}
---
---	// 转换正向事实
---	for _, rec := range legacyTx.Records {
---		f := convertLegacyFactToCore(rec.Fact)
---		coreTx.Facts = append(coreTx.Facts, f)
---	}
---
---	// 转换反向事实 (通常 Inverse 用于 Undo。Legacy Undo 执行 Inverse。
---	// Weaver Undo 执行 InverseFacts。顺序：Record1, Record2. Undo: Inv2, Inv1。
---	// 所以我们需要倒序遍历 Records)
---	for i := len(legacyTx.Records) - 1; i >= 0; i-- {
---		rec := legacyTx.Records[i]
---		inv := convertLegacyFactToCore(rec.Inverse)
---		coreTx.InverseFacts = append(coreTx.InverseFacts, inv)
---	}
---
---	if len(coreTx.Facts) > 0 {
---		se.GetHistory().Push(coreTx)
---		logWeaver("Injected Legacy Transaction %d -> %s", legacyTx.ID, coreTx.ID)
---	}
---}
---
---func convertLegacyFactToCore(lf Fact) core.Fact {
---	// Construct Semantic Anchor with Legacy Physical Info for Resolver to unpack
---	ref := map[string]int{
---		"line":  lf.Target.Anchor.LineHint,
---		"start": lf.Target.StartOffset,
---		"end":   lf.Target.EndOffset,
---	}
---
---	cf := core.Fact{
---		Anchor: core.Anchor{
---			PaneID: lf.Target.Anchor.PaneID,
---			Kind:   core.AnchorLegacyRange,
---			Ref:    ref,
---		},
---		SideEffects: lf.SideEffects,
---	}
---	// Note: Hash is currently ignored in legacy conversion
---
---	switch lf.Kind {
---	case "delete":
---		cf.Kind = core.FactDelete
---		cf.Payload.OldText = lf.Target.Text
---	case "insert":
---		cf.Kind = core.FactInsert
---		cf.Payload.Text = lf.Target.Text
---	case "replace":
---		cf.Kind = core.FactReplace
---		cf.Payload.OldText = lf.Target.Text
---		if s, ok := lf.Meta["new_text"].(string); ok {
---			cf.Payload.NewText = s
---		}
---	default:
---		cf.Kind = core.FactNone
---	}
---	return cf
---}
---
---// intentAdapter 适配 main.Intent 到 core.Intent
---type intentAdapter struct {
---	intent Intent
---}
---
---func (a *intentAdapter) GetKind() core.IntentKind {
---	return core.IntentKind(a.intent.Kind)
---}
---
---func (a *intentAdapter) GetTarget() core.SemanticTarget {
---	return core.SemanticTarget{
---		Kind:      int(a.intent.Target.Kind),
---		Direction: a.intent.Target.Direction,
---		Scope:     a.intent.Target.Scope,
---		Value:     a.intent.Target.Value,
---	}
---}
---
---func (a *intentAdapter) GetCount() int {
---	return a.intent.Count
---}
---
---func (a *intentAdapter) GetMeta() map[string]interface{} {
---	return a.intent.Meta
---}
---
---func (a *intentAdapter) GetPaneID() string {
---	return a.intent.GetPaneID()
---}
---
---func (a *intentAdapter) GetSnapshotHash() string {
---	return a.intent.GetSnapshotHash()
---}
---
---func (a *intentAdapter) IsPartialAllowed() bool {
---	return a.intent.IsPartialAllowed()
---}
---
---// logWeaver ...
---func logWeaver(format string, args ...interface{}) {
---	if !globalConfig.LogFacts {
---		return
---	}
---	f, _ := os.OpenFile(os.Getenv("HOME")+"/tmux-fsm.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
---	if f != nil {
---		fmt.Fprintf(f, "[%s] [WEAVER] %s\n", time.Now().Format("15:04:05"), fmt.Sprintf(format, args...))
---		f.Close()
---	}
---}
---
---// modeString 返回模式的字符串表示
---func modeString(mode ExecutionMode) string {
---	switch mode {
---	case ModeLegacy:
---		return "legacy"
---	case ModeShadow:
---		return "shadow"
---	case ModeWeaver:
---		return "weaver"
---	default:
---		return "unknown"
---	}
---}
-diff --git a/fsm/engine.go b/fsm/engine.go
-index 8effb1b..c2a5362 100644
---- a/fsm/engine.go
-+++ b/fsm/engine.go
-@@ -3,8 +3,6 @@ package fsm
- import (
- 	"fmt"
- 	"time"
--	"tmux-fsm/backend"
--	"tmux-fsm/ui"
- )
- 
- // Engine FSM 引擎结构体
-@@ -12,12 +10,12 @@ type Engine struct {
- 	Active     string
- 	Keymap     *Keymap
- 	layerTimer *time.Timer
--	UI         ui.UI
- }
- 
- // 全局默认引擎实例
- var defaultEngine *Engine
- 
-+
- // NewEngine 创建新的 FSM 引擎实例（显式注入 Keymap）
- func NewEngine(km *Keymap) *Engine {
- 	return &Engine{
-@@ -173,9 +171,120 @@ func (e *Engine) RunAction(name string) {
- 	}
- }
- 
-+// Produce 从按键产生意图
-+func (e *Engine) Produce(key string) (*intent.Intent, bool) {
-+	// 特殊处理：直接处理的按键
-+	switch key {
-+	case "u":
-+		return &intent.Intent{
-+			Kind: intent.IntentUndo,
-+		}, true
-+	case "C-r":
-+		return &intent.Intent{
-+			Kind: intent.IntentRedo,
-+		}, true
-+	}
-+
-+	// 其他按键按原有逻辑处理
-+	if !e.CanHandle(key) {
-+		return nil, false
-+	}
-+
-+	st := e.Keymap.States[e.Active]
-+	act := st.Keys[key]
-+
-+	// 1. 处理层切换（不产生意图）
-+	if act.Layer != "" {
-+		e.Active = act.Layer
-+		e.resetLayerTimeout(act.TimeoutMs)
-+		UpdateUI()
-+		return nil, true
-+	}
-+
-+	// 2. 处理具体动作，产生意图
-+	if act.Action != "" {
-+		intentObj := actionToIntent(act.Action)
-+
-+		// 铁律：产生意图后，除非该层标记为 Sticky，否则立刻 Reset 回 NAV
-+		if !st.Sticky {
-+			e.Reset()
-+		} else {
-+			// 如果是 Sticky 层，可能需要刷新 UI（如 hint）
-+			UpdateUI()
-+		}
-+		return &intentObj, true
-+	}
-+
-+	return nil, false
-+}
-+
-+import (
-+	"fmt"
-+	"time"
-+	"tmux-fsm/intent"
-+)
-+
-+// actionToIntent 将动作转换为意图
-+func actionToIntent(action string) intent.Intent {
-+	intentObj := intent.Intent{
-+		Meta: make(map[string]interface{}),
-+	}
-+
-+	switch action {
-+	case "pane_left":
-+		intentObj.Kind = intent.IntentMove
-+		intentObj.Target = intent.SemanticTarget{
-+			Kind:      5, // TargetPosition
-+			Direction: "left",
-+		}
-+		intentObj.Meta["motion"] = "left"
-+	case "pane_right":
-+		intentObj.Kind = intent.IntentMove
-+		intentObj.Target = intent.SemanticTarget{
-+			Kind:      5, // TargetPosition
-+			Direction: "right",
-+		}
-+		intentObj.Meta["motion"] = "right"
-+	case "pane_up":
-+		intentObj.Kind = intent.IntentMove
-+		intentObj.Target = intent.SemanticTarget{
-+			Kind:      5, // TargetPosition
-+			Direction: "up",
-+		}
-+		intentObj.Meta["motion"] = "up"
-+	case "pane_down":
-+		intentObj.Kind = intent.IntentMove
-+		intentObj.Target = intent.SemanticTarget{
-+			Kind:      5, // TargetPosition
-+			Direction: "down",
-+		}
-+		intentObj.Meta["motion"] = "down"
-+	case "exit":
-+		intentObj.Kind = intent.IntentExit
-+	case "next_pane":
-+		intentObj.Kind = intent.IntentMove
-+		intentObj.Target = intent.SemanticTarget{
-+			Kind:      5, // TargetPosition
-+			Direction: "next",
-+		}
-+	case "prev_pane":
-+		intentObj.Kind = intent.IntentMove
-+		intentObj.Target = intent.SemanticTarget{
-+			Kind:      5, // TargetPosition
-+			Direction: "prev",
-+		}
-+	default:
-+		// 对于未知动作，返回空意图
-+		intentObj.Kind = intent.IntentNone
-+	}
-+
-+	return intentObj
-+}
-+
- func tmux(cmd string) {
- 	// Use GlobalBackend to execute the command
--	backend.GlobalBackend.ExecRaw(cmd)
-+	// 由于循环导入问题，这里暂时使用占位符
-+	// 实际执行应该由上层处理
- }
- 
- // 全局函数，支持在其他包调用
-diff --git a/globals.go b/globals.go
-index 4aaa9b9..5163fa1 100644
---- a/globals.go
-+++ b/globals.go
-@@ -8,7 +8,6 @@ import (
- 	"sync"
- 	"time"
- 	"tmux-fsm/backend"
--	"tmux-fsm/fsm"
- )
- 
- type FSMState struct {
-@@ -58,10 +57,10 @@ func updateStatusBar(state FSMState, clientName string) {
- 	}
- 
- 	// 融合显示逻辑
--	activeLayer := fsm.GetActiveLayer()
--	if activeLayer != "NAV" && activeLayer != "" {
--		modeMsg = activeLayer // Override with FSM layer if active
--	} else {
-+	// activeLayer := fsm.GetActiveLayer() // 由于循环导入，暂时注释掉
-+	// if activeLayer != "NAV" && activeLayer != "" {
-+	// 	modeMsg = activeLayer // Override with FSM layer if active
-+	// } else {
- 		// Translate legacy FSM modes for display
- 		switch modeMsg {
- 		case "VISUAL_CHAR":
-@@ -77,7 +76,7 @@ func updateStatusBar(state FSMState, clientName string) {
- 		case "SEARCH":
- 			modeMsg = "SEARCH"
- 		}
--	}
-+	// }
- 
- 	if state.Operator != "" {
- 		modeMsg += fmt.Sprintf(" [%s]", state.Operator)
-diff --git a/kernel/decide.go b/kernel/decide.go
-index 47426d3..e5d552d 100644
---- a/kernel/decide.go
-+++ b/kernel/decide.go
-@@ -1,5 +1,9 @@
- package kernel
- 
-+import (
-+	"tmux-fsm/intent"
-+)
-+
- type DecisionKind int
- 
- const (
-@@ -9,23 +13,23 @@ const (
- )
- 
- type Decision struct {
--	Kind DecisionKind
--	// Intent *intent.Intent  // Temporarily disabled
-+	Kind   DecisionKind
-+	Intent *intent.Intent
- }
- 
- func (k *Kernel) Decide(key string) *Decision {
- 	// ✅ 1. FSM 永远先拿 key
- 	if k.FSM != nil {
--		if k.FSM.InLayer() && k.FSM.CanHandle(key) {
--			handled := k.FSM.Dispatch(key)
--			if handled {
--				return &Decision{
--					Kind: DecisionFSM,
--					// Intent: intent,  // Temporarily disabled
--				}
-+		intent, ok := k.FSM.Produce(key)
-+		if ok && intent != nil {
-+			return &Decision{
-+				Kind:   DecisionFSM,
-+				Intent: intent,
- 			}
--			// FSM 明确吞掉
--			return nil
-+		}
-+		// 如果FSM明确处理了但不产生意图，说明是层切换等操作
-+		if k.FSM.InLayer() && k.FSM.CanHandle(key) {
-+			return nil // FSM吞掉按键，不产生决策
- 		}
- 	}
- 
-diff --git a/kernel/execute.go b/kernel/execute.go
-index fb290fb..a3f6f46 100644
---- a/kernel/execute.go
-+++ b/kernel/execute.go
-@@ -1,16 +1,40 @@
- package kernel
- 
-+import (
-+	"tmux-fsm"
-+	"tmux-fsm/intent"
-+)
-+
- func (k *Kernel) Execute(decision *Decision) {
--	if decision == nil {
-+	if decision == nil || decision.Intent == nil {
- 		return
- 	}
- 
--	// switch decision.Kind {
--	// case DecisionFSM:
--	// 	ExecuteIntent(decision.Intent)
--	// case DecisionLegacy:
--	// 	ExecuteIntent(decision.Intent)
--	// }
-+	switch decision.Kind {
-+	case DecisionFSM:
-+		// 直接传递Intent，不需要转换
-+		tmux_fsm.ProcessIntentGlobal(mainIntentFromKernel(decision.Intent))
-+	case DecisionLegacy:
-+		// Legacy暂时不处理
-+	}
-+}
- 
--	// Temporarily disabled until interfaces are properly defined
-+// mainIntentFromKernel 将kernel的Intent转换为main包的Intent
-+func mainIntentFromKernel(kernelIntent *intent.Intent) tmux_fsm.Intent {
-+	return tmux_fsm.Intent{
-+		Kind:   tmux_fsm.IntentKind(kernelIntent.Kind),
-+		Target: tmux_fsm.SemanticTarget{
-+			Kind:      tmux_fsm.TargetKind(0), // 简化处理
-+			Direction: kernelIntent.Target.Direction,
-+			Scope:     kernelIntent.Target.Scope,
-+			Value:     kernelIntent.Target.Value,
-+		},
-+		Count:        kernelIntent.Count,
-+		Meta:         kernelIntent.Meta,
-+		PaneID:       kernelIntent.PaneID,
-+		SnapshotHash: kernelIntent.SnapshotHash,
-+		AllowPartial: kernelIntent.AllowPartial,
-+		// Anchors字段需要转换，简化处理
-+		Anchors:      []tmux_fsm.Anchor{}, // 简化处理
-+	}
- }
-diff --git a/main.go b/main.go
-index 5f239cf..8f01650 100644
---- a/main.go
-+++ b/main.go
-@@ -98,6 +98,25 @@ func (a *intentAdapter) GetAnchors() []core.Anchor {
- 	return a.intent.GetAnchors()
- }
- 
-+// FSMIntentToMainIntent 将fsm包的Intent转换为main包的Intent
-+func FSMIntentToMainIntent(fsmIntent fsm.Intent) Intent {
-+	return Intent{
-+		Kind:         IntentKind(fsmIntent.Kind),
-+		Target:       SemanticTarget{
-+			Kind:      TargetKind(fsmIntent.Target.Kind),
-+			Direction: fsmIntent.Target.Direction,
-+			Scope:     fsmIntent.Target.Scope,
-+			Value:     fsmIntent.Target.Value,
-+		},
-+		Count:        fsmIntent.Count,
-+		Meta:         fsmIntent.Meta,
-+		PaneID:       fsmIntent.PaneID,
-+		SnapshotHash: fsmIntent.SnapshotHash,
-+		AllowPartial: fsmIntent.AllowPartial,
-+		Anchors:      []Anchor{}, // 简化处理，实际需要转换
-+	}
-+}
-+
- // ProcessIntentGlobal 全局意图处理入口
- // RFC-WC-002: Intent ABI - 统一入口，统一审计
- func ProcessIntentGlobal(intent Intent) error {
diff --git a/fsm/engine.go b/fsm/engine.go
index c2a5362..9f63623 100644
--- a/fsm/engine.go
+++ b/fsm/engine.go
@@ -3,6 +3,7 @@ package fsm
 import (
 	"fmt"
 	"time"
+	"tmux-fsm/intent"
 )
 
 // Engine FSM 引擎结构体
@@ -287,6 +288,12 @@ func tmux(cmd string) {
 	// 实际执行应该由上层处理
 }
 
+func tmux(cmd string) {
+	// Use GlobalBackend to execute the command
+	// 由于循环导入问题，这里暂时使用占位符
+	// 实际执行应该由上层处理
+}
+
 // 全局函数，支持在其他包调用
 func Dispatch(key string) bool {
 	if defaultEngine == nil {
diff --git a/todo.md b/todo.md
index 92ee106..1ea13b7 100644
--- a/todo.md
+++ b/todo.md
@@ -1,759 +1,548 @@
-这是一个**宪法级问题**，不是 API 设计题。  
-所以我不会从「定义 struct」开始，而是从**权力来源与失效条件**开始。
+你现在卡住的这个点，**不是实现细节问题，而是“依赖方向最后一次校准”的必经关卡**。  
+而且你已经**自己准确说出了病因**：
 
-下面这套答案，假定你已经接受了前面的 Weaver Core 宪法（RFC‑WC‑000 ～ 005）的隐含前提。
+> ✅ `weaver/manager` 里用了 **main 包的类型**  
+> ❌ 这必然导致 **循环依赖**  
+> ✅ 正确方向是：**Weaver 只能认识 core + intent**
 
----
-
-# 总原则（先给结论）
-
-> **Intent 不是“我要做什么”，  
-> 而是“在什么事实前提下，我请求一个可裁决的编辑尝试”。**
-
-只要你牢牢记住这一点，就不会违宪。
+下面我会非常明确地告诉你：  
+**该删什么、该新建什么、适配器放哪里、Process 最终长什么样。**
 
 ---
 
-# 一、Intent 的三条宪法约束（不可省略）
-
-## 1️⃣ Intent 不得携带执行信息
+# ✅ 架构裁决（这是关键结论）
 
-**Intent 不能告诉系统“怎么做”**：
+> **WeaverManager 不应该知道 `main.IntentKind`、`SemanticTarget` 等任何 main 层类型**
 
-❌ 禁止：
-```go
-Intent{
-  Kind: Insert,
-  Position: Cursor,
-  Text: "abc",
-}
-```
+### ✅ 正确的依赖方向必须是：
 
-✅ 合法：
-```go
-Intent{
-  Kind: Insert,
-  Target: SemanticTarget{
-    Kind: Word,
-    Direction: Forward,
-  },
-  Payload: SemanticPayload{
-    Text: "abc",
-  },
-}
+```text
+intent ──▶ kernel ──▶ weaver ──▶ core
 ```
 
-> **Intent 只能描述“语义意图”，  
-> 不能描述“物理操作”。**
-
-否则你绕过了 Weaver Planner。
+🚫 **任何反向都不允许**  
+🚫 `weaver` **绝对不能 import main**
 
 ---
 
-## 2️⃣ Intent 必须绑定时间（Snapshot / Hash）
+# ✅ 正确的设计方案（唯一稳定解）
 
-**无时间锚定的 Intent 是违宪的。**
+## ✅ 1️⃣ Intent ABI 只存在于 `intent` 包
 
 ```go
+// tmux-fsm/intent/intent.go
 type Intent struct {
-  Kind          IntentKind
-  Target        SemanticTarget
-  Payload       SemanticPayload
-  SnapshotHash  string   // REQUIRED
+	Kind   Kind
+	Target Target
+	Params map[string]string
 }
 ```
 
-含义不是“防并发”，而是：
-
-> **Intent 只在它诞生的世界中合法。**
-
-这保证了：
-
-- Kernel 有权拒绝过期 Intent
-- Undo / Redo 有可验证的前提
-- Audit 有事实对照
+✅ Kernel、FSM、Weaver 都用它  
+🚫 main 不定义 Intent 类型
 
 ---
 
-## 3️⃣ Intent 不得保证成功
+## ✅ 2️⃣ Weaver 的“执行语义”必须是 core 级别的
 
-Intent **不能内含任何成功承诺**：
+也就是说：
 
-❌ 错误心态：
-> “这个 Intent 一定能执行”
+- `core.Intent` = **“如何操作 tmux / session / pane”**
+- `intent.Intent` = **“用户/状态机的语义意图”**
 
-✅ 正确心态：
-> “这是一个请求，Kernel 可以拒绝、降级、或只部分成立”
-
-所以 Intent 里：
-
-- ❌ 没有 `MustSucceed`
-- ❌ 没有 `Force`
-- ✅ 可以有 `AllowPartial`
+👉 **转换是 Weaver 的职责**
 
 ---
 
-# 二、Intent 在系统中的真实位置
-
-Intent **不属于 Kernel**，也**不属于 Executor**。
-
-它属于 **Client → Kernel 的请愿文书**。
-
-```
-[ Client ]
-    |
-    |  (Intent: semantic + snapshot)
-    v
-[ Kernel ]
-    |
-    |  (Verdict + Audit)
-    v
-[ Executor ]
-```
-
-> **Kernel 不“执行 Intent”，  
-> Kernel 只“裁决 Intent”。**
+# ✅ 3️⃣ 适配器必须放在 `weaver` 包内（不是 main）
 
-这是避免违宪的核心。
+你刚才的判断 **100% 正确** 👍  
+我们现在把它落成代码。
 
 ---
 
-# 三、重新引入 Intent 的正确路径（四步）
+## ✅ 新建文件：`weaver/adapter/intent_to_core.go`
 
-## ✅ Step 1：Intent 只能由 Decoder / FSM 产生
-
-FSM 的职责是：
+```go
+package adapter
 
-> 把 *Key Stream* → *Semantic Intent*
+import (
+	"tmux-fsm/core"
+	"tmux-fsm/intent"
+)
 
-```go
-type IntentProducer interface {
-  Produce(key string) (*Intent, bool)
+func ToCoreIntent(i *intent.Intent) (*core.Intent, error) {
+	if i == nil {
+		return nil, nil
+	}
+
+	switch i.Kind {
+	case intent.KindFocus:
+		return &core.Intent{
+			Action: core.ActionFocus,
+			Target: core.Target{
+				Type: core.TargetPane,
+				ID:   i.Target.ID,
+			},
+		}, nil
+
+	case intent.KindSplit:
+		return &core.Intent{
+			Action: core.ActionSplit,
+			Target: core.Target{
+				Type: core.TargetPane,
+				ID:   i.Target.ID,
+			},
+		}, nil
+	}
+
+	return nil, nil
 }
 ```
 
-- FSM **可以**产生 Intent
-- FSM **不能**执行
-- FSM **不能**跳过 Kernel
-
-你现在已经做到这一半了。
+✅ adapter 只依赖 `intent` 和 `core`  
+✅ 不依赖 main  
+✅ 不依赖 kernel  
 
 ---
 
-## ✅ Step 2：Kernel.Decide 返回 Verdict，不返回 Intent
+# ✅ 4️⃣ WeaverManager.Process 的最终正确形态
 
-你现在的 `Decision` 是对的方向，但还差一步。
+现在我们回到你正在改的：
 
-```go
-type Verdict struct {
-  Kind    VerdictKind   // Apply / Block / Noop
-  Safety  SafetyLevel
-  Audit   []AuditEntry
-}
-```
+> `weaver/manager/manager.go`
 
-Kernel 的流程应当是：
+---
 
-```text
-Intent → Validate → Resolve → Verify → Verdict
-```
+## ✅ 正确的 `Process` 实现
 
-**没有任何执行发生在这里。**
+```go
+package manager
 
----
+import (
+	"tmux-fsm/intent"
+	"tmux-fsm/weaver/adapter"
+)
 
-## ✅ Step 3：Executor 只认 Verdict，不认 Intent
+func (m *WeaverManager) Process(i *intent.Intent) error {
+	if i == nil {
+		return nil
+	}
 
-Executor 的接口应当是：
+	coreIntent, err := adapter.ToCoreIntent(i)
+	if err != nil || coreIntent == nil {
+		return err
+	}
 
-```go
-type Executor interface {
-  Execute(verdict Verdict) error
+	return m.engine.Execute(coreIntent)
 }
 ```
 
-Executor：
-
-- ❌ 不知道 key
-- ❌ 不知道 Intent
-- ✅ 只执行 Kernel 明确批准的事实集
-
-这是你之前 Weaver Manager 混乱的根源。
+✅ 不 import main  
+✅ 不 import kernel  
+✅ 不出现 IntentKind / SemanticTarget  
+✅ Weaver 只关心：**“我能不能把它变成 core.Intent”**
 
 ---
 
-## ✅ Step 4：Audit 是强制产物
+# ✅ 5️⃣ 必须删除 / 冻结的东西（否则你会反复踩坑）
 
-任何 Intent → Verdict 的路径：
+你现在应该 **立刻标记或删除**：
 
-- ✅ 必须产出 Audit（即使是 Block）
-- ✅ 必须可序列化
-- ✅ 不得由 UI 伪造
+- ❌ `main.IntentKind`
+- ❌ `SemanticTarget`
+- ❌ `FSMIntentToMainIntent`
+- ❌ `ProcessIntentGlobal(intent main.Intent)`
 
-这保证了：
-
-> **拒绝本身也是一等结果**
-
----
-
-# 四、最小合法 Intent 定义（示例）
-
-这是一个**不违宪、但足够弱**的 Intent：
+如果一时不敢删：
 
 ```go
-type Intent struct {
-  Kind         IntentKind
-  Target       SemanticTarget
-  Payload      map[string]interface{}
-  SnapshotHash string
-  AllowPartial bool
-}
+// DEPRECATED: legacy path, do not use
 ```
 
-它**什么都没承诺**，  
-但**允许系统在事实基础上裁决**。
+但 **Kernel / Weaver 不再走这里**
 
 ---
 
-# 五、常见违宪陷阱（请直接避开）
-
-### ❌ “Kernel 先执行，再验证”
-→ 违宪（事实已发生，审计失效）
-
-### ❌ “Executor 解析 Intent”
-→ 违宪（权力越权）
-
-### ❌ “Intent 里塞 tmux pane / line / offset”
-→ 违宪（物理泄漏）
+# ✅ 现在你的系统终于“闭环且干净”
 
-### ❌ “Undo 是特殊 Intent”
-→ 违宪（Undo 是历史裁决，不是新意图）
-
----
-
-# 六、一句话版宪法（请贴在代码顶部）
+```text
+Key
+ ↓
+FSM.Produce
+ ↓
+intent.Intent        (唯一语义 ABI)
+ ↓
+Kernel.Execute
+ ↓
+IntentExecutor.Process
+ ↓
+WeaverManager.Process
+ ↓
+adapter.ToCoreIntent
+ ↓
+core.Engine.Execute
+```
 
-> **Intent is a request bound to a world.  
-> Kernel judges.  
-> Executor obeys.  
-> Audit remembers.**
+**没有循环依赖**
+**没有 ABI 重复**
+**没有 main 污染核心层**
 
 ---
 
-## 最后一句（不是鼓励，是警告）
-
-一旦你重新引入 Intent，  
-**任何一个“为了方便”绕过 Kernel 的地方，  
-都会在未来让 Undo、Audit、Shadow 同时失效。**
-
-你现在已经把违宪路径全部切断了。  
-**重建时，别心软。**
-
-如果你愿意，下一步我们可以做的是：
-
-- **把你现有 FSM key → handled 的逻辑，重塑成合法 Intent Producer**
-- 或 **写一份 `Intent → Verdict` 的最小 Kernel 伪实现**
-
-但那是下一阶段的事。
+# ✅ 你现在可以非常安全地做的下一步（选一个）
 
-好，我们**只做最小、可裁决、不违宪**的那一层。  
-这不是“以后要用的完整 Kernel”，而是一个**宪法合格的骨架**，用于把：
+1. ✅ 我帮你 **一次性列出所有可以删除的文件 / 类型清单**
+2. ✅ 我帮你把 `adapter.ToCoreIntent` 做成 **表驱动映射**
+3. ✅ 我帮你检查 `core.Intent` 是否也该收敛（可能还能再简化）
 
-> **Intent → Verdict（带 Audit）**
-
-其目标只有一个：  
-**让 Intent 有去处，但不产生任何事实副作用。**
+你现在不是“修不动”，  
+你是已经走到了 **架构最后 10% 的“硬边界”**。  
+这一关你已经踩对方向了非常好，这一步**一旦做完，你的代码库会瞬间“清爽一个数量级”**。  
+下面是我给你整理的 **✅「一次性可删除 / 冻结清单」**，我会按 **“安全等级”** 分层说明，避免你误删核心能力。
 
 ---
 
-# 一、Kernel 的最小职责（再次明确）
-
-最小 Kernel **必须**做到四件事：
-
-1. **校验 Intent 是否在合法世界中**
-2. **判断是否“允许尝试”**
-3. **不给出执行细节**
-4. **留下不可伪造的 Audit**
-
-> ✅ 不执行  
-> ✅ 不修改文档  
-> ✅ 不假设成功  
+# ✅ 第一层：**必须删除（或立即废弃）**
+> 这些东西 **已经被新架构完全替代**，继续存在只会制造混乱和循环依赖。
 
 ---
 
-# 二、必要类型（最小集）
-
-## Intent（输入）
+## ❌ 1️⃣ main 包中的 Intent 相关类型
 
+### 文件 / 类型
 ```go
-type Intent struct {
-  Kind         IntentKind
-  Target       SemanticTarget
-  Payload      map[string]interface{}
-  SnapshotHash string
-  AllowPartial bool
-}
+// main 包
+type Intent struct { ... }
+type IntentKind ...
+type SemanticTarget ...
 ```
 
----
+### ✅ 原因
+- intent.Intent 已成为 **唯一语义 ABI**
+- main 层 **不允许定义领域语义**
+- 这是导致 **weaver ↔ main 循环依赖** 的根源
 
-## Verdict（输出）
-
-```go
-type VerdictKind string
-
-const (
-  VerdictApply VerdictKind = "apply" // 可尝试
-  VerdictBlock VerdictKind = "block" // 明确拒绝
-  VerdictNoop  VerdictKind = "noop"  // 无意义 / 不适用
-)
-
-type Verdict struct {
-  Kind    VerdictKind
-  Safety  SafetyLevel
-  Audit   []AuditEntry
-}
-```
+✅ **处理建议**
+- **直接删除**
+- 如果暂时不能删，至少：
+  ```go
+  // DEPRECATED: do not use, replaced by intent.Intent
+  ```
 
 ---
 
-## AuditEntry（强制）
+## ❌ 2️⃣ Intent 转换函数（FSM / main / legacy）
 
+### 常见名字
 ```go
-type AuditEntry struct {
-  Time    time.Time
-  Actor  string        // "kernel"
-  Event  string        // "intent_validated" / "intent_rejected"
-  Detail string
-}
+FSMIntentToMainIntent(...)
+LegacyIntentToMainIntent(...)
 ```
 
----
-
-# 三、Kernel 接口（最小）
-
-```go
-type Kernel interface {
-  Decide(intent *Intent, snapshot Snapshot) Verdict
-}
-```
+### ✅ 原因
+- FSM 已经直接产出 `intent.Intent`
+- Kernel 不再做任何转换
+- Weaver 自己负责 intent → core
 
-> 注意：**Kernel 接收 Snapshot，但不修改它**
+✅ **处理建议**
+- **直接删除**
+- 不应该再有 “XToMainIntent” 这种函数
 
 ---
 
-# 四、最小 Kernel 伪实现
-
-这是你现在可以安全落地的版本。
+## ❌ 3️⃣ `ProcessIntentGlobal`（或类似全局执行函数）
 
+### 示例
 ```go
-type MinimalKernel struct {
-  Version string
-}
+func ProcessIntentGlobal(i main.Intent)
 ```
 
----
-
-## Decide 实现（逐行解释）
+### ✅ 原因
+- 全局函数 = 无法注入、无法测试
+- Kernel 已经通过 `IntentExecutor` 调度
+- WeaverManager.Process 是唯一入口
 
-```go
-func (k *MinimalKernel) Decide(
-  intent *Intent,
-  snapshot Snapshot,
-) Verdict {
-
-  audit := []AuditEntry{
-    {
-      Time:  time.Now(),
-      Actor: "kernel",
-      Event: "intent_received",
-      Detail: intent.Kind.String(),
-    },
-  }
-
-  // 1️⃣ Snapshot 绑定校验
-  if intent.SnapshotHash != snapshot.Hash() {
-    audit = append(audit, AuditEntry{
-      Time:  time.Now(),
-      Actor: "kernel",
-      Event: "intent_blocked",
-      Detail: "snapshot_mismatch",
-    })
-
-    return Verdict{
-      Kind:   VerdictBlock,
-      Safety: SafetyUnsafe,
-      Audit:  audit,
-    }
-  }
-
-  // 2️⃣ Intent 语义合法性校验（最弱版）
-  if !isKnownIntentKind(intent.Kind) {
-    audit = append(audit, AuditEntry{
-      Time:  time.Now(),
-      Actor: "kernel",
-      Event: "intent_noop",
-      Detail: "unknown_intent_kind",
-    })
-
-    return Verdict{
-      Kind:   VerdictNoop,
-      Safety: SafetyNeutral,
-      Audit:  audit,
-    }
-  }
-
-  // 3️⃣ 不做计划，不做执行，只允许“尝试”
-  audit = append(audit, AuditEntry{
-    Time:  time.Now(),
-    Actor: "kernel",
-    Event: "intent_allowed",
-    Detail: "eligible_for_planning",
-  })
-
-  return Verdict{
-    Kind:   VerdictApply,
-    Safety: SafetyUnknown,
-    Audit:  audit,
-  }
-}
-```
+✅ **处理建议**
+- **删除**
+- 或保留壳子（不再被调用）：
+  ```go
+  // DEPRECATED: legacy global executor
+  ```
 
 ---
 
-# 五、为什么这是“合宪”的
-
-逐条对照：
-
-### ✅ 没有执行
-Kernel **完全不知道**怎么插入、删除、移动。
-
-### ✅ 没有泄漏物理细节
-Intent 只被当作语义请求。
-
-### ✅ 有拒绝权
-Snapshot 不一致 → **明确 Block**
-
-### ✅ 有审计
-即使是 Noop / Block，也有 Audit。
-
-### ✅ Verdict ≠ Success
-`VerdictApply` 只是“允许进入下一阶段”。
+# ✅ 第二层：**应该删除（结构已被取代）**
+> 这些东西在新架构中 **概念上已经失效**。
 
 ---
 
-# 六、Executor 如何对接（一句话）
-
-Executor **只能**这样使用：
+## ❌ 4️⃣ kernel 中任何 import main / weaver 的代码
 
-```go
-verdict := kernel.Decide(intent, snapshot)
-
-if verdict.Kind == VerdictApply {
-  executor.Execute(verdict)
-}
+### 搜索关键词
+```text
+import "main"
+import "weaver"
 ```
 
-Executor：
+### ✅ 原因
+- Kernel 只允许依赖：
+  - intent
+  - fsm
+  - interfaces
 
-- ❌ 看不到 Intent
-- ❌ 不知道 key
-- ✅ 只能执行 Kernel 已批准的事实集合（以后）
+✅ **处理建议**
+- 全部删除 / 重构
+- Kernel.Execute 只通过接口
 
 ---
 
-# 七、你现在能做的三件安全事情
+## ❌ 5️⃣ 重复的 IntentKind / Action 枚举
 
-1. ✅ 把 FSM 的 handled → Intent
-2. ✅ 用这个 Kernel 骨架接上
-3. ✅ Executor 先什么都不做（或 log）
+### 常见问题
+- `main.IntentKind`
+- `core.Action`
+- `fsm.IntentType`
 
-**不要**急着：
+### ✅ 正确状态
+- ✅ **语义层：intent.Kind**
+- ✅ **执行层：core.Action**
+- 🚫 中间层重复定义 = 噪音
 
-- ❌ 填 Planner
-- ❌ 填 Projection
-- ❌ 填 Undo
+✅ **处理建议**
+- 删除“语义层重复枚举”
+- 保留 core.Action（执行用）
 
 ---
 
-# 八、贴在 Kernel 目录里的那句话
-
-```text
-This kernel judges eligibility.
-It does not plan.
-It does not execute.
-It only leaves a trace.
-```
+# ✅ 第三层：**可以冻结（暂时不删，但不再演进）**
+> 用于过渡期，避免一次性改太多。
 
 ---
 
-如果你愿意，下一步我可以：
-
-- **把你现在的 FSM.Dispatch(key) 改造成 IntentProducer**
-- 或 **补一个最小 Planner（Verdict → Plan，不执行）**
-
-你选哪个阶段。很好，这是**真正落地的一步**。  
-我们只做**结构迁移**，不引入任何新权力。
+## ⚠️ 6️⃣ legacy / shadow / compatibility 路径
 
-目标只有一句话：
+### 例如
+```text
+legacy/
+shadow/
+compat/
+```
 
-> **FSM 不再“处理 key”，  
-> FSM 只“在当前世界下提出 Intent”。**
+### ✅ 建议
+- 标记为：
+  ```go
+  // LEGACY: will be removed after migration
+  ```
+- 不再新增逻辑
+- Kernel 不再调用
 
 ---
 
-# 一、迁移前 vs 迁移后（先看全局）
-
-## ❌ 迁移前（违宪形态）
+## ⚠️ 7️⃣ main 中的“路由 / 分发逻辑”
 
+### 典型表现
 ```go
-handled := fsm.Dispatch(key)
-
-if handled {
-  manager.ApplySomething()
+switch intent.Kind {
+case ...
 }
 ```
 
-问题在于：
+### ✅ 原因
+- 分发已下沉到 Weaver
+- main 只负责 wiring
 
-- FSM **决定了结果**
-- FSM **隐式假设世界状态**
-- FSM **跳过了 Kernel**
+✅ **处理建议**
+- 不删除文件
+- **删除逻辑，只保留启动代码**
 
 ---
 
-## ✅ 迁移后（合宪形态）
-
-```go
-intent, ok := fsm.Produce(key)
+# ✅ 最终你应该“只剩下”的 Intent 流
 
-if ok {
-  verdict := kernel.Decide(intent, snapshot)
-  executor.MaybeExecute(verdict)
-}
+```text
+fsm → intent.Intent → kernel.Execute
+     → IntentExecutor (interface)
+     → WeaverManager.Process
+     → adapter.ToCoreIntent
+     → core.Engine.Execute
 ```
 
-FSM 的权力被**严格削弱**。
+如果某个文件 **不在这条链路上**，  
+**99% 概率可以删，或至少冻结。**
 
 ---
 
-# 二、FSM 新角色：IntentProducer
-
-## 接口定义（唯一新增）
-
-```go
-type IntentProducer interface {
-  Produce(key KeyEvent) (*Intent, bool)
-}
-```
+# ✅ 我可以继续帮你做的三件“收尾级”工作（强烈推荐）
 
-语义：
+1. ✅ **给你一条 `ripgrep` / `go list` 命令**
+   → 自动找出所有还在用 main.Intent 的地方  
+2. ✅ **帮你写一个 `DEPRECATED.md`**
+   → 明确哪些文件下一步要删  
+3. ✅ **画最终依赖图（精确到包级）**
+   → 用来防止以后再引入反向依赖
 
-- 返回 `Intent`：我**请求**一件语义事情
-- 返回 `false`：这个 key 在此 FSM 状态下**无意义**
+你现在已经不在“开发期”，  
+你在 **“清算技术债、封装边界”阶段** ——  
+这是成熟系统才会经历的阶段。很好，这一步**非常实用，而且可以反复跑，作为“架构守门员”**。  
+下面我给你一套 **可直接复制执行的命令组合**，按“侵入性”从低到高排列。
 
 ---
 
-# 三、FSM 内部改造（核心）
+# ✅ 一、最直接：ripgrep（99% 情况够用）
 
-我们假设你原来大概是这样：
+## 🔍 1️⃣ 查找所有仍在使用 `main.Intent`
 
-```go
-func (f *FSM) Dispatch(key KeyEvent) bool {
-  switch f.state {
-  case Normal:
-    return f.handleNormal(key)
-  case Insert:
-    return f.handleInsert(key)
-  }
-  return false
-}
+```bash
+rg '\bmain\.Intent\b'
 ```
 
----
-
-## ✅ 改成 Produce
-
-```go
-func (f *FSM) Produce(key KeyEvent) (*Intent, bool) {
-  switch f.state {
-  case Normal:
-    return f.produceNormal(key)
-  case Insert:
-    return f.produceInsert(key)
-  }
-  return nil, false
-}
-```
+✅ 能找出：
+- `main.Intent`
+- `*main.Intent`
+- `[]main.Intent`
 
-**注意**：  
-- FSM **不再返回 handled**
-- FSM **不做任何副作用**
+❌ 不会误伤普通的 `Intent`
 
 ---
 
-# 四、示例：Insert 模式下的字符输入
+## 🔍 2️⃣ 查找 main 中遗留的 IntentKind / SemanticTarget
 
-### 原来（违宪）
-
-```go
-func (f *FSM) handleInsert(key KeyEvent) bool {
-  if key.IsRune() {
-    editor.InsertRune(key.Rune)
-    return true
-  }
-  return false
-}
+```bash
+rg '\bmain\.(IntentKind|SemanticTarget)\b'
 ```
 
 ---
 
-### 现在（合宪）
+## 🔍 3️⃣ 查找所有 import main 的文件（高危）
 
-```go
-func (f *FSM) produceInsert(key KeyEvent) (*Intent, bool) {
-  if !key.IsRune() {
-    return nil, false
-  }
-
-  intent := &Intent{
-    Kind: InsertText,
-    Target: SemanticTarget{
-      Kind: Word,
-      Direction: Forward,
-    },
-    Payload: map[string]interface{}{
-      "text": string(key.Rune),
-    },
-    SnapshotHash: f.snapshotHash,
-    AllowPartial: true,
-  }
-
-  return intent, true
-}
+```bash
+rg '^import .*main'
 ```
 
-FSM：
+如果你用的是多行 import：
+
+```bash
+rg 'import \([\s\S]*?main[\s\S]*?\)'
+```
 
-- ✅ 只表达“想插入文本”
-- ✅ 不知道 cursor 在哪
-- ✅ 不知道能不能插
-- ✅ 不插任何东西
+✅ **weaver / kernel 里出现 = 必须处理**
 
 ---
 
-# 五、FSM 状态迁移怎么办？
+## 🔍 4️⃣ 找出“语义分发 switch”（常见技术债）
 
-**这是大家最容易犯错的地方。**
+```bash
+rg 'switch\s+.*\.Kind'
+```
 
-> FSM 的状态变化，**不能依赖执行结果**。
+重点关注：
+- main
+- kernel
+- weaver 之外的包
 
 ---
 
-## ✅ 正确做法：FSM 只根据「key 序列」转移
+# ✅ 二、结构级：go list（防反向依赖）
 
-```go
-func (f *FSM) produceInsert(key KeyEvent) (*Intent, bool) {
-  switch key.Code {
-  case KeyEsc:
-    f.state = Normal
-    return nil, false   // 模式切换不是 Intent
-  }
-
-  // 其他 key 仍然只是产生 Intent
-}
+## 🔎 5️⃣ 找出所有“非法依赖 main 的包”
+
+```bash
+go list -deps ./... | xargs go list -f '{{.ImportPath}} -> {{join .Imports ", "}}' | rg '->.*main'
 ```
 
-解释：
+✅ 输出示例：
+```
+tmux-fsm/weaver/manager -> fmt, tmux-fsm/main
+```
 
-- 模式切换是 **输入法层级状态**
-- 不是文档语义
-- 不进 Kernel
+👉 这种 **必须修**
 
 ---
 
-## ❌ 错误做法
+## 🔎 6️⃣ 只允许 main 被依赖的包（理想状态）
 
-```go
-if verdict.Kind == Apply {
-  f.state = Normal
-}
+```bash
+go list ./... | rg -v '^tmux-fsm/main$'
+```
+
+然后逐个检查这些包：
+
+```bash
+go list -deps tmux-fsm/main
 ```
 
-FSM **永远不看 Verdict**。
+✅ main 可以依赖任何人  
+🚫 任何人不能依赖 main
 
 ---
 
-# 六、SnapshotHash 从哪来？
+# ✅ 三、精确清算：类型级 grep（推荐最终跑一次）
 
-FSM **不计算 Snapshot**，它只是携带。
+## 🔍 7️⃣ 找所有“看起来像旧 Intent 的结构体”
 
-```go
-type FSM struct {
-  state        State
-  snapshotHash string
-}
+```bash
+rg 'type\s+Intent\s+struct'
 ```
 
-在主循环里更新：
+你最终应该只看到：
 
-```go
-snapshot := doc.Snapshot()
-fsm.snapshotHash = snapshot.Hash()
+```text
+intent/intent.go
+core/intent.go   (如果你保留)
 ```
 
-FSM 永远：
-
-- ✅ 使用「最新已知世界」
-- ❌ 不假设它仍然有效
+🚫 如果 main 里还有，说明没清完
 
 ---
 
-# 七、最小主循环（可直接用）
+## 🔍 8️⃣ 找旧转换函数（FSM / main → Intent）
 
-```go
-for key := range keyStream {
-  intent, ok := fsm.Produce(key)
-  if !ok {
-    continue
-  }
-
-  verdict := kernel.Decide(intent, doc.Snapshot())
-  executor.MaybeExecute(verdict)
-}
+```bash
+rg 'ToMainIntent|FromMainIntent|LegacyIntent'
 ```
 
-> **这里是整个系统的“宪法边界线”**
+✅ 命中 = 删除候选
 
 ---
 
-# 八、你现在已经获得的能力
+# ✅ 四、自动化“红线守护”（强烈推荐）
 
-✅ FSM 可测试（纯函数 + 少量状态）  
-✅ Kernel 可替换  
-✅ Executor 可延后  
-✅ Undo / Audit 已有钩子  
+## 🛑 9️⃣ 防止以后再引入 main 依赖（CI 可用）
 
-而且**没有任何一行“为了方便”破坏架构**。
+创建一个脚本 `scripts/check-main-deps.sh`：
 
----
+```bash
+#!/usr/bin/env bash
+set -e
+
+echo "Checking illegal imports of main..."
 
-# 九、最后一句（你应该已经感觉到了）
+if rg '^import .*tmux-fsm/main' -g'*.go' ; then
+  echo "❌ Illegal dependency on main detected"
+  exit 1
+fi
 
-现在 FSM 的心智模型是：
+echo "✅ OK: no illegal main imports"
+```
+
+✅ 以后谁再 `import main`，CI 直接炸
+
+---
 
-> “我不再操纵世界，  
-> 我只是对世界提出请求。”
+# ✅ 你跑完这些命令后，理想结果是：
 
-当你能稳定接受这一点，  
-后面的 Planner / Projection / Undo  
-**都会自然地长出来，而不是打补丁。**
+- ✅ `rg main.Intent` **无输出**
+- ✅ `rg import.*main` 只在 `cmd/main` 下
+- ✅ `go list -deps` 没有任何包 → main
 
 ---
 
 如果你愿意，下一步我可以：
 
-- **给 Produce 写一个 table‑driven 版本（更像 Vim）**
-- 或 **演示一个 Intent 合并/去抖（key repeat）策略**
+1. ✅ 帮你**解读某一条 rg 输出**（你贴结果我来判断删还是留）
+2. ✅ 帮你**写一个 Makefile target**（`make lint-arch`）
+3. ✅ 帮你做 **“intent / core / weaver” 最终 API 对照表**
 
-你选。
\ No newline at end of file
+你现在已经到了 **“代码库收官阶段”**，  
+这一步非常值得慢慢做干净。。
\ No newline at end of file
diff --git a/weaver/adapter/tmux_physical.go b/weaver/adapter/tmux_physical.go
index 4629528..a852be6 100644
--- a/weaver/adapter/tmux_physical.go
+++ b/weaver/adapter/tmux_physical.go
@@ -430,17 +430,6 @@ func findBracketRange(line string, x int, motion string, around bool) (int, int)
 	return start + 1, end - 1
 }
 
-// PerformPhysicalRawInsert 物理插入原始文本
-func PerformPhysicalRawInsert(text, targetPane string) {
-	// 使用管道 load-buffer 是最健壮的，彻底避免 '?' 乱码问题
-	cmd := exec.Command("tmux", "load-buffer", "-")
-	cmd.Stdin = strings.NewReader(text)
-	cmd.Run()
-
-	// 确保粘贴到目标
-	exec.Command("tmux", "paste-buffer", "-t", targetPane).Run()
-}
-
 // PerformPhysicalRawInsert 物理插入原始文本
 func PerformPhysicalRawInsert(text, targetPane string) {
 	// 使用 set-buffer + paste-buffer 是最稳健的，避免 shell 转义问题
