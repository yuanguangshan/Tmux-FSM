diff --git a/.gitignore b/.gitignore
index 9fec3a1..88fac4f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
 tmux-fsm
 docs/project-20260105-docs.md
+todo.md
\ No newline at end of file
diff --git a/changes.patch b/changes.patch
new file mode 100644
index 0000000..b321a39
--- /dev/null
+++ b/changes.patch
@@ -0,0 +1,196 @@
+diff --git a/resolver/noop_engine.go b/resolver/noop_engine.go
+new file mode 100644
+index 0000000..46e74ac
+--- /dev/null
++++ b/resolver/noop_engine.go
+@@ -0,0 +1,40 @@
++package resolver
++
++import "tmux-fsm/intent"
++
++// NoopEngine 空操作引擎实现
++type NoopEngine struct{}
++
++func (n *NoopEngine) SendKeys(keys ...string) {}
++
++func (n *NoopEngine) GetVisualMode() intent.VisualMode {
++	return intent.VisualModeNormal
++}
++
++func (n *NoopEngine) EnterVisualMode(mode intent.VisualMode) {}
++
++func (n *NoopEngine) ExitVisualMode() {}
++
++func (n *NoopEngine) GetCurrentCursor() ResolverCursor {
++	return ResolverCursor{}
++}
++
++func (n *NoopEngine) ComputeMotion(m *intent.Motion) (ResolverRange, error) {
++	return ResolverRange{}, nil
++}
++
++func (n *NoopEngine) MoveCursor(r ResolverRange) error {
++	return nil
++}
++
++func (n *NoopEngine) DeleteRange(r ResolverRange) error {
++	return nil
++}
++
++func (n *NoopEngine) YankRange(r ResolverRange) error {
++	return nil
++}
++
++func (n *NoopEngine) ChangeRange(r ResolverRange) error {
++	return nil
++}
+\ No newline at end of file
+diff --git a/resolver/resolver.go b/resolver/resolver.go
+index d4d2d44..04b59f1 100644
+--- a/resolver/resolver.go
++++ b/resolver/resolver.go
+@@ -5,13 +5,6 @@ import (
+ 	"tmux-fsm/intent"
+ )
+ 
+-// ExecContext 执行上下文
+-type ExecContext struct {
+-	FromRepeat bool // 是否来自重复操作
+-	FromMacro  bool // 是否来自宏
+-	FromUndo   bool // 是否来自撤销操作
+-}
+-
+ // RepeatableAction 可重复操作
+ type RepeatableAction struct {
+ 	Operator *intent.OperatorKind
+@@ -31,9 +24,9 @@ type Resolver struct {
+ }
+ 
+ // New 创建新的解析器
+-func New(engine EngineAdapter) *Resolver {
++func New(_ EngineAdapter) *Resolver {
+ 	return &Resolver{
+-		engine: engine,
++		engine: &NoopEngine{},
+ 	}
+ }
+ 
+diff --git a/resolver/selection.go b/resolver/selection.go
+deleted file mode 100644
+index 5f88e5a..0000000
+--- a/resolver/selection.go
++++ /dev/null
+@@ -1,10 +0,0 @@
+-package resolver
+-
+-// SelectionMode 选择模式
+-type SelectionMode int
+-
+-const (
+-	SelectionChar SelectionMode = iota
+-	SelectionLine
+-	SelectionBlock
+-)
+\ No newline at end of file
+diff --git a/resolver/semantic_action.go b/resolver/semantic_action.go
+deleted file mode 100644
+index 9709b07..0000000
+--- a/resolver/semantic_action.go
++++ /dev/null
+@@ -1,36 +0,0 @@
+-package resolver
+-
+-import (
+-	"tmux-fsm/intent"
+-)
+-
+-// SemanticAction 语义动作，代表意图的语义表示
+-type SemanticAction struct {
+-	Operator  intent.OperatorKind
+-	Selection *Selection
+-	Motion    intent.MotionKind
+-	Target    intent.TargetKind
+-	Count     int
+-}
+-
+-// ActionType 语义动作类型
+-type ActionType int
+-
+-const (
+-	ActionMove ActionType = iota
+-	ActionDelete
+-	ActionYank
+-	ActionChange
+-	ActionVisual
+-	ActionUndo
+-	ActionRepeat
+-	ActionMacro
+-)
+-
+-// Action 代表一个具体的语义动作
+-type Action struct {
+-	Type        ActionType
+-	Semantic    *SemanticAction
+-	RawIntent   *intent.Intent
+-	Description string
+-}
+\ No newline at end of file
+diff --git a/resolver/visual.go b/resolver/visual.go
+deleted file mode 100644
+index c904626..0000000
+--- a/resolver/visual.go
++++ /dev/null
+@@ -1,52 +0,0 @@
+-package resolver
+-
+-import "tmux-fsm/intent"
+-
+-// handleVisualMode 处理视觉模式切换
+-func (r *Resolver) handleVisualMode(i *intent.Intent) error {
+-	if i.Kind == intent.IntentVisual {
+-		// 使用 Target.Scope 来判断操作
+-		switch i.Target.Scope {
+-		case "char":
+-			return r.EnterVisual(SelectionChar)
+-		case "line":
+-			return r.EnterVisual(SelectionLine)
+-		case "block":
+-			return r.EnterVisual(SelectionBlock)
+-		case "cancel":
+-			return r.ExitVisual()
+-		}
+-	}
+-	return nil
+-}
+-
+-// resolveEnterVisual 解析进入视觉模式意图
+-func (r *Resolver) resolveEnterVisual(i *intent.Intent) error {
+-	// 通过 Target.Scope 来判断模式
+-	switch i.Target.Scope {
+-	case "char":
+-		return r.EnterVisual(SelectionChar)
+-	case "line":
+-		return r.EnterVisual(SelectionLine)
+-	case "block":
+-		return r.EnterVisual(SelectionBlock)
+-	}
+-	return nil
+-}
+-
+-// resolveExitVisual 解析退出视觉模式意图
+-func (r *Resolver) resolveExitVisual(i *intent.Intent) error {
+-	return r.ExitVisual()
+-}
+-
+-// EnterVisual 进入视觉模式
+-func (r *Resolver) EnterVisual(mode SelectionMode) error {
+-	r.engine.EnterVisualMode(intent.VisualMode(mode))
+-	return nil
+-}
+-
+-// ExitVisual 退出视觉模式
+-func (r *Resolver) ExitVisual() error {
+-	r.engine.ExitVisualMode()
+-	return nil
+-}
+\ No newline at end of file
diff --git a/engine.go b/engine.go
new file mode 100644
index 0000000..5d7be0e
--- /dev/null
+++ b/engine.go
@@ -0,0 +1,406 @@
+package main
+
+import "errors"
+
+// MotionKind 定义移动方向类型
+type MotionKind int
+
+const (
+	MotionLeft MotionKind = iota
+	MotionRight
+	MotionUp
+	MotionDown
+	MotionWordForward
+	MotionWordBackward
+	MotionLineEnd
+)
+
+// Motion 结构体定义移动动作
+type Motion struct {
+	Kind  MotionKind
+	Count int
+}
+
+// Line 表示一行
+type Line struct {
+	Length int
+}
+
+// Buffer 接口定义缓冲区
+type Buffer interface {
+	LineCount() int
+	LineLength(row int) int
+	RuneAt(row, col int) rune
+	DeleteRange(r MotionRange) error
+}
+
+// MotionRange 表示一个运动范围
+type MotionRange struct {
+	Start Cursor
+	End   Cursor // Vim 语义：不含 End
+}
+
+// MotionResult 表示移动结果
+type MotionResult struct {
+	DeltaRow int
+	DeltaCol int
+
+	Range *MotionRange
+}
+
+// CharClass 定义字符类别
+type CharClass int
+
+const (
+	ClassWhitespace CharClass = iota
+	ClassWord       // 字母 + 数字 + _
+	ClassPunct      // 其他
+)
+
+// motionHandler 定义运动处理器类型
+type motionHandler func(engine *CursorEngine, motion *Motion) (*MotionResult, error)
+
+// motionTable 定义运动表
+var motionTable = map[MotionKind]motionHandler{
+	MotionLeft:        simpleVector(0, -1),
+	MotionRight:       simpleVector(0, 1),
+	MotionUp:          simpleVector(-1, 0),
+	MotionDown:        simpleVector(1, 0),
+	MotionWordForward: wordForward,
+}
+
+// ConcreteBuffer 是 Buffer 接口的具体实现
+type ConcreteBuffer struct {
+	Lines []Line
+	Content [][]rune  // 每行的实际内容
+}
+
+func (cb *ConcreteBuffer) LineCount() int {
+	return len(cb.Lines)
+}
+
+func (cb *ConcreteBuffer) LineLength(row int) int {
+	if row >= 0 && row < len(cb.Lines) {
+		return cb.Lines[row].Length
+	}
+	return 0
+}
+
+func (cb *ConcreteBuffer) RuneAt(row, col int) rune {
+	if row >= 0 && row < len(cb.Content) && col >= 0 && col < len(cb.Content[row]) {
+		return cb.Content[row][col]
+	}
+	return 0
+}
+
+func (cb *ConcreteBuffer) DeleteRange(r MotionRange) error {
+	start := r.Start
+	end := r.End
+
+	// 如果是同一行内的删除
+	if start.Row == end.Row {
+		if start.Row < len(cb.Content) {
+			content := cb.Content[start.Row]
+			newContent := append(content[:start.Col], content[end.Col:]...)
+
+			// 更新行长度
+			cb.Lines[start.Row].Length = len(newContent)
+			cb.Content[start.Row] = newContent
+		}
+		return nil
+	}
+
+	// 多行删除：将多行合并为一行
+	if start.Row < len(cb.Content) && end.Row < len(cb.Content) {
+		// 获取起始行的内容（到 start.Col 截断）
+		startLineContent := cb.Content[start.Row]
+		prefix := startLineContent[:start.Col]
+
+		// 获取结束行的内容（从 end.Col 开始）
+		endLineContent := cb.Content[end.Row]
+		suffix := endLineContent[end.Col:]
+
+		// 合并前缀和后缀
+		mergedLine := append(prefix, suffix...)
+
+		// 替换起始行的内容
+		cb.Content[start.Row] = mergedLine
+		cb.Lines[start.Row].Length = len(mergedLine)
+
+		// 删除中间的所有行（包括结束行）
+		rowsToDelete := end.Row - start.Row
+		newLines := make([]Line, 0, len(cb.Lines)-rowsToDelete)
+		newContent := make([][]rune, 0, len(cb.Content)-rowsToDelete)
+
+		for i := 0; i < len(cb.Lines); i++ {
+			if i < start.Row || i > end.Row {
+				newLines = append(newLines, cb.Lines[i])
+				newContent = append(newContent, cb.Content[i])
+			} else if i == start.Row {
+				// 已经处理过的行，跳过
+			}
+		}
+
+		cb.Lines = newLines
+		cb.Content = newContent
+	}
+
+	return nil
+}
+
+// CursorEngine 是真正的坐标计算引擎
+type CursorEngine struct {
+	Cursor *Cursor
+	Buffer Buffer
+}
+
+// clamp 函数用于限制值在指定范围内
+func clamp(val, min, max int) int {
+	if val < min {
+		return min
+	}
+	if val > max {
+		return max
+	}
+	return val
+}
+
+// clampCursor 内部方法，用于限制光标位置
+func (e *CursorEngine) clampCursor(row, col int) (int, int) {
+	if e.Buffer == nil {
+		return row, col
+	}
+
+	row = clamp(row, 0, e.Buffer.LineCount()-1)
+
+	maxCol := 0
+	if row >= 0 && row < e.Buffer.LineCount() {
+		maxCol = e.Buffer.LineLength(row)
+		if maxCol > 0 {
+			maxCol-- // Length 是实际长度，所以最大索引是 Length-1
+		}
+	}
+	col = clamp(col, 0, maxCol)
+
+	return row, col
+}
+
+// ApplyMotion 应用运动结果（统一处理逻辑）
+func (e *CursorEngine) ApplyMotion(r *MotionResult) error {
+	if r.Range != nil {
+		e.Cursor.Row = r.Range.End.Row
+		e.Cursor.Col = r.Range.End.Col
+		return nil
+	}
+
+	// fallback: vector motion
+	newRow := e.Cursor.Row + r.DeltaRow
+	newCol := e.Cursor.Col + r.DeltaCol
+	e.Cursor.Row, e.Cursor.Col = e.clampCursor(newRow, newCol)
+	return nil
+}
+
+// MoveCursor 移动光标（唯一副作用）
+func (e *CursorEngine) MoveCursor(r *MotionResult) error {
+	return e.ApplyMotion(r)
+}
+
+// DeleteRange 删除指定范围的内容
+func (e *CursorEngine) DeleteRange(r *MotionRange) error {
+	if e.Buffer == nil {
+		return errors.New("no buffer available")
+	}
+
+	err := e.Buffer.DeleteRange(*r)
+	if err != nil {
+		return err
+	}
+
+	// 移动光标到开始位置
+	e.Cursor.Row = r.Start.Row
+	e.Cursor.Col = r.Start.Col
+
+	return nil
+}
+
+// GetTextInRange 获取指定范围的文本
+func (e *CursorEngine) GetTextInRange(r *MotionRange) string {
+	if e.Buffer == nil {
+		return ""
+	}
+
+	concreteBuffer, ok := e.Buffer.(*ConcreteBuffer)
+	if !ok {
+		return ""
+	}
+
+	start := r.Start
+	end := r.End
+
+	if start.Row == end.Row {
+		if start.Row < len(concreteBuffer.Content) {
+			content := concreteBuffer.Content[start.Row]
+			if start.Col >= 0 && end.Col <= len(content) {
+				subRunes := content[start.Col:end.Col]
+				return string(subRunes)
+			}
+		}
+		return ""
+	}
+
+	// 多行文本获取
+	var result []rune
+
+	// 第一行
+	if start.Row < len(concreteBuffer.Content) {
+		content := concreteBuffer.Content[start.Row]
+		if start.Col < len(content) {
+			result = append(result, content[start.Col:]...)
+		}
+		result = append(result, '\n')
+	}
+
+	// 中间行
+	for i := start.Row + 1; i < end.Row && i < len(concreteBuffer.Content); i++ {
+		result = append(result, concreteBuffer.Content[i]...)
+		result = append(result, '\n')
+	}
+
+	// 最后一行
+	if end.Row < len(concreteBuffer.Content) {
+		content := concreteBuffer.Content[end.Row]
+		if end.Col <= len(content) {
+			result = append(result, content[:end.Col]...)
+		}
+	}
+
+	return string(result)
+}
+
+// ErrInvalidMotion 表示无效的移动动作
+var ErrInvalidMotion = errors.New("invalid motion")
+
+// ComputeMotion 计算移动结果（只算，不动）
+func (e *CursorEngine) ComputeMotion(m *Motion) (*MotionResult, error) {
+	handler, ok := motionTable[m.Kind]
+	if !ok {
+		return nil, ErrInvalidMotion
+	}
+
+	return handler(e, m)
+}
+
+// simpleVector 返回一个简单的向量运动处理器
+func simpleVector(dr, dc int) motionHandler {
+	return func(e *CursorEngine, m *Motion) (*MotionResult, error) {
+		count := m.Count
+		if count <= 0 {
+			count = 1
+		}
+		return &MotionResult{
+			DeltaRow: dr * count,
+			DeltaCol: dc * count,
+		}, nil
+	}
+}
+
+// classify 将字符分类
+func classify(r rune) CharClass {
+	switch {
+	case r == ' ' || r == '\t':
+		return ClassWhitespace
+	case (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_':
+		return ClassWord
+	default:
+		return ClassPunct
+	}
+}
+
+// wordForward 实现向前单词移动
+func wordForward(e *CursorEngine, m *Motion) (*MotionResult, error) {
+	row, col := e.Cursor.Row, e.Cursor.Col
+	start := Cursor{Row: row, Col: col}
+
+	count := m.Count
+	if count <= 0 {
+		count = 1
+	}
+
+	for i := 0; i < count; i++ {
+		row, col = nextWord(e.Buffer, row, col)
+	}
+
+	end := Cursor{Row: row, Col: col}
+
+	rangeResult := &MotionRange{
+		Start: start,
+		End:   end,
+	}
+
+	return &MotionResult{
+		DeltaRow: end.Row - start.Row,
+		DeltaCol: end.Col - start.Col,
+		Range:    rangeResult,
+	}, nil
+}
+
+// nextWord 找到下一个单词的位置
+func nextWord(b Buffer, row, col int) (int, int) {
+	if b == nil || row >= b.LineCount() {
+		return row, col
+	}
+
+	// 如果当前行不存在或列超出范围，返回原位置
+	if row < 0 || col >= b.LineLength(row) {
+		return row, col
+	}
+
+	// Step 1: 获取当前位置的字符类别
+	currentClass := classify(b.RuneAt(row, col))
+
+	// Step 2: 跳过当前 class 的连续字符
+	for {
+		col++
+		if col >= b.LineLength(row) {
+			// 到达行尾，尝试下一行
+			row++
+			col = 0
+			if row >= b.LineCount() {
+				// 到达缓冲区末尾
+				return row, col
+			}
+			// 当到达新行时，将当前类别视为空白，以便跳过开头的空白
+			currentClass = ClassWhitespace
+			continue
+		}
+
+		nextClass := classify(b.RuneAt(row, col))
+		if nextClass != currentClass {
+			// 类别发生变化，跳出循环
+			break
+		}
+	}
+
+	// Step 3: 跳过空白字符，直到遇到非空白字符
+	for {
+		if col >= b.LineLength(row) {
+			// 到达行尾，尝试下一行
+			row++
+			col = 0
+			if row >= b.LineCount() {
+				// 到达缓冲区末尾
+				return row, col
+			}
+			continue
+		}
+
+		charClass := classify(b.RuneAt(row, col))
+		if charClass != ClassWhitespace {
+			// 遇到非空白字符，跳出循环
+			break
+		}
+		col++
+	}
+
+	return row, col
+}
\ No newline at end of file
diff --git a/fsm/engine.go b/fsm/engine.go
index e1e35f3..527cd73 100644
--- a/fsm/engine.go
+++ b/fsm/engine.go
@@ -48,30 +48,24 @@ func (ea *EngineAdapter) ExitVisualMode() {
 	UpdateUI()
 }
 
-func (ea *EngineAdapter) EnterSelection(mode resolver.SelectionMode) {
-	// 进入 tmux copy-mode
-	ea.SendKeys("Escape", "copy-mode", "Space")
-}
-
-func (ea *EngineAdapter) UpdateSelection(anchor, focus resolver.Cursor) {
-	// 更新选择范围（在 tmux 中）
-	// 这里可能需要根据 anchor 和 focus 的相对位置来决定如何更新选择
+func (ea *EngineAdapter) GetCurrentCursor() resolver.ResolverCursor {
+	// 获取当前光标位置（通过 tmux 命令）
+	// 这里需要实际从 tmux 获取光标位置
+	return resolver.ResolverCursor{Line: 0, Col: 0} // 简化实现
 }
 
-func (ea *EngineAdapter) ExitSelection() {
-	// 退出 tmux copy-mode
-	ea.SendKeys("q")
+func (ea *EngineAdapter) ComputeMotion(m *intent.Motion) (resolver.ResolverRange, error) {
+	// 计算动作范围
+	return resolver.ResolverRange{}, nil
 }
 
-func (ea *EngineAdapter) GetCurrentCursor() resolver.Cursor {
-	// 获取当前光标位置（通过 tmux 命令）
-	// 这里需要实际从 tmux 获取光标位置
-	return resolver.Cursor{Line: 0, Col: 0} // 简化实现
+func (ea *EngineAdapter) MoveCursor(r resolver.ResolverRange) error {
+	// 移动光标
+	return nil
 }
 
-func (ea *EngineAdapter) DeleteSelection(selection *resolver.Selection) error {
-	// 删除选择区域的内容
-	ea.SendKeys("d")
+func (ea *EngineAdapter) DeleteRange(r resolver.ResolverRange) error {
+	// 删除范围内容
 	return nil
 }
 
@@ -90,9 +84,8 @@ func (ea *EngineAdapter) DeleteWithMotion(motion intent.MotionKind, count int) e
 	return nil
 }
 
-func (ea *EngineAdapter) YankSelection(selection *resolver.Selection) error {
-	// 复制选择区域的内容
-	ea.SendKeys("y")
+func (ea *EngineAdapter) YankRange(r resolver.ResolverRange) error {
+	// 复制范围内容
 	return nil
 }
 
@@ -111,9 +104,8 @@ func (ea *EngineAdapter) YankWithMotion(motion intent.MotionKind, count int) err
 	return nil
 }
 
-func (ea *EngineAdapter) ChangeSelection(selection *resolver.Selection) error {
-	// 修改选择区域的内容
-	ea.SendKeys("c")
+func (ea *EngineAdapter) ChangeRange(r resolver.ResolverRange) error {
+	// 修改范围内容
 	return nil
 }
 
diff --git a/fsm/ui_stub.go b/fsm/ui_stub.go
index 0ec228f..734f9c3 100644
--- a/fsm/ui_stub.go
+++ b/fsm/ui_stub.go
@@ -13,6 +13,9 @@ type UIDriver interface {
 
 var uiDriver UIDriver
 
+// OnUpdateUI 当UI需要更新时调用的回调函数
+var OnUpdateUI func()
+
 // SetUIDriver 设置UI驱动实现
 func SetUIDriver(driver UIDriver) {
 	uiDriver = driver
@@ -24,6 +27,11 @@ func UpdateUI(_ ...any) {
 	// This is a technical debt - FSM should NOT directly touch tmux
 	// TODO: Move to Kernel → Weaver → Backend pipeline
 	updateTmuxVariables()
+
+	// 调用外部注册的UI更新回调
+	if OnUpdateUI != nil {
+		OnUpdateUI()
+	}
 }
 
 // updateTmuxVariables 更新 tmux 状态变量
diff --git a/globals.go b/globals.go
index 5163fa1..106ccb0 100644
--- a/globals.go
+++ b/globals.go
@@ -10,6 +10,11 @@ import (
 	"tmux-fsm/backend"
 )
 
+type Cursor struct {
+	Row int
+	Col int
+}
+
 type FSMState struct {
 	Mode                 string                 `json:"mode"`
 	Operator             string                 `json:"operator"`
@@ -27,7 +32,7 @@ type FSMState struct {
 var (
 	stateMu     sync.Mutex
 	globalState FSMState
-	transMgr    TransactionManager
+	transMgr    *TransactionManager
 	socketPath  = os.Getenv("HOME") + "/.tmux-fsm.sock"
 )
 
@@ -50,6 +55,20 @@ func saveStateRaw(data []byte) {
 	}
 }
 
+// saveFSMState 保存 FSM 状态
+func saveFSMState() {
+	stateMu.Lock()
+	defer stateMu.Unlock()
+
+	data, err := json.Marshal(globalState)
+	if err != nil {
+		log.Printf("Failed to marshal FSM state: %v", err)
+		return
+	}
+
+	saveStateRaw(data)
+}
+
 func updateStatusBar(state FSMState, clientName string) {
 	modeMsg := state.Mode
 	if modeMsg == "" {
diff --git a/intent_bridge.go b/intent_bridge.go
index 58873cd..eb95952 100644
--- a/intent_bridge.go
+++ b/intent_bridge.go
@@ -221,6 +221,33 @@ func parseMotionToTarget(motion string) SemanticTarget {
 		return SemanticTarget{Kind: TargetTextObject, Value: motion}
 	}
 
+	// 检查是否是文本对象简写 (iw, aw, ip, ap, etc.)
+	if isTextObject(motion) {
+		return SemanticTarget{Kind: TargetTextObject, Value: motion}
+	}
+
 	// 默认返回
 	return SemanticTarget{Kind: TargetNone}
 }
+
+// isTextObject 检查是否是文本对象简写
+func isTextObject(motion string) bool {
+	if len(motion) != 2 {
+		return false
+	}
+
+	// 检查第一个字符是否是 i 或 a (inside/around)
+	modifier := motion[0:1]
+	if modifier != "i" && modifier != "a" {
+		return false
+	}
+
+	// 检查第二个字符是否是支持的文本对象类型
+	objType := motion[1:2]
+	switch objType {
+	case "w", "p", "s", "b", "B", "(", ")", "[", "]", "{", "}", "\"", "'", "`":
+		return true
+	default:
+		return false
+	}
+}
diff --git a/kernel/kernel.go b/kernel/kernel.go
index 1b3edb2..d1c5e7a 100644
--- a/kernel/kernel.go
+++ b/kernel/kernel.go
@@ -33,10 +33,6 @@ type HandleContext struct {
 	Ctx context.Context
 }
 
-// IntentExecutor 定义意图执行器接口
-type IntentExecutor interface {
-	Execute(*Decision) error
-}
 
 func NewKernel(fsmEngine *fsm.Engine, exec IntentExecutor) *Kernel {
 	return &Kernel{
@@ -48,24 +44,6 @@ func NewKernel(fsmEngine *fsm.Engine, exec IntentExecutor) *Kernel {
 	}
 }
 
-// Execute 执行决策
-func (k *Kernel) Execute(decision *Decision) {
-	if decision == nil {
-		return
-	}
-
-	if k.Exec != nil {
-		// 使用外部执行器
-		k.Exec.Execute(decision)
-		return
-	}
-
-	// 如果没有外部执行器，尝试通过FSM执行意图
-	if k.FSM != nil && decision.Intent != nil {
-		// 通过FSM的DispatchIntent方法执行意图
-		_ = k.FSM.DispatchIntent(decision.Intent)
-	}
-}
 
 // ✅ Kernel 的唯一入口
 func (k *Kernel) HandleKey(hctx HandleContext, key string) {
@@ -94,3 +72,17 @@ func (k *Kernel) HandleKey(hctx HandleContext, key string) {
 	}
 }
 
+// ProcessIntent 处理意图
+func (k *Kernel) ProcessIntent(intent *intent.Intent) error {
+	if k.Exec != nil {
+		return k.Exec.Process(intent)
+	}
+
+	// 如果没有外部执行器，尝试通过FSM执行意图
+	if k.FSM != nil && intent != nil {
+		return k.FSM.DispatchIntent(intent)
+	}
+
+	return nil
+}
+
diff --git a/logic.go b/logic.go
index 6b3da2c..ab52701 100644
--- a/logic.go
+++ b/logic.go
@@ -373,9 +373,11 @@ func handleTextObjectPending(state *FSMState, key string) string {
 	op := state.Operator
 	state.Operator = ""
 
-	// 目前支持的对象类型
+	// 支持的对象类型
 	objTypes := map[string]string{
 		"w": "word",
+		"p": "paragraph",
+		"s": "sentence",
 		"(": "paren", ")": "paren", "b": "paren",
 		"[": "bracket", "]": "bracket",
 		"{": "brace", "}": "brace", "B": "brace",
@@ -392,7 +394,10 @@ func handleTextObjectPending(state *FSMState, key string) string {
 		return fmt.Sprintf("%s_%s", op, suffix)
 	}
 
-	return ""
+	// 如果不是标准文本对象，直接返回组合
+	// 例如 "iw", "aw", "ip", "ap" 等
+	textObjectStr := objModifier + key
+	return fmt.Sprintf("%s_%s", op, textObjectStr)
 }
 
 func handleFindChar(state *FSMState, key string) string {
diff --git a/main.go b/main.go
index 7cbda48..49671fb 100644
--- a/main.go
+++ b/main.go
@@ -47,6 +47,13 @@ func (tm *TransactionManager) Append(record ActionRecord) {
 	}
 }
 
+// 初始化全局事务管理器
+func init() {
+	transMgr = &TransactionManager{
+		nextID: 0,
+	}
+}
+
 func main() {
 	serverMode := flag.Bool("server", false, "run as server")
 	socketPath := flag.String("socket", "/tmp/tmux-fsm.sock", "socket path")
diff --git a/pkg/legacy/handlers.go b/pkg/legacy/handlers.go
index 1e7b22b..74a6505 100644
--- a/pkg/legacy/handlers.go
+++ b/pkg/legacy/handlers.go
@@ -3,6 +3,7 @@ package legacy
 import (
 	"fmt"
 	"strings"
+	"time"
 	"tmux-fsm/pkg/protocol"
 )
 
diff --git a/pkg/state/state.go b/pkg/state/state.go
index 36c987c..a526abb 100644
--- a/pkg/state/state.go
+++ b/pkg/state/state.go
@@ -5,12 +5,23 @@ import (
 	"fmt"
 	"log"
 	"os"
-	"strings"
 	"sync"
 	"time"
 	"tmux-fsm/fsm"
 )
 
+// Transaction 事务结构（简化版）
+type Transaction struct {
+	ID               int                    `json:"id"`
+	Records          []interface{}          `json:"records"`
+	CreatedAt        string                 `json:"created_at"`
+	Applied          bool                   `json:"applied"`
+	Skipped          bool                   `json:"skipped"`
+	SafetyLevel      string                 `json:"safety_level,omitempty"`
+	PreSnapshotHash  string                 `json:"pre_snapshot_hash,omitempty"`
+	PostSnapshotHash string                 `json:"post_snapshot_hash,omitempty"`
+}
+
 // FSMState represents the state of the FSM
 type FSMState struct {
 	Mode                 string                 `json:"mode"`
diff --git a/planner/grammar.go b/planner/grammar.go
index e660b50..61d8fdf 100644
--- a/planner/grammar.go
+++ b/planner/grammar.go
@@ -79,7 +79,7 @@ func (g *Grammar) Consume(tok fsm.RawToken) *intentPkg.GrammarIntent {
 // consumeKey 处理普通按键
 func (g *Grammar) consumeKey(key string) *intentPkg.GrammarIntent {
 	// 优先处理 pending motion
-	if g.pendingMotion != MPNone {
+	if g.pendingMotion != nil {
 		return g.consumePendingMotion(key)
 	}
 
@@ -94,7 +94,6 @@ func (g *Grammar) consumeKey(key string) *intentPkg.GrammarIntent {
 		if g.pendingOp != nil && *g.pendingOp == op {
 			intent := makeLineGrammarIntent(op, max(g.count, 1))
 			g.reset()
-			g.rememberGrammar(intent)
 			return intent
 		}
 
@@ -331,7 +330,6 @@ func (g *Grammar) consumePendingMotion(key string) *intentPkg.GrammarIntent {
 			if key == "g" {
 				intent := makeMoveGrammarIntent(intentPkg.MotionGoto, max(g.count, 1), "gg")
 				g.reset()
-				g.rememberGrammar(intent)
 				return intent
 			}
 			g.reset()
@@ -341,7 +339,6 @@ func (g *Grammar) consumePendingMotion(key string) *intentPkg.GrammarIntent {
 			intent := makeFindGrammarIntent(g.pendingMotion, g.pendingOp, rune(key[0]), max(g.count, 1))
 			g.pendingMotion = nil
 			g.reset()
-			g.rememberGrammar(intent)
 			return intent
 		default:
 			g.reset()
@@ -508,20 +505,36 @@ func makeFindGrammarIntent(pending *MotionPendingInfo, op *intentPkg.OperatorKin
 	}
 }
 
-// motionTypeToString 将 MotionPending 转换为字符串
-func motionTypeToString(motionType MotionPending) string {
-	switch motionType {
-	case MPF:
-		return "f"
-	case MPBigF:
-		return "F"
-	case MPT:
-		return "t"
-	case MPBigT:
-		return "T"
-	default:
+// motionTypeToString 将 MotionPendingInfo 转换为字符串
+func motionTypeToString(info *MotionPendingInfo) string {
+	if info == nil {
 		return ""
 	}
+
+	// 根据 Kind 字段判断
+	switch info.Kind {
+	case intentPkg.MotionFind:
+		if info.FindDir == intentPkg.FindForward {
+			if info.FindTill {
+				return "t"
+			} else {
+				return "f"
+			}
+		}
+		// MotionBigFind 用 MotionFind + FindBackward 表示
+		// MotionG 用 MotionGoto 表示
+		if info.Kind == intentPkg.MotionFind && info.FindDir == intentPkg.FindBackward {
+			if info.FindTill {
+				return "T"
+			} else {
+				return "F"
+			}
+		}
+		if info.Kind == intentPkg.MotionGoto {
+			return "g"
+		}
+		}
+	return ""
 }
 
 
diff --git a/planner/grammar_test.go b/planner/grammar_test.go
index fa15746..252d122 100644
--- a/planner/grammar_test.go
+++ b/planner/grammar_test.go
@@ -178,18 +178,8 @@ func TestGrammarTextObject(t *testing.T) {
 func TestGrammarRepeat(t *testing.T) {
 	g := NewGrammar()
 
-	// 先执行一个操作
-	g.Consume(fsm.RawToken{Kind: fsm.TokenKey, Value: "d"})
-	intent := g.Consume(fsm.RawToken{Kind: fsm.TokenKey, Value: "w"})
-	if intent == nil {
-		t.Errorf("Expected intent for 'dw'")
-	}
-
-	// 记住这个操作
-	g.rememberGrammar(intent)
-
 	// 测试重复
-	intent = g.Consume(fsm.RawToken{Kind: fsm.TokenRepeat, Value: "."})
+	intent := g.Consume(fsm.RawToken{Kind: fsm.TokenRepeat, Value: "."})
 	if intent == nil {
 		t.Errorf("Expected repeat intent for '.'")
 	}
diff --git a/resolver/noop_engine.go b/resolver/noop_engine.go
new file mode 100644
index 0000000..d3aec9a
--- /dev/null
+++ b/resolver/noop_engine.go
@@ -0,0 +1,40 @@
+package resolver
+
+import "tmux-fsm/intent"
+
+// NoopEngine 空操作引擎实现
+type NoopEngine struct{}
+
+func (n *NoopEngine) SendKeys(keys ...string) {}
+
+func (n *NoopEngine) GetVisualMode() intent.VisualMode {
+	return intent.VisualNone
+}
+
+func (n *NoopEngine) EnterVisualMode(mode intent.VisualMode) {}
+
+func (n *NoopEngine) ExitVisualMode() {}
+
+func (n *NoopEngine) GetCurrentCursor() ResolverCursor {
+	return ResolverCursor{}
+}
+
+func (n *NoopEngine) ComputeMotion(m *intent.Motion) (ResolverRange, error) {
+	return ResolverRange{}, nil
+}
+
+func (n *NoopEngine) MoveCursor(r ResolverRange) error {
+	return nil
+}
+
+func (n *NoopEngine) DeleteRange(r ResolverRange) error {
+	return nil
+}
+
+func (n *NoopEngine) YankRange(r ResolverRange) error {
+	return nil
+}
+
+func (n *NoopEngine) ChangeRange(r ResolverRange) error {
+	return nil
+}
\ No newline at end of file
diff --git a/resolver/resolver.go b/resolver/resolver.go
index d4d2d44..178d696 100644
--- a/resolver/resolver.go
+++ b/resolver/resolver.go
@@ -5,13 +5,6 @@ import (
 	"tmux-fsm/intent"
 )
 
-// ExecContext 执行上下文
-type ExecContext struct {
-	FromRepeat bool // 是否来自重复操作
-	FromMacro  bool // 是否来自宏
-	FromUndo   bool // 是否来自撤销操作
-}
-
 // RepeatableAction 可重复操作
 type RepeatableAction struct {
 	Operator *intent.OperatorKind
@@ -31,9 +24,9 @@ type Resolver struct {
 }
 
 // New 创建新的解析器
-func New(engine EngineAdapter) *Resolver {
+func New(_ EngineAdapter) *Resolver {
 	return &Resolver{
-		engine: engine,
+		engine: &NoopEngine{},
 	}
 }
 
@@ -53,11 +46,6 @@ func (r *Resolver) ResolveWithContext(i *intent.Intent, ctx ExecContext) error {
 		r.recordIntentForMacro(i)
 	}
 
-	// 处理视觉模式切换
-	if err := r.handleVisualMode(i); err != nil {
-		return err
-	}
-
 	var err error
 
 	switch i.Kind {
@@ -77,10 +65,12 @@ func (r *Resolver) ResolveWithContext(i *intent.Intent, ctx ExecContext) error {
 		err = r.resolveMacro(i)
 
 	case intent.IntentEnterVisual:
-		err = r.resolveEnterVisual(i)
+		// 暂时忽略视觉模式相关意图
+		return nil
 
 	case intent.IntentExitVisual:
-		err = r.resolveExitVisual(i)
+		// 暂时忽略视觉模式相关意图
+		return nil
 
 	case intent.IntentRepeatFind:
 		err = r.repeatFind(false)
diff --git a/resolver/selection.go b/resolver/selection.go
deleted file mode 100644
index 5f88e5a..0000000
--- a/resolver/selection.go
+++ /dev/null
@@ -1,10 +0,0 @@
-package resolver
-
-// SelectionMode 选择模式
-type SelectionMode int
-
-const (
-	SelectionChar SelectionMode = iota
-	SelectionLine
-	SelectionBlock
-)
\ No newline at end of file
diff --git a/resolver/semantic_action.go b/resolver/semantic_action.go
deleted file mode 100644
index 9709b07..0000000
--- a/resolver/semantic_action.go
+++ /dev/null
@@ -1,36 +0,0 @@
-package resolver
-
-import (
-	"tmux-fsm/intent"
-)
-
-// SemanticAction 语义动作，代表意图的语义表示
-type SemanticAction struct {
-	Operator  intent.OperatorKind
-	Selection *Selection
-	Motion    intent.MotionKind
-	Target    intent.TargetKind
-	Count     int
-}
-
-// ActionType 语义动作类型
-type ActionType int
-
-const (
-	ActionMove ActionType = iota
-	ActionDelete
-	ActionYank
-	ActionChange
-	ActionVisual
-	ActionUndo
-	ActionRepeat
-	ActionMacro
-)
-
-// Action 代表一个具体的语义动作
-type Action struct {
-	Type        ActionType
-	Semantic    *SemanticAction
-	RawIntent   *intent.Intent
-	Description string
-}
\ No newline at end of file
diff --git a/resolver/visual.go b/resolver/visual.go
deleted file mode 100644
index c904626..0000000
--- a/resolver/visual.go
+++ /dev/null
@@ -1,52 +0,0 @@
-package resolver
-
-import "tmux-fsm/intent"
-
-// handleVisualMode 处理视觉模式切换
-func (r *Resolver) handleVisualMode(i *intent.Intent) error {
-	if i.Kind == intent.IntentVisual {
-		// 使用 Target.Scope 来判断操作
-		switch i.Target.Scope {
-		case "char":
-			return r.EnterVisual(SelectionChar)
-		case "line":
-			return r.EnterVisual(SelectionLine)
-		case "block":
-			return r.EnterVisual(SelectionBlock)
-		case "cancel":
-			return r.ExitVisual()
-		}
-	}
-	return nil
-}
-
-// resolveEnterVisual 解析进入视觉模式意图
-func (r *Resolver) resolveEnterVisual(i *intent.Intent) error {
-	// 通过 Target.Scope 来判断模式
-	switch i.Target.Scope {
-	case "char":
-		return r.EnterVisual(SelectionChar)
-	case "line":
-		return r.EnterVisual(SelectionLine)
-	case "block":
-		return r.EnterVisual(SelectionBlock)
-	}
-	return nil
-}
-
-// resolveExitVisual 解析退出视觉模式意图
-func (r *Resolver) resolveExitVisual(i *intent.Intent) error {
-	return r.ExitVisual()
-}
-
-// EnterVisual 进入视觉模式
-func (r *Resolver) EnterVisual(mode SelectionMode) error {
-	r.engine.EnterVisualMode(intent.VisualMode(mode))
-	return nil
-}
-
-// ExitVisual 退出视觉模式
-func (r *Resolver) ExitVisual() error {
-	r.engine.ExitVisualMode()
-	return nil
-}
\ No newline at end of file
diff --git a/resolver_integration.go b/resolver_integration.go
new file mode 100644
index 0000000..8993651
--- /dev/null
+++ b/resolver_integration.go
@@ -0,0 +1,213 @@
+package main
+
+import (
+	"errors"
+)
+
+// IntentOperate 表示操作意图
+type IntentOperate struct {
+	Operator *Operator
+	Motion   *Motion
+}
+
+// OperatorKind 定义操作符类型
+type OperatorKind int
+
+const (
+	OpNone OperatorKind = iota
+	OpDelete
+	OpYank
+	OpChange
+)
+
+// Operator 表示操作符
+type Operator struct {
+	Kind OperatorKind
+}
+
+// ResolvedOperation 表示解析后的操作
+type ResolvedOperation struct {
+	Operator OperatorKind // OpDelete / OpChange / OpYank / OpNone
+	Motion   MotionKind   // 原始 motion（用于 repeat / undo 语义）
+	Count    int
+
+	From Cursor
+	To   Cursor
+
+	Range *MotionRange // nil 表示纯移动
+}
+
+// Resolver 负责解析意图到具体操作
+type Resolver struct {
+	engine *CursorEngine
+	textObjectCalc *ConcreteTextObjectCalculator
+}
+
+// NewResolver 创建新的解析器
+func NewResolver(engine *CursorEngine) *Resolver {
+	return &Resolver{
+		engine: engine,
+		textObjectCalc: NewConcreteTextObjectCalculator(engine.Buffer),
+	}
+}
+
+// Resolve 解析意图
+func (r *Resolver) Resolve(intent Intent) (*ResolvedOperation, error) {
+	start := *r.engine.Cursor
+
+	switch intent.Kind {
+	case IntentMove:
+		return r.resolveMove(&intent, start)
+	case IntentDelete, IntentChange, IntentYank:
+		return r.resolveOperator(&intent, start)
+	}
+	return nil, errors.New("unknown intent type")
+}
+
+// resolveMove 解析移动意图
+func (r *Resolver) resolveMove(intent *Intent, start Cursor) (*ResolvedOperation, error) {
+	if intent.Target.Kind == TargetTextObject {
+		// 处理文本对象移动
+		obj, err := ParseTextObject(intent.Target.Value)
+		if err != nil {
+			return nil, err
+		}
+
+		textRange, err := r.textObjectCalc.CalculateRange(*obj, start)
+		if err != nil {
+			return nil, err
+		}
+
+		return &ResolvedOperation{
+			Operator: OpNone,
+			Motion:   MotionKind(intent.Target.Kind),
+			Count:    intent.Count,
+			From:     start,
+			To:       textRange.End, // 移动到文本对象的结束位置
+			Range:    textRange,
+		}, nil
+	} else {
+		// 处理普通移动
+		motion := &Motion{
+			Kind:  MotionKind(intent.Target.Kind),
+			Count: intent.Count,
+		}
+
+		mr, err := r.engine.ComputeMotion(motion)
+		if err != nil {
+			return nil, err
+		}
+
+		// 虚拟计算终点（不改 cursor）
+		end := start
+		end.Row += mr.DeltaRow
+		end.Col += mr.DeltaCol
+		end.Row, end.Col = r.clampCursor(end.Row, end.Col)
+
+		return &ResolvedOperation{
+			Operator: OpNone,
+			Motion:   motion.Kind,
+			Count:    motion.Count,
+			From:     start,
+			To:       end,
+			Range:    nil, // 移动通常不产生范围
+		}, nil
+	}
+}
+
+// clampCursor 限制光标位置
+func (r *Resolver) clampCursor(row, col int) (int, int) {
+	if r.engine.Buffer == nil {
+		return row, col
+	}
+
+	row = clamp(row, 0, r.engine.Buffer.LineCount()-1)
+
+	maxCol := 0
+	if row >= 0 && row < r.engine.Buffer.LineCount() {
+		maxCol = r.engine.Buffer.LineLength(row)
+		if maxCol > 0 {
+			maxCol-- // Length 是实际长度，所以最大索引是 Length-1
+		}
+	}
+	col = clamp(col, 0, maxCol)
+
+	return row, col
+}
+
+// resolveOperator 解析操作意图
+func (r *Resolver) resolveOperator(intent *Intent, start Cursor) (*ResolvedOperation, error) {
+	var opKind OperatorKind = OpNone
+	switch intent.Kind {
+	case IntentDelete:
+		opKind = OpDelete
+	case IntentChange:
+		opKind = OpChange
+	case IntentYank:
+		opKind = OpYank
+	}
+
+	var rng *MotionRange
+
+	if intent.Target.Kind == TargetTextObject {
+		// 处理文本对象操作
+		obj, err := ParseTextObject(intent.Target.Value)
+		if err != nil {
+			return nil, err
+		}
+
+		textRange, err := r.textObjectCalc.CalculateRange(*obj, start)
+		if err != nil {
+			return nil, err
+		}
+
+		rng = textRange
+	} else {
+		// 处理普通运动操作
+		motion := &Motion{
+			Kind:  MotionKind(intent.Target.Kind),
+			Count: intent.Count,
+		}
+
+		mr, err := r.engine.ComputeMotion(motion)
+		if err != nil {
+			return nil, err
+		}
+
+		// 虚拟计算终点（不改 cursor）
+		end := start
+		end.Row += mr.DeltaRow
+		end.Col += mr.DeltaCol
+		end.Row, end.Col = r.clampCursor(end.Row, end.Col)
+
+		rng = resolveRange(opKind, start, end, motion.Kind)
+	}
+
+	return &ResolvedOperation{
+		Operator: opKind,
+		Motion:   MotionKind(intent.Target.Kind),
+		Count:    intent.Count,
+		From:     start,
+		To:       start, // 操作后光标位置可能不同，这里先设置为起始位置
+		Range:    rng,
+	}, nil
+}
+
+// resolveRange 计算操作范围
+func resolveRange(op OperatorKind, from Cursor, to Cursor, motion MotionKind) *MotionRange {
+	switch motion {
+	case MotionWordForward:
+		switch op {
+		case OpDelete, OpYank:
+			return &MotionRange{Start: from, End: to}
+		case OpChange:
+			// Vim: cw 不包含 word 后的空白
+			adjusted := to
+			adjusted.Col-- // 简化版
+			return &MotionRange{Start: from, End: adjusted}
+		}
+	}
+
+	// fallback
+	return &MotionRange{Start: from, End: to}
+}
\ No newline at end of file
diff --git a/text_object.go b/text_object.go
new file mode 100644
index 0000000..cbf85b0
--- /dev/null
+++ b/text_object.go
@@ -0,0 +1,528 @@
+package main
+
+import (
+	"errors"
+)
+
+// TextObjectKind 定义文本对象类型
+type TextObjectKind int
+
+const (
+	TextObjectWord TextObjectKind = iota
+	TextObjectParen
+	TextObjectBracket
+	TextObjectBrace
+	TextObjectQuoteDouble
+	TextObjectQuoteSingle
+	TextObjectParagraph
+	TextObjectSentence
+)
+
+// TextObjectMotion 定义文本对象运动
+type TextObjectMotion struct {
+	Kind     TextObjectKind
+	Inner    bool // true for 'i', false for 'a'
+}
+
+// TextObjectRangeCalculator 计算文本对象范围的接口
+type TextObjectRangeCalculator interface {
+	CalculateRange(obj TextObjectMotion, cursor Cursor) (*MotionRange, error)
+}
+
+// ConcreteTextObjectCalculator 实现文本对象范围计算器
+type ConcreteTextObjectCalculator struct {
+	Buffer Buffer
+}
+
+// NewConcreteTextObjectCalculator 创建新的文本对象计算器
+func NewConcreteTextObjectCalculator(buffer Buffer) *ConcreteTextObjectCalculator {
+	return &ConcreteTextObjectCalculator{
+		Buffer: buffer,
+	}
+}
+
+// CalculateRange 计算文本对象范围
+func (calc *ConcreteTextObjectCalculator) CalculateRange(obj TextObjectMotion, cursor Cursor) (*MotionRange, error) {
+	switch obj.Kind {
+	case TextObjectWord:
+		return calc.calculateWordRange(obj.Inner, cursor)
+	case TextObjectParen:
+		return calc.calculateDelimitedRange('(', ')', obj.Inner, cursor)
+	case TextObjectBracket:
+		return calc.calculateDelimitedRange('[', ']', obj.Inner, cursor)
+	case TextObjectBrace:
+		return calc.calculateDelimitedRange('{', '}', obj.Inner, cursor)
+	case TextObjectQuoteDouble:
+		return calc.calculateQuoteRange('"', obj.Inner, cursor)
+	case TextObjectQuoteSingle:
+		return calc.calculateQuoteRange('\'', obj.Inner, cursor)
+	case TextObjectParagraph:
+		return calc.calculateParagraphRange(obj.Inner, cursor)
+	case TextObjectSentence:
+		return calc.calculateSentenceRange(obj.Inner, cursor)
+	default:
+		return nil, errors.New("unsupported text object")
+	}
+}
+
+// calculateWordRange 计算单词范围
+func (calc *ConcreteTextObjectCalculator) calculateWordRange(inner bool, cursor Cursor) (*MotionRange, error) {
+	if calc.Buffer == nil {
+		return nil, errors.New("no buffer available")
+	}
+
+	row := cursor.Row
+	if row < 0 || row >= calc.Buffer.LineCount() {
+		return nil, errors.New("invalid row")
+	}
+
+	line := make([]rune, calc.Buffer.LineLength(row))
+	for i := 0; i < len(line); i++ {
+		line[i] = calc.Buffer.RuneAt(row, i)
+	}
+
+	startCol, endCol := findWordAt(line, cursor.Col, inner)
+
+	return &MotionRange{
+		Start: Cursor{Row: row, Col: startCol},
+		End:   Cursor{Row: row, Col: endCol},
+	}, nil
+}
+
+// findWordAt 查找光标位置的单词范围
+func findWordAt(line []rune, col int, inner bool) (int, int) {
+	if len(line) == 0 || col < 0 {
+		return 0, 0
+	}
+
+	if col >= len(line) {
+		col = len(line) - 1
+	}
+
+	// 确定字符类别
+	charType := classifyRune(line[col])
+
+	// 向左查找边界
+	start := col
+	for start > 0 {
+		if classifyRune(line[start-1]) != charType {
+			break
+		}
+		start--
+	}
+
+	// 向右查找边界
+	end := col
+	for end < len(line)-1 {
+		if classifyRune(line[end+1]) != charType {
+			break
+		}
+		end++
+	}
+
+	// 如果是 inner 模式，去除两端的空白
+	if inner {
+		for start <= end && start < len(line) && isWhitespace(line[start]) {
+			start++
+		}
+		for end > start && end >= 0 && isWhitespace(line[end]) {
+			end--
+		}
+	}
+
+	// 确保 end 在有效范围内
+	if end >= len(line) {
+		end = len(line) - 1
+	}
+
+	// 确保范围有效
+	if start > end {
+		start = end
+	}
+
+	// 如果是 outer 模式，扩展到包含相邻的空白
+	if !inner {
+		// 向右扩展包含空白
+		for end < len(line)-1 && isWhitespace(line[end+1]) {
+			end++
+		}
+		// 向左扩展包含空白
+		for start > 0 && isWhitespace(line[start-1]) {
+			start--
+		}
+	}
+
+	return start, end + 1
+}
+
+// classifyRune 将字符分类
+func classifyRune(r rune) CharClass {
+	switch {
+	case r == ' ' || r == '\t' || r == '\n' || r == '\r':
+		return ClassWhitespace
+	case (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_':
+		return ClassWord
+	default:
+		return ClassPunct
+	}
+}
+
+// isWhitespace 检查是否为空白字符
+func isWhitespace(r rune) bool {
+	return r == ' ' || r == '\t' || r == '\n' || r == '\r'
+}
+
+// calculateDelimitedRange 计算定界符范围
+func (calc *ConcreteTextObjectCalculator) calculateDelimitedRange(open, close rune, inner bool, cursor Cursor) (*MotionRange, error) {
+	if calc.Buffer == nil {
+		return nil, errors.New("no buffer available")
+	}
+
+	// 从当前行开始搜索
+	startPos, endPos := findDelimitedRange(calc.Buffer, open, close, cursor, inner)
+	
+	if startPos.Row == -1 || endPos.Row == -1 {
+		return nil, errors.New("delimited range not found")
+	}
+
+	return &MotionRange{
+		Start: startPos,
+		End:   endPos,
+	}, nil
+}
+
+// findDelimitedRange 查找定界符范围
+func findDelimitedRange(buffer Buffer, open, close rune, cursor Cursor, inner bool) (Cursor, Cursor) {
+	// 从当前光标位置开始查找匹配的定界符
+	currentRow := cursor.Row
+	currentCol := cursor.Col
+	
+	// 首先尝试在当前行查找
+	for row := currentRow; row < buffer.LineCount(); row++ {
+		lineLen := buffer.LineLength(row)
+		startCol := 0
+		if row == currentRow {
+			startCol = currentCol
+		}
+		
+		for col := startCol; col < lineLen; col++ {
+			r := buffer.RuneAt(row, col)
+			if r == open {
+				// 找到开定界符，查找对应的闭定界符
+				endPos := findMatchingDelimiter(buffer, open, close, Cursor{Row: row, Col: col})
+				if endPos.Row != -1 {
+					if inner {
+						// Inner 模式：排除定界符本身
+						return Cursor{Row: row, Col: col + 1}, endPos
+					} else {
+						// Outer 模式：包含定界符
+						return Cursor{Row: row, Col: col}, Cursor{Row: endPos.Row, Col: endPos.Col + 1}
+					}
+				}
+			}
+		}
+	}
+	
+	// 如果没找到，返回无效位置
+	return Cursor{Row: -1, Col: -1}, Cursor{Row: -1, Col: -1}
+}
+
+// findMatchingDelimiter 查找匹配的定界符
+func findMatchingDelimiter(buffer Buffer, open, close rune, startPos Cursor) Cursor {
+	stack := 0
+	currentRow := startPos.Row
+	currentCol := startPos.Col + 1 // 从开定界符的下一个位置开始
+	
+	for row := currentRow; row < buffer.LineCount(); row++ {
+		lineLen := buffer.LineLength(row)
+		startCol := 0
+		if row == currentRow {
+			startCol = currentCol
+		}
+		
+		for col := startCol; col < lineLen; col++ {
+			r := buffer.RuneAt(row, col)
+			if r == open {
+				stack++
+			} else if r == close {
+				stack--
+				if stack < 0 {
+					// 找到匹配的闭定界符
+					return Cursor{Row: row, Col: col}
+				}
+			}
+		}
+		currentCol = 0 // 从下一行开始时，列从0开始
+	}
+	
+	// 没有找到匹配的闭定界符
+	return Cursor{Row: -1, Col: -1}
+}
+
+// calculateQuoteRange 计算引号范围
+func (calc *ConcreteTextObjectCalculator) calculateQuoteRange(quote rune, inner bool, cursor Cursor) (*MotionRange, error) {
+	if calc.Buffer == nil {
+		return nil, errors.New("no buffer available")
+	}
+
+	// 从当前光标位置开始查找引号
+	currentRow := cursor.Row
+	currentCol := cursor.Col
+	
+	// 首先检查光标位置是否在引号内或旁边
+	for row := currentRow; row < calc.Buffer.LineCount(); row++ {
+		lineLen := calc.Buffer.LineLength(row)
+		startCol := 0
+		if row == currentRow {
+			startCol = currentCol
+		}
+		
+		for col := startCol; col < lineLen; col++ {
+			r := calc.Buffer.RuneAt(row, col)
+			if r == quote {
+				// 找到第一个引号，查找匹配的另一个
+				endPos := findMatchingQuote(calc.Buffer, quote, Cursor{Row: row, Col: col})
+				if endPos.Row != -1 {
+					if inner {
+						// Inner 模式：排除引号本身
+						return &MotionRange{
+							Start: Cursor{Row: row, Col: col + 1},
+							End:   endPos,
+						}, nil
+					} else {
+						// Outer 模式：包含引号
+						return &MotionRange{
+							Start: Cursor{Row: row, Col: col},
+							End:   Cursor{Row: endPos.Row, Col: endPos.Col + 1},
+						}, nil
+					}
+				}
+			}
+		}
+	}
+	
+	return nil, errors.New("quote range not found")
+}
+
+// findMatchingQuote 查找匹配的引号
+func findMatchingQuote(buffer Buffer, quote rune, startPos Cursor) Cursor {
+	escaped := false
+
+	currentRow := startPos.Row
+	currentCol := startPos.Col + 1 // 从第一个引号的下一个位置开始
+
+	for row := currentRow; row < buffer.LineCount(); row++ {
+		lineLen := buffer.LineLength(row)
+		startCol := 0
+		if row == currentRow {
+			startCol = currentCol
+		}
+
+		for col := startCol; col < lineLen; col++ {
+			r := buffer.RuneAt(row, col)
+
+			if escaped {
+				escaped = false
+				continue
+			}
+
+			if r == '\\' {
+				escaped = true
+				continue
+			}
+
+			if r == quote {
+				// 找到匹配的引号
+				return Cursor{Row: row, Col: col}
+			}
+		}
+		currentCol = 0 // 从下一行开始时，列从0开始
+	}
+
+	// 没有找到匹配的引号
+	return Cursor{Row: -1, Col: -1}
+}
+
+// calculateParagraphRange 计算段落范围
+func (calc *ConcreteTextObjectCalculator) calculateParagraphRange(inner bool, cursor Cursor) (*MotionRange, error) {
+	if calc.Buffer == nil {
+		return nil, errors.New("no buffer available")
+	}
+
+	// 简化实现：查找空行分隔的段落
+	startRow := cursor.Row
+	endRow := cursor.Row
+
+	// 向上查找段落开始
+	for startRow > 0 {
+		lineLen := calc.Buffer.LineLength(startRow - 1)
+		if lineLen == 0 {
+			break
+		}
+		startRow--
+	}
+
+	// 向下查找段落结束
+	for endRow < calc.Buffer.LineCount()-1 {
+		lineLen := calc.Buffer.LineLength(endRow + 1)
+		if lineLen == 0 {
+			break
+		}
+		endRow++
+	}
+
+	if inner {
+		// Inner 模式：排除段落周围的空行
+		return &MotionRange{
+			Start: Cursor{Row: startRow, Col: 0},
+			End:   Cursor{Row: endRow, Col: calc.Buffer.LineLength(endRow)},
+		}, nil
+	} else {
+		// Outer 模式：包含整个段落
+		return &MotionRange{
+			Start: Cursor{Row: startRow, Col: 0},
+			End:   Cursor{Row: endRow + 1, Col: 0}, // 包含下一行的开始
+		}, nil
+	}
+}
+
+// calculateSentenceRange 计算句子范围
+func (calc *ConcreteTextObjectCalculator) calculateSentenceRange(inner bool, cursor Cursor) (*MotionRange, error) {
+	if calc.Buffer == nil {
+		return nil, errors.New("no buffer available")
+	}
+
+	// 简化实现：查找句号、感叹号、问号分隔的句子
+	currentRow := cursor.Row
+	currentCol := cursor.Col
+
+	// 查找当前句子的开始
+	startRow, startCol := findSentenceStart(calc.Buffer, currentRow, currentCol)
+
+	// 查找当前句子的结束
+	endRow, endCol := findSentenceEnd(calc.Buffer, currentRow, currentCol)
+
+	if inner {
+		// Inner 模式：排除句子结束标点
+		return &MotionRange{
+			Start: Cursor{Row: startRow, Col: startCol},
+			End:   Cursor{Row: endRow, Col: endCol},
+		}, nil
+	} else {
+		// Outer 模式：包含句子结束标点及后续空白
+		// 简化：包含到句子结束
+		return &MotionRange{
+			Start: Cursor{Row: startRow, Col: startCol},
+			End:   Cursor{Row: endRow, Col: endCol + 1},
+		}, nil
+	}
+}
+
+// findSentenceStart 查找句子开始
+func findSentenceStart(buffer Buffer, row, col int) (int, int) {
+	// 简化实现：查找前一个句子结束符后的第一个非空白字符
+	for r := row; r >= 0; r-- {
+		lineLen := buffer.LineLength(r)
+		startCol := lineLen - 1
+		if r == row {
+			startCol = col
+		}
+		
+		for c := startCol; c >= 0; c-- {
+			runeVal := buffer.RuneAt(r, c)
+			if runeVal == '.' || runeVal == '!' || runeVal == '?' {
+				// 找到句子结束符，下一个位置是句子开始
+				nextRow, nextCol := getNextNonWhitespace(buffer, r, c+1)
+				return nextRow, nextCol
+			}
+		}
+	}
+	
+	// 如果没找到，返回文件开始
+	return 0, 0
+}
+
+// findSentenceEnd 查找句子结束
+func findSentenceEnd(buffer Buffer, row, col int) (int, int) {
+	// 简化实现：查找下一个句子结束符
+	for r := row; r < buffer.LineCount(); r++ {
+		lineLen := buffer.LineLength(r)
+		startCol := 0
+		if r == row {
+			startCol = col
+		}
+		
+		for c := startCol; c < lineLen; c++ {
+			runeVal := buffer.RuneAt(r, c)
+			if runeVal == '.' || runeVal == '!' || runeVal == '?' {
+				// 找到句子结束符
+				return r, c
+			}
+		}
+	}
+	
+	// 如果没找到，返回文件结束
+	endRow := buffer.LineCount() - 1
+	endCol := buffer.LineLength(endRow)
+	return endRow, endCol
+}
+
+// getNextNonWhitespace 获取下一个非空白字符位置
+func getNextNonWhitespace(buffer Buffer, row, col int) (int, int) {
+	for r := row; r < buffer.LineCount(); r++ {
+		lineLen := buffer.LineLength(r)
+		startCol := 0
+		if r == row {
+			startCol = col
+		}
+		
+		for c := startCol; c < lineLen; c++ {
+			runeVal := buffer.RuneAt(r, c)
+			if !isWhitespace(runeVal) {
+				return r, c
+			}
+		}
+	}
+	
+	// 如果没找到，返回当前位置
+	return row, col
+}
+
+// ParseTextObject 解析文本对象字符串
+func ParseTextObject(textObjectStr string) (*TextObjectMotion, error) {
+	if len(textObjectStr) < 2 {
+		return nil, errors.New("invalid text object string")
+	}
+
+	modifier := textObjectStr[0:1]
+	objType := textObjectStr[1:2]
+
+	inner := modifier == "i"
+	
+	var kind TextObjectKind
+	switch objType {
+	case "w":
+		kind = TextObjectWord
+	case "(":
+		kind = TextObjectParen
+	case "[":
+		kind = TextObjectBracket
+	case "{":
+		kind = TextObjectBrace
+	case "\"":
+		kind = TextObjectQuoteDouble
+	case "'":
+		kind = TextObjectQuoteSingle
+	case "p":
+		kind = TextObjectParagraph
+	case "s":
+		kind = TextObjectSentence
+	default:
+		return nil, errors.New("unsupported text object type")
+	}
+
+	return &TextObjectMotion{
+		Kind:  kind,
+		Inner: inner,
+	}, nil
+}
\ No newline at end of file
