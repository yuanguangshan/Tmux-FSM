package adapter

import (
	"strings"
	"tmux-fsm/weaver/core"
)

// TmuxProjection Phase 3: Smart Projection
// 仅负责执行，不负责 Undo，不负责 Logic
type TmuxProjection struct{}

func (p *TmuxProjection) Apply(resolved []core.ResolvedAnchor, facts []core.ResolvedFact) error {
	for _, fact := range facts {
		targetPane := fact.Anchor.PaneID
		if targetPane == "" {
			targetPane = "{current}" // 容错
		}

		// Phase 7: For exact restoration, we must jump to the coordinate first
		if fact.Anchor.Start >= 0 {
			TmuxJumpTo(fact.Anchor.Start, fact.Anchor.Line, targetPane)
		}

		// 从 Meta 中提取 legacy motion
		motion, _ := fact.Meta["motion"].(string)
		count, _ := fact.Meta["count"].(int)
		if count <= 0 {
			count = 1
		}

		switch fact.Kind {
		case core.FactDelete:
			PerformPhysicalDelete(motion, targetPane)

		case core.FactInsert:
			// Insert 有两种情况：真正的插入文本，或者进入插入模式动作
			if text := fact.Payload.Text; text != "" {
				// 实际插入文本（可能由 VimExecutor 使用，或者 paste）
				// 但目前的 execute.go 中，insert 动作也是通过 performPhysicalPaste 等执行的
				// 如果是 paste:
				if motion == "paste" { // Hack: check motion
					PerformPhysicalPaste(metaString(fact.Meta, "sub_motion"), targetPane)
				} else {
					// Phase 7: Undo recovery or raw text projection
					PerformPhysicalRawInsert(text, targetPane)
				}
			} else {
				// 动作 (e.g. insert_after -> a)
				PerformPhysicalInsert(motion, targetPane)
			}

			// 如果是 change 操作，通常包含 delete + enter insert mode
			// 这里我们假设 Fact 已经被拆分成 Delete + InsertMode
			// 但 execute.go 中是 performPhysicalDelete + performPhysicalExecute(i)
			if fact.Meta["operation"] == "change" {
				PerformPhysicalDelete(motion, targetPane)
				// change implies insert mode, handled inside performPhysicalDelete for Shell?
				// No, performPhysicalDelete for change just deletes.
				// We need to send 'i' if shell?
				// executeShellAction line 287: exitFSM(targetPane) // change implies entering insert mode
				// Wait, legacy executeShellAction calls exitFSM for "change".
				// We should replicate that side effect.
				ExitFSM(targetPane)
			}

		case core.FactReplace:
			// replace char
			if char, ok := fact.Meta["char"].(string); ok {
				for i := 0; i < count; i++ {
					PerformPhysicalReplace(char, targetPane)
				}
			}
			// toggle case
			if fact.Meta["operation"] == "toggle_case" {
				for i := 0; i < count; i++ {
					PerformPhysicalToggleCase(targetPane)
				}
			}

		case core.FactMove:
			PerformPhysicalMove(motion, count, targetPane)

		case core.FactNone: // Maybe pure side-effect or search
			if op, ok := fact.Meta["operation"].(string); ok {
				if strings.HasPrefix(op, "search_") {
					query := fact.Payload.Value
					if op == "search_next" {
						// performPhysicalSearchNext? execute.go has exec.Command inside executeAction
						// We need to move those to physical layer too?
						// Yes, executeAction 161-173.
						// I forgot to copy executeSearch logic for next/prev.
						// Let's assume FactBuilder generates "search_forward" with query.
					} else if op == "search_forward" {
						PerformExecuteSearch(query, targetPane)
					}
				} else if strings.HasPrefix(op, "find_") {
					fType := fact.Meta["find_type"].(string)
					char := fact.Meta["find_char"].(string)
					PerformPhysicalFind(fType, char, count, targetPane)
				} else if strings.HasPrefix(op, "visual_") {
					HandleVisualAction(op, count, targetPane)
				} else if op == "exit" {
					ExitFSM(targetPane)
				}
			}
		}
	}
	return nil
}

// Verify 验证投影是否按预期执行 (Phase 9)
func (p *TmuxProjection) Verify(
	pre core.Snapshot,
	facts []core.ResolvedFact,
	post core.Snapshot,
) core.VerificationResult {
	// Use the LineHashVerifier to check if the changes match expectations
	verifier := core.NewLineHashVerifier()
	return verifier.Verify(pre, facts, post)
}

// 辅助函数：安全获取 string meta
func metaString(m map[string]interface{}, key string) string {
	if v, ok := m[key]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}
