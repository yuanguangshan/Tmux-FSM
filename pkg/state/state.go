package state

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sync"
	"time"
	"tmux-fsm/fsm"
)

// Transaction 事务结构（简化版）
// TODO: Phase-3 undo/redo transaction log
type Transaction struct {
	ID               int           `json:"id"`
	Records          []interface{} `json:"records"`
	CreatedAt        string        `json:"created_at"`
	Applied          bool          `json:"applied"`
	Skipped          bool          `json:"skipped"`
	SafetyLevel      string        `json:"safety_level,omitempty"`
	PreSnapshotHash  string        `json:"pre_snapshot_hash,omitempty"`
	PostSnapshotHash string        `json:"post_snapshot_hash,omitempty"`
}

// FSMState represents the state of the FSM
type FSMState struct {
	Mode                 string                 `json:"mode"`
	Operator             string                 `json:"operator"`
	Count                int                    `json:"count"`
	PendingKeys          string                 `json:"pending_keys"`
	Register             string                 `json:"register"`
	LastRepeatableAction map[string]interface{} `json:"last_repeatable_action"`
	UndoStack            []Transaction          `json:"undo_stack"`
	RedoStack            []Transaction          `json:"redo_stack"`
	LastUndoFailure      string                 `json:"last_undo_failure,omitempty"`
	LastUndoSafetyLevel  string                 `json:"last_undo_safety_level,omitempty"`
	AllowPartial         bool                   `json:"allow_partial"` // Phase 7: Explicit permission for fuzzy resolution
}

// StateManager manages the global state
type StateManager struct {
	mutex   sync.Mutex
	state   FSMState
	backend Backend
}

// Backend interface for interacting with tmux
type Backend interface {
	GetUserOption(option string) (string, error)
	SetUserOption(option, value string) error
	RefreshClient(clientName string) error
	SwitchClientTable(clientName, table string) error
	GetActivePane(clientName string) (string, error)
}

// NewStateManager creates a new state manager
func NewStateManager(backend Backend) *StateManager {
	return &StateManager{
		backend: backend,
	}
}

// LoadState loads the state from tmux options
func (sm *StateManager) LoadState() FSMState {
	sm.mutex.Lock()
	defer sm.mutex.Unlock()

	// Use backend to read tmux options
	out, err := sm.backend.GetUserOption("@tmux_fsm_state")
	var state FSMState
	if err != nil || len(out) == 0 {
		return FSMState{Mode: "NORMAL", Count: 0}
	}
	json.Unmarshal([]byte(out), &state)
	sm.state = state
	return state
}

// SaveStateRaw saves the raw state data to tmux options
func (sm *StateManager) SaveStateRaw(data []byte) {
	sm.mutex.Lock()
	defer sm.mutex.Unlock()

	// Use backend to save state
	// This implies SetUserOption needs to be able to set arbitrary keys.
	if err := sm.backend.SetUserOption("@tmux_fsm_state", string(data)); err != nil {
		log.Printf("Failed to save FSM state: %v", err)
	}
}

// UpdateStatusBar updates the status bar display
func (sm *StateManager) UpdateStatusBar(state FSMState, clientName string) {
	modeMsg := state.Mode
	if modeMsg == "" {
		modeMsg = "NORMAL"
	}

	// 融合显示逻辑
	activeLayer := fsm.GetActiveLayer()
	if activeLayer != "NAV" && activeLayer != "" {
		modeMsg = activeLayer // Override with FSM layer if active
	} else {
		// Translate legacy FSM modes for display
		switch modeMsg {
		case "VISUAL_CHAR":
			modeMsg = "VISUAL"
		case "VISUAL_LINE":
			modeMsg = "V-LINE"
		case "OPERATOR_PENDING":
			modeMsg = "PENDING"
		case "REGISTER_SELECT":
			modeMsg = "REGISTER"
		case "MOTION_PENDING":
			modeMsg = "MOTION"
		case "SEARCH":
			modeMsg = "SEARCH"
		}
	}

	if state.Operator != "" {
		modeMsg += fmt.Sprintf(" [%s]", state.Operator)
	}
	if state.Count > 0 {
		modeMsg += fmt.Sprintf(" [%d]", state.Count)
	}

	keysMsg := ""
	if state.PendingKeys != "" {
		if state.Mode == "SEARCH" {
			keysMsg = fmt.Sprintf(" /%s", state.PendingKeys)
		} else {
			keysMsg = fmt.Sprintf(" (%s)", state.PendingKeys)
		}
	}

	if state.LastUndoSafetyLevel == "fuzzy" {
		keysMsg += " ~UNDO"
	} else if state.LastUndoFailure != "" {
		keysMsg += " !UNDO_FAIL"
	}

	// Debug logging
	f, _ := os.OpenFile(os.Getenv("HOME")+"/tmux-fsm.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if f != nil {
		fmt.Fprintf(f, "[%s] Updating status: mode=%s, state.Mode=%s, keys=%s\n",
			time.Now().Format("15:04:05"), modeMsg, state.Mode, keysMsg)
		f.Close()
	}

	// Use backend for tmux option updates
	sm.backend.SetUserOption("@fsm_state", modeMsg)
	sm.backend.SetUserOption("@fsm_keys", keysMsg)
	sm.backend.RefreshClient(clientName) // Refresh the target client

	// --- [ABI: Heartbeat Lock] ---
	// Re-assert the key table to prevent "one-shot" dropouts.
	// Check @fsm_active to allow intentional exits.
	if clientName != "" && clientName != "default" {
		// Fetching @fsm_active via backend if it were available would be ideal,
		// but for now, we rely on the fact that we are in a state where we should be active.
		// If backend could read options, it would be better.
		// For now, we assume if we got here, FSM is active.
		sm.backend.SwitchClientTable(clientName, "fsm")
	}
}

// GetState returns the current state
func (sm *StateManager) GetState() FSMState {
	sm.mutex.Lock()
	defer sm.mutex.Unlock()
	return sm.state
}

// SetState sets the current state
func (sm *StateManager) SetState(state FSMState) {
	sm.mutex.Lock()
	defer sm.mutex.Unlock()
	sm.state = state
}
